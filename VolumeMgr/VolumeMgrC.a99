****************************************
* VOLUME MANAGER                       *
* For TI-99/4a SD CARD FDC EMULATOR    *
* By Dennis D Hatton Sr                *
* Sept 2021                            *
****************************************

EAREG	EQU >2094	;EA Registers
DSRREG EQU >209A
MYREG	EQU >2700	;My Registers
BUFF1	EQU >2720	;223 bytes
DSKNUM	EQU >27FD	;Saved disk number for DSK1-3 (3 bytes)
BUFF2	EQU >2800	;6144 bytes available, 2880 used
KEYBUF EQU BUFF1
*R7 = Current Volume
*
	AORG >6000	;Standard Header (ROM can have programs)
	BYTE >AA	;6000	Identification
	BYTE >01	;6001	Version number
	BYTE 0		;6002	Number of programs
	BYTE 0		;6003	Reserved
	DATA 0		;6004	Power up routine header
	DATA PRGM	;6006	User program header
	DATA 0		;6008	DSR header
	DATA 0		;600A	Subroutine link header
	DATA 0		;600C	Address of interrupt link
	DATA 0		;600E	Address of BASIC subroutine libraries
***
PRGM	DATA >0000
	DATA START	
	BYTE _MSG1-MSG1
MSG1	TEXT 'VOLUME MANAGER'
_MSG1
*
MSG2	TEXT 'SPACE=NXT F9=BACK 1-3=CAT_DSK1-3'
_MSG2
MSG3	TEXT 'READING VOLUME NAMES'
_MSG3
MSG4	TEXT 'DSK1.     DSK2.     DSK3.     '
_MSG4
MSG5	TEXT '  SENDING VOLUME'
_MSG5
MSG6	TEXT 'RECEIVING VOLUME'
_MSG6
MSG7	TEXT 'CATALOG DISK'
_MSG7
MSG8	TEXT '  DSK1 -  DISKNAME=             '
	TEXT '  AVAILABLE=      USED=         '
	TEXT '   FILENAME  SIZE    TYPE    P  '
	TEXT '  ---------- ---- ---------- -  '
_MSG8
MSG9	TEXT 'TRANSFER FAILED OR CANCELED'
_MSG9
MSG10	TEXT 'TRANSFER COMPLETE'
_MSG10
MSG11	TEXT 'PRESS ANY KEY TO RETURN'
_MSG11
****************************************
*Help Message
****************************************
MSG12	TEXT '(H) HELP'
_MSG12	BYTE 13,13
	TEXT 'FCTN(=) QUIT'
	BYTE 13
	TEXT 'FCTN(9) BACK'
	BYTE 13,13
	TEXT '(E),FCTN(E) UP'
	BYTE 13
	TEXT '(X),FCTN(X) DOWN'
	BYTE 13
	TEXT '(S),FCTN(S) LEFT'
	BYTE 13
	TEXT '(D),FCTN(D) RIGHT'
	BYTE 13
	TEXT '(SPACEBAR) PAGE DOWN'
	BYTE 13,13
	TEXT '(1) MOUNT VOLUME DSK1'
	BYTE 13
	TEXT '(2) MOUNT VOLUME DSK2'
	BYTE 13
	TEXT '(3) MOUNT VOLUME DSK3'
	BYTE 13,13
	TEXT 'FCTN(1) CATALOG DSK1'
	BYTE 13
	TEXT 'FCTN(2) CATALOG DSK2'
	BYTE 13
	TEXT 'FCTN(3) CATALOG DSK3'
	BYTE 13
	TEXT '(ENTER) CATALOG VOLUME'
	BYTE 0
	EVEN
****************************************
TYPTBL	TEXT 'DIS/FIX DIS/VAR INT/FIX INT/VAR PROGRAM'
ASCII0	TEXT '0'
BF	BYTE >BF
SPACE	EQU MSG4+5
;DOT	EQU MSG4+4	;Defined in DSRLNK
*********************
	EVEN
PABBUF	EQU >1000
PAB	EQU >F80
STATUS	EQU >837C
PNTR	EQU >8356
PDATA	DATA >000D,PABBUF,>0000,>0000,>0005
	TEXT 'DSK1.'
	EVEN
READ	BYTE >02
CLOSE	BYTE >01
*********************
	EVEN
N10	DATA 10
N100	DATA 100
N1000	DATA 1000
N48	DATA 48
N3	DATA 3
N80	DATA 80
H1000	DATA >1000
H8000	DATA >8000
H00	BYTE 0
H0D	BYTE 13
	EVEN
**********************
*Sprite Attributes
SPRATR	BYTE 32,0,128,9
	BYTE 32,16,128,9
	BYTE 32,32,128,9
	BYTE 32,48,128,9
	BYTE >D0
SPRPAT	BYTE >00,>00,>00,>FF,>00,>00,>00,>FF
	EVEN
	
START	LWPI MYREG		
	CLR @>8374		;Set scan for complete keyboard
	CLR R7			;Set current volume = 000
	
****************************************
*** Get VOLUME names from FDC
****************************************
GETNAM	LI R12,>1100		;Disk CRU address
	SBO 0			;Turn disk card on
	LI R0,>7D00		;Command >82 inverted
	MOVB R0,@>5FF8		;Send command

* Display 'READING VOLUME NAMES'
	LI R0,ROW8+1		;
	LI R1,MSG3		
	LI R2,_MSG3-MSG3	;
	BLWP @VMBW
	AI R0,_MSG3-MSG3	;
	MOVB @DOT,R1		;'.'

	LI R5,DSKNUM
	LI R4,3			;3 drives
LP05	MOVB @>5FFE,R6		;Get DSKx Volume
	INV R6
	MOVB R6,*R5+		;Store in BUFF1
	DEC R4			;Next
	JNE LP05		; "

	LI R5,BUFF2		
	LI R2,256		;256 Volumes
	CLR R3			;Volume number 0
LP01	BLWP @VSBW		;Put '.' on screen
	INC R0			;Inc screen position
*** Remark below to test on emulator	
	LI R4,10		;10 Chars per disk name
LP08	MOVB @>5FFE,R6		;Get Char
	INV R6			;Invert
	MOVB R6,*R5+		;Store Char in buffer
	DEC R4			;Next Char
	JNE LP08		; "
*** Use for testing on emulator
*	LI R6,'T '
*	MOVB R6,*R5+
*	LI R6,'I '
*	MOVB R6,*R5+
*	LI R6,'V '
*	MOVB R6,*R5+
*	LI R6,'O '
*	MOVB R6,*R5+
*	LI R6,'L '
*	MOVB R6,*R5+
*	MOV R3,R9
*	INC R3
*	LI R1,BUFF1
*	BL @CV2ASC
*	MOVB @BUFF1+1,*R5+
*	MOVB @BUFF1+2,*R5+
*	MOVB @BUFF1+3,*R5+
*	LI R6,'  '
*	MOVB R6,*R5+
*	MOVB R6,*R5+
***	
	DEC R2			;Next Volume
	JNE LP01		; "
	SBZ 0			;Turn disk card off
	
*Pad rest of buffer with space	
	LI R2,320		
	LI R6,'  '
LP18	MOVB R6,*R5+
	DEC R2
	JNE LP18
	
*Set sprite attributes	
	LI R0,768
	LI R1,SPRATR
	LI R2,17
	BLWP @VMBW
	
	LI R0,>0400		;Hi-Lite pattern
	LI R1,SPRPAT
	LI R2,8
	BLWP @VMBW
	
	LI R0,>E101		;Magnify 2 sprites
	MOVB R0,@>83D4
	SWPB R0
	BLWP @VWTR
****************************************
*** Put header and footer on screen
****************************************
MAIN	BL @CLS			;Clear screen

	LI R0,ROW0+9		;Header
	LI R1,MSG1
	LI R2,_MSG1-MSG1	;
	BLWP @VMBW

	BL @DSPDSK		;Drives disk names
 
	LI R0,ROW22+22		;Footer
	LI R1,MSG12
	LI R2,_MSG12-MSG12	;
	BLWP @VMBW
	
****************************************
*** Display volume names
****************************************
DSPNAM	ANDI R7,>00FF		;Wrap around Volume number 0-255		
	CLR R0			;Clear MSWord
	MOV R7,R1		;Get current volume number
	DIV @N48,R0		;Calc page number 0-5
	MOV R1,R4		;Remainder = selection on page
	
	MPY @N48,R0		;Calc 1st volume number on page
	MOV R1,R0		;Times ten for location in buffer
	MPY @N10,R0		; "
	AI R1,BUFF2		;Point to 1st volume address in buffer

	LI R3,16		;16 Rows on page
	LI R2,10		;10 chars
	LI R0,ROW5		;Starting row
LP02	BLWP @VMBW
	AI R0,11
	AI R1,10
	BLWP @VMBW
	AI R0,11
	AI R1,10
	BLWP @VMBW
	AI R0,10
	AI R1,10
	DEC R3
	JNE LP02

* Hi-Lite current volume
	CLR R3
	DIV @N3,R3		;R3=Row,R4=Col
	SLA R3,3		;R3*8 dot row
	AI R3,32		;Starting dot row
	
	LI R0,768		;Write row to sprite 0
	MOV R3,R1		; "
	SWPB R1			; "
	BLWP @VSBW		; "
	AI R0,4			;Write row to sprite 1
	BLWP @VSBW		; "
	AI R0,4			;Write row to sprite 2
	BLWP @VSBW		; "
	AI R0,4			;Write row to sprite 3
	BLWP @VSBW		; "	
***
	MPY @N80,R4		;R4 times (8*10) dots per volume
	AI R5,0			;Starting dot column
	CI R5,80
	JLT JP16
	AI R5,8			;First char space between columns
	CI R5,160
	JLT JP16
	AI R5,8			;Second char space between columns
	
JP16	LI R0,769		;Write col to sprite 0
	MOV R5,R1		; "
	SWPB R1			; "
	BLWP @VSBW		; "
	AI R0,4			;Write col to sprite 1
	AI R1,>1000		;Add 16 dots wide per sprite
	BLWP @VSBW		; "
	AI R0,4			;Write col to sprite 2
	AI R1,>1000		;Add 16 dots wide per sprite
	BLWP @VSBW		; "
	AI R0,4			;Write col to sprite 3
	AI R1,>1000		;Add 16 dots wide per sprite
	BLWP @VSBW		; "
***
* Display current selected volume
	MOV R7,R9
	LI R1,BUFF1
	BL @CV2ASC
	
	LI R1,BUFF1+1		;Display Volume number
	LI R0,ROW22+2
	LI R2,3
	BLWP @VMBW
	
	MOV R7,R0		;Times ten for location in buffer
	MPY @N10,R0		; "
	AI R1,BUFF2		;Point to 1st volume address in buffer
	LI R0,ROW22+6	
	LI R2,10		;Display 10 characters
	BLWP @VMBW


****************************************
*** Get input from keyboard
****************************************
GETKEY	BLWP @KSCAN
	MOVB @STATUS,R0
	JEQ GETKEY

	CLR R3
	MOVB @>8375,R3
	CI R3,>0500		;FCTN '=' QUIT
	JEQ QUIT

	CI R3,>3100		;'1' Change DSK1
	JEQ JP04
	CI R3,>3200		;'2' Change DSK2
	JEQ JP04  
	CI R3,>3300		;'3' Change DSK3
	JNE JP15
JP04   	ANDI R3,>0300		;31-32 to 1-3
	BL @CHGDSK		;Call change disk
 	BL @DSPDSK		;Call display drives
	JMP GETKEY		;Loop back to kscan
  
JP15	CI R3,>0300		;FCTN '1' Catalog DSK1	
	JEQ JP21
	CI R3,>0400		;FCTN '2' Catalog DSK2	
	JEQ JP21
	CI R3,>0700		;FCTN '3' Catalog DSK3
	JEQ JP21
	CI R3,>0D00		;ENTER Catalog Current Volume
	JNE JP22
	LI R3,>0300		;Use Drive 3
	BL @CHGDSK		;Change volume
	LI R3,>0700		;Catalog Drive 3
JP21	SRL R3,1		;	
	JMP CATDSK
	
JP22	CI R3,>0E00		;FCTN-5 Transmit volume to PC
	JNE JP23
	BL @XFRSND
	B @GETNAM
JP23	CI R3,>0C00		;FCTN-6 Receive Volume from PC
	JNE JP24
	BL @XFRRCV
	B @GETNAM		;Re-read volume names If changed
	
JP24	ANDI R3,>DF00		;If lowercase,make uppercase
	CI R3,>5800		;'X'	Arrow Down
	JEQ JP17
	CI R3,>0A00		;Fctn-X
	JNE JP00
JP17	AI R7,3
	B @DSPNAM

JP00	CI R3,>4500		;'E'	Arrow Up
	JEQ JP18
	CI R3,>0B00		;Fctn-E
	JNE JP01
JP18	AI R7,-3
	B @DSPNAM
	
JP01	CI R3,>5300		;'S'	Arrow Left
	JEQ JP19
	CI R3,>0800		;Fctn-S
	JNE JP02
JP19	DEC R7
	B @DSPNAM
	
JP02	CI R3,>4400		;'D'	Arrow Right
	JEQ JP20
	CI R3,>0900		;Fctn-D
	JNE JP03
JP20	INC R7
	B @DSPNAM
	
JP03	CI R3,>0000		;' '	Space PGDN	
	JNE JP30
	AI R7,48
	B @DSPNAM
	
JP30	CI R3,>4800		;'H'	HELP
	JNE GETKEY		;Loop back to kscan	
	BL @CLS
	LI R0,ROW1
	LI R1,MSG12
	BL @PRINT
	BL @ANYKY1
	B @MAIN

QUIT	BLWP @>0000		;reset
****************************************
*	Catalog disk
* Entry: MSB R3=drive #
****************************************
CATDSK
	BL @CLS

	LI R0,ROW0+10		;Catalog
	LI R1,MSG7
	LI R2,_MSG7-MSG7	;
	BLWP @VMBW

	LI R0,ROW22		;Footer
	LI R1,MSG2
	LI R2,_MSG2-MSG2	;
	BLWP @VMBW

	LI R0,ROW2		;Disk info at top
	LI R1,MSG8
	LI R2,_MSG8-MSG8	;
	BLWP @VMBW

	ORI R3,>3000		;Value to ASCII
	MOVB R3,R1
	LI R0,ROW2+5		;Replace DSK# on screen
	BLWP @VSBW		

	BL @DSROP
	BL @DSRRD

	LI R0,ROW2+20		;Display disk name
	LI R1,BUFF1		;Point to name in buffer
	MOVB *R1+,R2		;Name length (Should be 10)
	SRL R2,8
	MOV R2,R5
	BLWP @VMBW
		
	LI R0,BUFF1+11		;Point total sectors Float
	A R5,R0			;Add name length
	BL @FL2INT		;R9 = Integer on return
	MOV R9,R3		;Save total Int

 	LI R0,BUFF1+20		;;Point available sectors Float
	A R5,R0			;Add name length
	BL @FL2INT		;
	S R9,R3			;R3 = Used sectors (total - available)

	LI R0,ROW3+12		;Put AVAILABLE sectors on screen
	BL @DSPINT

	MOV R3,R9
	LI R0,ROW3+23		;Put USED sectors on screen
	BL @DSPINT
***
LP16
	LI R0,ROW6
	LI R1,>2000
	LI R2,448
LP15	BLWP @VSBW
	INC R0		
	DEC R2
	JNE LP15	

	LI R4,14
	LI R3,ROW6+2
LP14
	BL @DSRRD		;Read record into BUFF1
	LI R1,BUFF1
	MOVB *R1+,R2		;File name Char count
	SRL R2,8		;
	JEQ LP13		;All read
	MOV R2,R5		;Save name length
 	MOV R3,R0		;Restore Row address
	BLWP @VMBW		;Display file name
*
	LI R0,BUFF1+11		;Size offset from name
	A R5,R0		;Add name length
	BL @FL2INT		;R9 = Integer on return
	MOV R3,R0		;Restore Row address
	AI R0,11		;Screen address for Size
	BL @DSPINT		;Display size
*
 	LI R0,BUFF1+20		;Record size
	A R5,R0		;
	BL @FL2INT		;
	CI R9,0		;Is type Program?
	JEQ JP11		;
	MOV R3,R0		;Restore Row address
	AI R0,22		;
	BL @DSPINT		;
*
JP11	LI R0,BUFF1+2		;Type
	A R5,R0		;Add name length 
	MOVB *R0+,R9		;MSByte BF or 40,LSBYTE type 0-5
	SWPB R9
	MOVB *R0,R9
	SWPB R9
	LI R10,>2000		;' '
	CB R9,@BF		;Protected?
	JNE JP14		;Not protected
	LI R10,>5900		;'Y'	
	INV R9			;0-4
	INC R9			;1-5

JP14	ANDI R9,>00FF		;
 
	MOV R3,R0		;Restore Row address
	AI R0,16		;Screen address for Type
	LI R1,TYPTBL		;Point type table
	DEC R9			;1-5 to 0-4
	SLA R9,3		;Times 8
	A R9,R1
	LI R2,7
	BLWP @VMBW
	
	MOV R3,R0		;Restore Row address
	AI R0,27		;Screen address for Protected
	MOV R10,R1		;Point type table
	BLWP @VSBW
*	
	AI R3,32		;Next row	
	DEC R4
	JNE LP14

LP13	BLWP @KSCAN
	MOVB @STATUS,R0
	JEQ LP13
	CLR R3
	MOVB @>8375,R3
	CI R3,>0F00		;FCTN '9' BACK
	JEQ JP08
	CI R3,>3100		;'1' Catalog DSK1
	JEQ JP12
	CI R3,>3200		;'2' Catalog DSK2
	JEQ JP12  
	CI R3,>3300		;'3' Catalog DSK3
	JEQ JP12

	CI R2,0			;Was last record read empty?
	JEQ LP13		
	JMP LP16		;Any other key next screen
	
JP12	BL @DSRCL		;New drive
	B @CATDSK
	
JP08	BL @DSRCL		;Back
	B @MAIN			


********************************************************************************
* Subroutines
********************************************************************************

* Float to Integer
* Entry: R0=pointer float Exit: R9=Int
FL2INT
	MOVB *R0+,R9 
	ANDI R9,>0100	;40 1 byte 41 2 bytes
	JNE JP10
	MOVB *R0+,R9 
	SRL R9,8
	B *R11

JP10	MOVB *R0+,R1
	SRL R1,8
	MPY @N100,R1
	MOVB *R0,R9
	SRL R9,8
	A R2,R9
	B *R11

* Display Integer
* Entry: R0=Display position
DSPINT
	MOV R11,R12
	LI R1,BUFF1+40	;R9=word R1=buffer 
	BL @CV2ASC		;Buffer=4 digit string
	LI R1,BUFF1+44	;Point to leading 0s changed to space
	LI R2,4
	BLWP @VMBW
	B *R12

****************************************
*	Read from disk
* Entry: MSB R3=drive #
* Exit:
* Registers used R0 R1 R2 R3
****************************************

* R3 MSB=drive #
DSROP
	LI R0,PAB
	LI R1,PDATA
	LI R2,>20
	BLWP @VMBW	;Move PAB data into PAB in VDP RAM

	MOVB R3,R1	;Get new drive number
	LI R0,PAB+13	;Drive number location in PAB
	BLWP @VSBW	;Change drive number

	CLR R1		; Open OP
	JMP DSR
* Read 38 byte record into BUFF1
DSRRD
	MOV R11,R12
	LI R1,>0200	;Read op-code
	BL @DSR

	LI R0,PABBUF	;Move from VDP buffer to CPU buffer
	LI R1,BUFF1	;
	LI R2,38	;	
	BLWP @VMBR	;
	B *R12
*
DSRCL
	LI R1,>0100	;Close op-code
*	JMP DSR		;Fall thru
* Call DSRLNK,R1=OP-code
DSR
	LI R0,PAB
	BLWP @VSBW	;Change I/O op-code

	LI R0,PAB+9	;Get Pointer to name length
	MOV R0,@PNTR	;Store pointer to name length @>8356
	BLWP @DSRLNK	;
	DATA 8
       	B    *R11

****************************************
*	Change disk in drives
*
* ; R3 MSByte=Drive,R4 MSByte=Disk
*
****************************************
CHGDSK	MOV R7,R4		;Get volume number
	SWPB R4
	SRL R3,8		;Move Drive # to LSByte
	MOVB R4,@DSKNUM-1(R3)	;Store volume # at DSKNUM 0-2
	SWPB R3			;Drive number back to MSByte

	LI R12,>1100		;Turn on DSR address space
	SBO 0
	LI R0,>7E00		;Command >81 inverted
	MOVB R0,@>5FF8		;Send command
	INV R3			;Invert
	MOVB R3,@>5FFE		;Send Drive number
	NOP
	INV R4
	MOVB R4,@>5FFE		;Send Disk number
	SBZ 0			;Turn off DSR address space

	B *R11
********************************************************************
*** Clear Screen
CLS	LI R0,768		;Turn off sprite cursor
	LI R1,>D000
	BLWP @VSBW
	
	CLR R0
	LI R1,>2000		;MSB=' '
	LI R2,768
LP04
	BLWP @VSBW		
	INC R0			
	DEC R2			
	JNE LP04
	B *R11

*** Display '1-3=CHG DSK,FCTN 1-3=CAT DSK'
DSPCHG	LI R0,ROW23+1		;
	LI R1,MSG6
	LI R2,_MSG6-MSG6	;
	BLWP @VMBW
	B *R11

*** Display DSKx.xxx and Disk names
DSPDSK
	MOV R11,R12		;Save return
	LI R0,ROW2+1		;DSKX.
	LI R1,MSG4
	LI R2,_MSG4-MSG4	;
	BLWP @VMBW

	LI R4,3		;3 drives
	LI R5,DSKNUM
	LI R0,ROW2+6
LP06				
	MOVB *R5,R9		;Get disk number for drive x
	SRL R9,8		;make byte a word
	LI R1,BUFF1
	BL @CV2ASC
	LI R1,BUFF1+1	;Skip 1st leading 0
	LI R2,3		;Only put 3 digits on screen		
	BLWP @VMBW		;Put disk number on screen
		
	MOVB *R5+,R9		;Get disk number for drive x
	SRL R9,8		;make byte a word
	MPY @N10,R9		;Point to name location in BUFF2
	AI R10,BUFF2		; "
	MOV R10,R1
	AI R0,27		;Row below DSKX and back 5 columns
	LI R2,10
	BLWP @VMBW		;Put disk name on screen
	AI R0,-17		;Back up to DSKX row advance 10 columns
	DEC R4
	JNE LP06
	
	B *R12

*** Convert word to 4 digit ASCII
*Entry: R9=word to convert,R1 pointing to 8 byte buffer
*Exit: Buffer=1st 4 bytes string with leading 0s
*Exit: Buffer=2nd 4 bytes string leading 0s removed
CV2ASC
	MOV R9,R10

	CLR R9
	DIV @N1000,R9	;R9 has integer of result,R10 has remainder
 	SWPB R9
	ORI R9,>3000
	MOVB R9,*R1+		;Save integer

	CLR R9
	DIV @N100,R9	;R9 has integer of result,R10 has remainder
 	SWPB R9
	ORI R9,>3000
	MOVB R9,*R1+		;Save integer
	
	CLR R9			;R10 has remainder from previous division
	DIV @N10,R9		;R9 has integer of result,R10 has remainder	
	SWPB R9
	ORI R9,>3000
	MOVB R9,*R1+		;Save integer

	SWPB R10
	ORI R10,>3000
	MOVB R10,*R1+		;Save remainder

*Copy string to buffer+4 & Change leading 0s to space
	MOV @-4(R1),*R1		;Copy 1st 4 bytes to 2nd 4 bytes
	MOV @-2(R1),@2(R1)	; "
	LI R9,3		;Only 1st 3 0s
LP17	
	CB @ASCII0,*R1
	JNE JP09		;Leave at 1st non-zero digit
	MOVB @SPACE,*R1+
	DEC R9
	JNE LP17
JP09
	B *R11
	
****************************************
*	Transfer volume to PC
*
****************************************
XFRSND	MOV R11,R8
	BL @CLS			;Clear screen
	LI R1,MSG5
	LI R2,_MSG5-MSG5
	LI R3,>0100
	JMP JP25
	
XFRRCV	MOV R11,R8
	BL @CLS			;Clear screen
	LI R1,MSG6
	LI R2,_MSG6-MSG6
	CLR R3
	
JP25	LI R0,ROW2+2		;Display Sending/Receiving
	BLWP @VMBW
	MOV R7,R9		;Display Volume number
	LI R1,BUFF1
	BL @CV2ASC
	LI R1,BUFF1+1		
	LI R0,ROW2+19
	LI R2,3
	BLWP @VMBW
	
	MOV R7,R0		;Display volume name
	MPY @N10,R0		;Times ten for location in buffer
	AI R1,BUFF2		;Point to address in buffer
	LI R0,ROW4+12	
	LI R2,10		;Display 10 characters
	BLWP @VMBW

	LI R12,>1100		;Turn on DSR address space
	SBO 0
	LI R0,>7800		;Command >87 inverted
	MOVB R0,@>5FF8		;Send command
	MOV R7,R0
	SWPB R0
	INV R0
	MOVB R0,@>5FFE		;Send Volume number
	LI R0,>0100
	MOVB R0,@>5FFE		;Send Telnet flag
	INV R3
	MOVB R3,@>5FFE		;Send Send/Recieve mode

	LI R1,'. '		;
LP07	LI R3,738		;Start screen position
	ORI R3,>4000		;set VDP for write
	SWPB R3			;Get LSByte 1st
	MOVB R3,@>8C02		;Write LSByte
	SWPB R3			;Get MSByte
	MOVB R3,@>8C02		;Write MSByte
	
	LI R4,28
LP09	MOVB R1,@>8C00		;Write '.' or space to screen

	LI R2,1500
LP10	MOVB @>5FF6,R0
	INV R0
	COC @H1000,R0
	JEQ JP26		;Cancel or error
	COC @H8000,R0
	JNE JP27		;Finished
	DEC R2
	JNE LP10
	DEC R4
	JNE LP09
	SWPB R1
	JMP LP07
	
JP26	LI R1,MSG9
	LI R2,_MSG9-MSG9
	JMP JP28

JP27	LI R1,MSG10
	LI R2,_MSG10-MSG10
	
JP28	LI R0,ROW21+2
	BLWP @VMBW
	
	SBZ 0			;Turn off DSR address space
	BL @ANYKY1
	B *R8
***************************************
* Wait for press any keyboard
***************************************
ANYKY1	LI R0,ROW23+5
	LI R1,MSG11
	LI R2,_MSG11-MSG11
	BLWP @VMBW
ANYKY2	BLWP @KSCAN
	MOVB @STATUS,R0
	JEQ ANYKY2	
	B *R11
****************************************
*Print to screen
*Entry	R0=VDP address, 
*	R1=Pointer to message
****************************************
NEWLIN	INC R1			;Skip cr in message
	AI R0,32		;LF - Next line
	SRL R0,5		;CR - Round to 1st Column
	SLA R0,5		;       "
PRINT	ORI R0,>4000		;set VDP for write
	SWPB R0			;Get LSByte 1st
	MOVB R0,@>8C02		;Write LSByte
	SWPB R0			;Get MSByte
	MOVB R0,@>8C02		;Write MSByte
	ANDI R0,>3FFF		;Restore screen address

LP20	CB *R1,@H0D		;Check If cr
	JEQ NEWLIN		;
	CB *R1,@H00		;Check If end of message
	JEQ JP29		;
	MOVB *R1+,@>8C00	;Write to screen
	INC R0
	JMP LP20
JP29	B *R11
********************************************************************************
* E/A Utilities
********************************************************************************            
_KSCAN	LWPI >83E0                
       	MOV  R11,@EAREG+22           ;save to old r11
       	BL   @>000E
       	LWPI EAREG
       	MOV  R11,@>83F6              ;restore gpl r11
       	RTWP
 
*Register 0: Address in VDP RAM.
*Register 1: Most-significant byte contains the value to be written.                       
_VSBW  	BL   @VWR                 
       	MOVB @>0002(R13),@>8C00
       	RTWP

*Register 0: Starting address of the buffer in VDP RAM.
*Register 1: Starting address of the buffer in RAM.
*Register 2: The number of bytes to be written.                                  
_VMBW  	BL   @VWR                 
LP80  	MOVB *R1+,@>8C00
       	DEC  R2
       	JNE  LP80                  
       	RTWP

*Register 0: Address in VDP RAM.
*Register 1: Value is placed in the most-significant byte.                               
_VSBR  	BL   @VRD                 
       	MOVB @>8800,@>0002(R13)
       	RTWP

*Register 0: Starting address of the buffer in VPP RAM.
*Register 1: Starting address of the buffer in RAM.
*Register 2: The number of bytes to be read.                                 
_VMBR  BL   @VRD                 
LP81  	MOVB @>8800,*R1+
       	DEC  R2
       	JNE  lp81                  
       	RTWP

*Register 0: Least-significant byte contains the value to be written.
*Most-significant byte indicates the VDP Register to be written to.   
_VWTR  	MOV  *R13,R1                  
       	MOVB @>0001(R13),@>8C02
       	ORI  R1,>8000
       	MOVB R1,@>8C02
       	RTWP

VWR	LI   R1,>4000			;vdp write
       	JMP  jp82                  
VRD	CLR  R1 			;vdp read
JP82  	MOV  *R13,R2                  
       	MOVB @EAREG+5,@>8C02
	SOC  R1,R2
       	MOVB R2,@>8C02
       	MOV  @>0002(R13),R1           fetch old r1,r2
       	MOV  @>0004(R13),R2
       	B    *R11
*
*-------------------------------------
* DSRLNK Call DSR or subprogram
*-------------------------------------
SAVCRU	EQU >2032
SAVENT	EQU >2034
SAVLEN	EQU >2036
SAVPAB	EQU >2038
SAVVER	EQU >203A
NAMBUF	EQU >208C
DOT	TEXT '.'	      ;Used by DSRLNK
EQBIT	BYTE >20	      ; "
HEADID	BYTE >AA	      ;Could use >6000
	EVEN
_DSRLN
       MOV  *R14+,R5          ;get data word: >0008 = DSR,>000A = subprogram
       SZCB @EQBIT,R15        ;clear Eq bit
       MOV  @>8356,R0          ;get name ptr
       MOV  R0,R9
       AI   R9,-8	      ;point to status/error byte in PAB
       BLWP @VSBR             ;VSBR: read size
       MOVB R1,R3             ;name size
       SRL  R3,8              ;make it a word
       SETO R4                ;character counter
       LI   R2,NAMBUF         ;name buffer

LP90   INC  R0
       INC  R4
       C    R4,R3             ;whole name done?
       JEQ  JP90              ;yes
       BLWP @VSBR             ;no: read a char with VSBR
       MOVB R1,*R2+           ;save it on buffer
       CB   R1,@DOT           ;is it . ?
       JNE  LP90              ;no: next char

JP90   MOV  R4,R4             ;yes: did we find any char before the dot?
       JEQ  JP95              ;empty name: error 0
       CI   R4,>0007          ;check name size
       JGT  JP95              ;8 char or more: error 0
       CLR  @>83D0            ;buffer for CRU address
       MOV  R4,@>8354         ;save name size
       MOV  R4,@SAVLEN        ;again for internal use
       INC  R4
       A    R4,@>8356         ;point at end-of-name
       MOV  @>8356,@SAVPAB    ;save for recall		
       LWPI >83E0             ;GPL workspace
       CLR  R1                ;call counter
       LI   R12,>0F00         ;CRU

LP91  MOV  R12,R12            ;first CRU?
       JEQ  JP91              ;yes: skip
       SBZ  0                 ;no: turn previous card off

JP91  AI   R12,>0100          ;next card
       CLR  @>83D0            ;reset buffer
       CI   R12,>2000         ;last card done?
       JEQ  JP94              ;yes: error 0
       MOV  R12,@>83D0        ;save current CRU
       SBO  0                 ;turn card on (if any)
       LI   R2,>4000
       CB   *R2,@HEADID       ;check if valid header (>AA)
       JNE  LP91              ;no: next card
       A    @DSRREG+10,R2    ;yes: get first link (sub or DSR)
       JMP  JP92

LP92  MOV  @>83D2,R2	      ;address of 'next link' word
       SBO   0                ;make sure card is on

JP92  MOV  *R2,R2             ;next link
       JEQ  LP91              ;no more: next card
       MOV  R2,@>83D2         ;save address (ptr to next link)
       INCT R2
       MOV  *R2+,R9           ;program address
       MOVB @>8355,R5         ;name size
       JEQ  JP93              ;no name: execute
       CB   R5,*R2+           ;same size?
       JNE  LP92              ;no: next link
       SRL  R5,8              ;yes: make it a word
       LI   R6,NAMBUF         ;name buffer

LP93  CB   *R6+,*R2+          ;check name
       JNE  LP92              ;mismatch: next link
       DEC  R5
       JNE  LP93              ;next char

JP93  INC  R1                 ;occurences counter
       MOV  R1,@SAVVER        ;save it for recall
       MOV  R9,@SAVENT        ;save program address
       MOV  R12,@SAVCRU       ;save CRU
       BL   *R9               ;call DSR/subprogram
       JMP  LP92              ;keep scanning
       SBZ  0                 ;done: turn card off
       LWPI DSRREG            ;DSRLNK workspace
       MOV  R9,R0              ;status/error byte in PAB
       BLWP @VSBR             ;VSBR: read it
       SRL  R1,13             ;keep only error bits
       JNE  JP96              ;error
       RTWP                   ;no error: return to caller
 
JP94  LWPI DSRREG            ;back to DSRLNK workspace
JP95  CLR  R1                 ;error #0
JP96  SWPB R1
       MOVB R1,*R13           ;pass error code in caller's R0
       SOCB @EQBIT,R15        ;set eq bit
       RTWP                   ;return to caller

*********************************
KSCAN	DATA EAREG,_KSCAN
VSBW	DATA EAREG,_VSBW
VMBW	DATA EAREG,_VMBW
VSBR	DATA EAREG,_VSBR
VMBR	DATA EAREG,_VMBR
VWTR	DATA EAREG,_VWTR
DSRLNK	DATA DSRREG,_DSRLN

ROW0	EQU >0000
ROW1	EQU >0020
ROW2	EQU >0040
ROW3	EQU >0060
ROW4	EQU >0080
ROW5	EQU >00A0
ROW6	EQU >00C0
ROW7	EQU >00E0
ROW8	EQU >0100
ROW9	EQU >0120
ROW10	EQU >0140
ROW11	EQU >0160
ROW12	EQU >0180
ROW13	EQU >01A0
ROW14	EQU >01C0
ROW15	EQU >01E0
ROW16	EQU >0200
ROW17	EQU >0220
ROW18	EQU >0240
ROW19	EQU >0260
ROW20	EQU >0280
ROW21	EQU >02A0
ROW22	EQU >02C0
ROW23	EQU >02E0
 END                         