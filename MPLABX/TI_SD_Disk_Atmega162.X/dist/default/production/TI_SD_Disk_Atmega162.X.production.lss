
AVRASM ver. 2.2.8  main.asm Mon Jul 05 20:12:03 2021

[builtin](2): Including file 'C:/Program Files/Microchip/MPLABX/v5.45/packs/Microchip/ATmega_DFP/2.2.108/avrasm/inc\m162def.inc'
[builtin](2): Including file 'C:/Program Files/Microchip/MPLABX/v5.45/packs/Microchip/ATmega_DFP/2.2.108/avrasm/inc\m162def.inc'
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega162.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m162def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega162
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega162
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M162DEF_INC_
                                 #define _M162DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega162
                                 #pragma AVRPART ADMIN PART_NAME ATmega162
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x94
                                 .equ	SIGNATURE_002	= 0x04
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	UBRR1H	= 0x3c
                                 .equ	UCSR1C	= 0x3c
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	EMCUCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	TCCR2	= 0x27
                                 .equ	ASSR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	TCNT2	= 0x23
                                 .equ	OCR2	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRR0H	= 0x20
                                 .equ	UCSR0C	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	PORTE	= 0x07
                                 .equ	DDRE	= 0x06
                                 .equ	PINE	= 0x05
                                 .equ	OSCCAL	= 0x04
                                 .equ	OCDR	= 0x04
                                 .equ	UDR1	= 0x03
                                 .equ	UCSR1A	= 0x02
                                 .equ	UCSR1B	= 0x01
                                 .equ	UBRR1L	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 3	; Force Output Compare for Channel A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select1 bit 0
                                 .equ	CS11	= 1	; Clock Select1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Pulse Width Modulator Select Bit 1
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Forde Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE2	= 2	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 4	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 2	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 4	; Output Compare Flag 2
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 3B
                                 .equ	OCF3A	= 4	; Output Compare Flag 3A
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	WGM31	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	FOC3B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC3A	= 3	; Force Output Compare for Channel A
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select3 bit 0
                                 .equ	CS31	= 1	; Clock Select3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	WGM33	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR	= UDR0	; For compatibility
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	USR	= UCSR0A	; For compatibility
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	U2X	= U2X0	; For compatibility
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	DOR	= DOR0	; For compatibility
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	FE	= FE0	; For compatibility
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	UDRE	= UDRE0	; For compatibility
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	TXC	= TXC0	; For compatibility
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 .equ	RXC	= RXC0	; For compatibility
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	UCR	= UCSR0B	; For compatibility
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	TXB8	= TXB80	; For compatibility
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	RXB8	= RXB80	; For compatibility
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	TXEN	= TXEN0	; For compatibility
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	RXEN	= RXEN0	; For compatibility
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	UDRIE	= UDRIE0	; For compatibility
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	TXCIE	= TXCIE0	; For compatibility
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 .equ	RXCIE	= RXCIE0	; For compatibility
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UBRRHI	= UCSR0C	; For compatibility
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 .equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 ;.equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= UBRR0L	; For compatibility
                                 .equ	UBRR	= UBRR0L	; For compatibility
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART1 I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART1 I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART1 I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART1 I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART1 I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART1 I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART1 I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART1 I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	CHR91	= UCSZ12	; For compatibility
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 .equ	URSEL1	= 7	; Register Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Highg Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ;.equ	UBRR1	= UBRR1L	; For compatibility
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 1
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SM	= SM1	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRW	= SRW10	; For compatibility
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	SM2	= 5	; Sleep Mode Select Bit 2
                                 .equ	JDT	= 7	; JTAG Interface Disable
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 .equ	ISC2	= 0	; Interrupt Sense Control 2
                                 .equ	SRW11	= 1	; Wait State Select Bit 1 for Upper Sector
                                 .equ	SRW00	= 2	; Wait State Select Bit 0 for Lower Sector
                                 .equ	SRW01	= 3	; Wait State Select Bit 1 for Lower Sector
                                 .equ	SRL0	= 4	; Wait State Sector Limit Bit 0
                                 .equ	SRL1	= 5	; Wait State Sector Limit Bit 1
                                 .equ	SRL2	= 6	; Wait State Sector Limit Bit 2
                                 .equ	SM0	= 7	; Sleep mode Select Bit 0
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 
                                 ; CLKPR - Clock prescale register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR310	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSR310	; For compatibility
                                 .equ	PSR0	= PSR310	; For compatibility
                                 .equ	PSR1	= PSR310	; For compatibility
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	XMM0	= 3	; External Memory High Mask Bit 0
                                 .equ	XMM1	= 4	; External Memory High Mask Bit 1
                                 .equ	XMM2	= 5	; External Memory High Mask Bit 2
                                 .equ	XMBK	= 6	; External Memory Bus Keeper Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter 0 Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter 0 Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Timer/Counter 0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0	= 0	; Timer/Counter0 Output Compare Match Interrupt register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0	= 0	; Output Compare Flag 0
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 ;.equ	ISC2	= 0	; Interrupt Sense Control 2
                                 
                                 ; GICR - General Interrupt Control Register
                                 .equ	EIMSK	= GICR	; For compatibility
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PCIE0	= 3	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 4	; Pin Change Interrupt Enable 1
                                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	PCIF0	= 3	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 4	; Pin Change Interrupt Flag 1
                                 .equ	INTF2	= 5	; External Interrupt Flag 2
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 1	; Brown out detector trigger level
                                 .equ	BODLEVEL1	= 2	; Brown out detector trigger level
                                 .equ	BODLEVEL2	= 3	; Brown out detector trigger level
                                 .equ	M161C	= 4	; ATMega 161 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x04ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 16384
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1c00
                                 .equ	NRWW_STOP_ADDR	= 0x1fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1bff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x1f80
                                 .equ	SECONDBOOTSTART	= 0x1f00
                                 .equ	THIRDBOOTSTART	= 0x1e00
                                 .equ	FOURTHBOOTSTART	= 0x1c00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	PCI0addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	ICP3addr	= 0x000c	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x000e	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0010	; Timer/Counter3 Compare Match B
                                 .equ	OVF3addr	= 0x0012	; Timer/Counter3 Overflow
                                 .equ	OC2addr	= 0x0014	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0016	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0018	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x001a	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001c	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001e	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x0020	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0022	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0024	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0026	; USART0, Rx Complete
                                 .equ	URXC1addr	= 0x0028	; USART1, Rx Complete
                                 .equ	UDRE0addr	= 0x002a	; USART0 Data register Empty
                                 .equ	UDRE1addr	= 0x002c	; USART1, Data register Empty
                                 .equ	UTXC0addr	= 0x002e	; USART0, Tx Complete
                                 .equ	UTXC1addr	= 0x0030	; USART1, Tx Complete
                                 .equ	ERDYaddr	= 0x0032	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0034	; Analog Comparator
                                 .equ	SPMRaddr	= 0x0036	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 56	; size in words
                                 
                                 #endif  /* _M162DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 ;    TI SD Disk.asm
                                 ;
                                 ; Created: 1/1/2019 3:45:02 PM
                                 ; Author : denni
                                 ;
                                 ; Fuses FF D9 FF
                                 ; 16mhz ext crystal
                                 ;
                                 ;   Atmega8515 Converted to Atmega162		
                                 ;    PortA	PortB	    Portc	PortD	    PortE			
                                 ;    0<Data0	0<A0	    0>Data0	0<RXD	    0<!INT2			
                                 ;    1<Data1	1<A1	    1>Data1	1>TXD	    1<!WE		
                                 ;    2<Data2	2<	    2>Data2	2<	    2>!ready			
                                 ;    3<Data3	3<	    3>Data3	3>HLD			
                                 ;    4<Data4	4>CS	    4>Data4	4<Drive1
                                 ;    5<Data5	5>MOSI	    5>Data5	5<Drive2    
                                 ;    6<Data6	6<MISO	    6>Data6	6<Drive3
                                 ;    7<Data7	7>SCK	    7>Data7	7<Side   
                                 ;
                                 ; IN PINx
                                 ; OUT PORTx
                                 ; OUT PINx turns on pullup						
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
                                 
                                 			
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Equates
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PortE bits
                                 			.equ intbit = PE0
                                 			.equ webit = PE1
                                 			.equ rdybit = PE2
                                 			
                                 ; Dedicated registers			
                                 ; INT2:	XL XH r13 r14			
                                 ; SD error count: r10			
                                 ; Save arg: r6-r9
                                 ;			
                                 		
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.DSEG
                                 fdcRegisters:
000100                           fdcStatus:	.byte 1			;TI 5FF0 Read Status
000101                           fdcTrack:	.byte 1			;TI 5FF2/5FFA Rd/Wr Track Register
000102                           fdcSector:	.byte 1			;TI 5FF4/5FFC Rd/Wr Sector Register
000103                           fdcData:	.byte 1			;TI 5FF6/5FFE Rd/ Data Register
000104                           fdcCommand:	.byte 1			;TI 5FF8 Write Command Register
000105                           fdcSide:	.byte 1			;	
                                 
000106                           flags:		.byte 1			;flags + address
                                 			.equ iflag = 7	;1 int occured
                                 			.equ wflag = 2	;1 write occured
                                 
000107                           DSK1address:	.byte	4	;LSB -- MSB			
00010b                           DSK2address:	.byte	4	;LSB -- MSB
00010f                           DSK3address:	.byte	4	;LSB -- MSB
000113                           DSK1LastTrk:	.byte	1
000114                           DSK2LastTrk:	.byte	1
000115                           DSK3LastTrk:	.byte	1
000116                           TIlowbyte:	.byte	1
                                 	
                                 	
                                 ;SD variables
                                 		.equ CS = PB4
000117                           ocr:		.byte	1
                                 		.equ ccs = 6	;bit 6
000118                           cmd:		.byte	1
000119                           arg:		.byte	4	;LSB -- MSB		
00011d                           crc:		.byte	1
00011e                           resp:		.byte	1
                                 
                                 SectorsPerCluster:		;in Powers of 2 (Number of left shifts to use)
00011f                           		.byte	1
000120                           vbr:		.byte	4	;LSB -- MSB	
000124                           StartSector:	.byte	2
000126                           StepSectors:	.byte	2
                                 		
                                 ;Use buffer to calc end of fdcRegisters variables to send to USART intr
000128                           TIbuffer:	.byte	256
000228                           SDbuffer:	.byte	512
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Interrupts vector tables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 	.CSEG		;8515 use rjmp 162 use jmp
                                 	.org $000
000000 940c 00b0                 	jmp setup	;Reset Handler
                                 	.org URXC0addr	;8515 URXCaddr, 162 URXC0addr
000026 940c 0054                 	jmp USART_RXC	;USART RX Complete Handler  
                                 	.org INT2addr
000006 940c 0038                 	jmp EXT_INT2	;IRQ2 Handler
                                 	
                                 
                                 ;Interrupt Service Routines
                                 	.org INT_VECTORS_SIZE		;End of Int vector table
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; IRQ2 Interrupt Handler
                                 ; XH XL r13 r14 r15 not saved
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; cycle = 62.5ns
                                 EXT_INT2:
000038 b6df                          	in r13, SREG			;Save SREG			1
000039 2ee0                      	mov r14, r16			;				1
00003a b306                      	in r16, PinB			;Get FDC address		1
00003b 7003                      	andi r16,0x03			;				1
00003c 24ff                      	clr r15				;				1								
00003d e0b1                      	ldi XH, high(fdcRegisters)	;Point X to FDC_Registers base	1
00003e e0a0                      	ldi XL, low(fdcRegisters)	; "				1
00003f 0fa0                      	add XL, r16			;add FDC address offset		1
000040 1dbf                      	adc XH, r15			; "				1
000041 90fc                      	ld r15, X			;Get data in FDC register	2
000042 bafb                      	out PortA, r15			;Send it to TI			1
000043 6800                      	sbr r16, 1<<iflag		;Set our interrupt flag		1
000044 0000                      	nop				;				1
000045 0000                      	nop				;				1
                                  ;Need 13-19 cycles to here, Min 15 without errors			15
                                 	
000046 9929                      	sbic PinE, webit		;Test !we
000047 c007                      	rjmp isr2end			;Read if 1
000048 b2f3                      	in r15, PinC			;Get  write data
000049 94f0                      	com r15				;TI sends inverted data
00004a 6004                      	sbr r16, 1<<wflag		;Set write flag
00004b 3804                      	cpi r16,0x84			;Check If Command
00004c f409                      	brne NotCMD			; "
00004d 9614                      	adiw X, 4			;Point to Command registers
                                 NotCMD:	
00004e 92fc                      	st X, r15			;Write data to FDC register
                                 isr2end:
00004f 9300 0106                 	sts flags, r16			;
000051 2d0e                      	mov r16, r14			;
000052 bedf                      	out SREG, r13			;Restore SREG	
000053 9518                      	reti
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; USART RX Complete Interrupt Handler	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 USART_RXC:
000054 93ff                      	push ZH
000055 93ef                      	push ZL
000056 93df                      	push YH
000057 93cf                      	push YL
000058 93bf                      	push XH
000059 93af                      	push XL
00005a 939f                      	push r25
00005b 938f                      	push r24
00005c 937f                      	push r23
00005d 936f                      	push r22
00005e 935f                      	push r21
00005f 934f                      	push r20
000060 933f                      	push r19
000061 932f                      	push r18
000062 931f                      	push r17
000063 930f                      	push r16
000064 b70f                      	in r16, SREG
000065 930f                      	PUSH r16
                                 	
000066 d243                      	rcall USARTRead		    ;Get char received
000067 7d0f                      	cbr r16, 1<<5		    ;If lowercase convert to uppercase
                                 chkR:	
000068 3502                      	cpi r16,'R'		    ;Send reg 16-31, SREG, Ret PC
000069 f429                      	brne chkS
00006a b7fe                      	in ZH, SPH
00006b b7ed                      	in ZL, SPL
00006c 9631                      	adiw Z,1
00006d e113                      	ldi r17, 19
00006e c014                      	rjmp TXLP0
                                 chkS:	
00006f 3503                      	cpi r16,'S'		    ;Send all calls on stack
000070 f439                      	brne chkB
000071 b7fe                      	in ZH, SPH
000072 b7ed                      	in ZL, SPL
000073 9671                      	adiw Z,17
000074 ef1f                      	ldi r17, low(RAMEND)
000075 1b1e                      	sub r17, ZL
000076 9631                      	adiw Z,1
000077 c00b                      	rjmp TXLP0	
                                 chkB:
000078 3402                       	cpi r16,'B'		    ;Send TIbuffer
000079 f421                      	brne chkC
00007a 2711                      	clr r17
                                 TXJP0:	
00007b e0f1                      	ldi ZH, high(TIbuffer)	    ; Get address to TIbuffer
00007c e2e8                      	ldi ZL, low(TIbuffer)	    ; "
00007d c005                      	rjmp TXLP0
                                 chkC:
00007e 3403                       	cpi r16,'C'	;Send all FDC registers (variables) except buffer
00007f f439                      	brne RXCIntRtn
000080 e218                      	ldi r17, TIbuffer-fdcRegisters ;All between fdcRegisters & buffer
000081 e0f1                      	ldi ZH, high(fdcRegisters)  ; Get address to FDC registers
000082 e0e0                      	ldi ZL, low(fdcRegisters)   ; "
                                 TXLP0:	
000083 9101                      	ld r16,Z+
000084 d229                      	rcall USARTWrite	    ; Send data byte
000085 951a                      	dec R17
000086 f7e1                      	brne TXLP0
                                 	
                                 RXCIntRtn:
000087 910f                      	pop r16
000088 bf0f                       	out SREG, r16
000089 910f                      	pop r16
00008a 911f                      	pop r17
00008b 912f                      	pop r18
00008c 913f                      	pop r19
00008d 914f                      	pop r20
00008e 915f                      	pop r21
00008f 916f                      	pop r22
000090 917f                      	pop r23
000091 918f                      	pop r24
000092 919f                      	pop r25
000093 91af                      	pop XL
000094 91bf                      	pop XH
000095 91cf                      	pop YL
000096 91df                      	pop YH
000097 91ef                      	pop ZL
000098 91ff                      	pop ZH
000099 9518                        	reti	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Constants
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Use to access program memory	
                                 ; ldi ZH,high(hello<<1)	;Shift (address*2) because program memory is 16 bits
                                 ; ldi ZL,low(hello<<1)	;When address bit0 is 0 low byte of word is accessed
                                 ; lpm r16,Z+		;When address bit0 is 1 high byte of word is accessed
                                 ;			;Effectively changing to byte access
                                 ;hello:
                                 ;	.db "HELLO",0
00009a 76eb
00009b 4590
00009c 4658
00009d 5441
00009e 00ff                      EXFATstr: .db 0xEB,0x76,0x90,"EXFAT",0xFF,0 ;make even bytes
00009f 00c1
0000a0 0056
0000a1 004f
0000a2 004c
0000a3 0055
0000a4 004d
0000a5 0045
0000a6 ff53                      VOLstr:	.db 0xC1,0,'V',0,'O',0,'L',0,'U',0,'M',0,'E',0,'S',0xFF
0000a7 00c1
0000a8 0054
0000a9 0049
0000aa 0056
0000ab 004f
0000ac 004c
0000ad 0030
0000ae 0030
0000af ff30                      TIVOLstr: .db 0xC1,0,'T',0,'I',0,'V',0,'O',0,'L',0,'0',0,'0',0,'0',0xFF
                                  
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Setup
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 setup:
0000b0 ef0f                      	ldi r16, low(RAMEND)		;Init stack
0000b1 bf0d                      	out spl, r16			;	"
0000b2 e004                      	ldi r16, high(RAMEND)		;	"
0000b3 bf0e                      	out sph, r16			;	"
                                 ;Setup ports
0000b4 ef0f                      	ser	r16			;PortA (FF) output mode for TI read
0000b5 bb0a                      	out DDRA, r16			; "
0000b6 2700                      	clr	r16			;PortC (00) input mode for TI write
0000b7 bb04                      	out DDRC, r16			; "
0000b8 eb00                      	ldi	r16,0b10110000		;SCK,MI,MO,CS,0,0,A1,A0
0000b9 bb07                      	out DDRB, r16			;O  ,I ,O ,O ,I,I,I ,I
0000ba 9ac6                      	sbi PortB, PB6			;Pullup MISO
0000bb e00a                      	ldi	r16,0b00001010		;Side,DR3,DR2,DR1,HLD,0,TDX,RXD
0000bc bb01                      	out DDRD, r16			;I   ,I  ,I  ,I  ,O  ,I,O  ,I
0000bd e004                      	ldi	r16,0b00000100		;0,0,0,0,0,!Ready,!WE,!INT
0000be b906                      	out DDRE, r16			;I,I,I,I,I,O     ,I  ,I
0000bf 983a                      	cbi PortE, rdybit		;Ready to TI
                                 
0000c0 b706                      	in r16, EMCUCR			;Set INT2 falling edge trigger
0000c1 7f0e                      	cbr r16, 1<<ISC2		; " ISC2=bit0 same as andi r16, 0xFE
0000c2 bf06                      	out EMCUCR, r16			; "
0000c3 b70b                      	in r16, GICR			;Enable INT2
0000c4 6200                      	sbr r16, 1<<INT2		; " INT2=bit5 same as ori r16, 32
0000c5 bf0b                      	out GICR, r16			; "	
                                 ;Set status				;NotReady  track0  busy
0000c6 e004                      	ldi r16, 0x04			;b7=0      b3=1    b0=0
0000c7 9300 0100                 	sts fdcStatus, r16		;
0000c9 2700                      	clr r16				; 
0000ca 9300 0101                 	sts fdcTrack, r16		;
0000cc 9300 0102                 	sts fdcSector, r16		;
0000ce 9300 0103                 	sts fdcData, r16		;
0000d0 9300 0104                 	sts fdcCommand, r16		;
0000d2 9893                      	cbi PortD, 3			;data not ready
                                 ;Setup USART				;baud @ 16MHz (Using double baud rate)
0000d3 e010                      	ldi r17, 0			;230.4k=0,8 115.2k=0,16
0000d4 e100                      	ldi r16, 16			;
0000d5 d1cb                      	rcall USARTInit
0000d6 b10a                      	in r16, UCSR0B			;Enable RXC interrupt
0000d7 6800                      	sbr r16, 1<<RXCIE		; "
0000d8 b90a                      	out UCSR0B, r16			; "	
                                 ;Setup SPI
0000d9 e100                      	ldi r16, 16
0000da 2ea0                      	mov r10, r16			;SD error count, So it doesn't run away
0000db d1da                      	rcall SPIInit  
0000dc d29b                      	rcall MMCInit
                                 ;Setup Drives	
                                 SetupStartStep:  
0000dd d1e5                      	rcall FindTIVOL		;Find TIVOL000, Save Start and Step
0000de f019                      	breq SetupDSK
0000df e800                      	ldi r16, 0x80		;disk error, not ready
0000e0 9300 0100                 	sts fdcStatus, r16	;
                                 ;Get DSKx addresses from SD sector 1    
                                 SetupDSK:
0000e2 e001                      	ldi r16, 0x01
0000e3 9300 0119                 	sts arg, r16		; (LSB) sector 00 00 00 01
0000e5 2700                       	clr r16
0000e6 9300 011a                 	sts arg+1, r16
0000e8 9300 011b                 	sts arg+2, r16
0000ea 9300 011c                 	sts arg+3, r16		; (MSB)
0000ec d38a                      	rcall ReadMMC           ; First half 512 sector (uses ZL & ZH)
                                 	
                                 ;XL & XH ok to use before interrupts are enabled    	
0000ed e2ec                      	ldi ZL, low(SDbuffer+4)	    ;
0000ee e0f2                      	ldi ZH, high(SDbuffer+4)	    ;
                                 
0000ef 9101                      	ld r16, Z+		    ;Get Drive 1 Disk #
0000f0 930f                      	push r16		    ;		    
0000f1 9101                      	ld r16, Z+		    ;Get Drive 2 Disk #
0000f2 930f                      	push r16		    ;
0000f3 9101                      	ld r16, Z+		    ;Get Drive 3 Disk #
0000f4 930f                      	push r16
                                 	
0000f5 e0cf                      	ldi YL, low(DSK3address)    ;
0000f6 e0d1                      	ldi YH, high(DSK3address)   ;
                                 	
0000f7 e023                      	ldi r18, 3
0000f8 915f                      LP02:	pop r21			    ;Restore disk number (stepping 3 - 1)
0000f9 d189                      	rcall Disk2Sector	    ;Convert disk # to sector address
0000fa 9209                      	st Y+, r0		    ;Save into DSKXaddress
0000fb 9219                      	st Y+, r1		    ;
0000fc 9229                      	st Y+, r2		    ;
0000fd 9239                      	st Y+, r3		    ;
0000fe 9728                      	sbiw Y, 8		    ;Back to start of current drive + start preceding drive
0000ff 952a                      	dec r18			    ;
000100 f7b9                      	brne LP02		    ;All 3 drives done 
                                 	
                                 ;Set last track for drives
000101 e0e7                      	ldi ZL, low(DSK1address)    ;LSB -- MSB
000102 e0f1                      	ldi ZH, high(DSK1address)   ;
000103 e1c9                      	ldi YL, low(arg)	    ;
000104 e0d1                      	ldi YH, high(arg)	    ;
000105 d3ea                      	rcall mov4		    ;
000106 d370                      	rcall ReadMMC 		    ;First half 512 sector (uses ZL & ZH)
000107 e207                      	ldi r16, 39
000108 9110 0232                 	lds r17, SDbuffer+10
00010a fd12                      	sbrc r17, 2		    ;Check bit 2 for value 4 in 5 A0	
00010b e40f                      	ldi r16, 79
00010c 9300 0113                 	sts DSK1LastTrk, r16
                                 	
00010e e0eb                      	ldi ZL, low(DSK2address)    ;LSB -- MSB
00010f e0f1                      	ldi ZH, high(DSK2address)   ;
000110 e1c9                      	ldi YL, low(arg)	    ;
000111 e0d1                      	ldi YH, high(arg)	    ;
000112 d3dd                      	rcall mov4		    ;
000113 d363                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
000114 e207                      	ldi r16, 39
000115 9110 0232                 	lds r17, SDbuffer+10
000117 fd12                      	sbrc r17, 2		    ;Check bit 2 for value 4 in 5 A0	
000118 e40f                      	ldi r16, 79
000119 9300 0114                 	sts DSK2LastTrk, r16
                                 	
00011b e0ef                      	ldi ZL, low(DSK3address)    ;LSB -- MSB
00011c e0f1                      	ldi ZH, high(DSK3address)   ;
00011d e1c9                      	ldi YL, low(arg)	    ;
00011e e0d1                      	ldi YH, high(arg)	    ;
00011f d3d0                      	rcall mov4		    ;
000120 d356                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
000121 e207                      	ldi r16, 39
000122 9110 0232                 	lds r17, SDbuffer+10
000124 fd12                      	sbrc r17, 2		    ;Check bit 2 for value 4 in 5 A0	
000125 e40f                      	ldi r16, 79
000126 9300 0115                 	sts DSK3LastTrk, r16
                                 	
                                 ;Enable interrupts	
000128 2700                      	clr r16				;Clear flags
000129 9300 0106                 	sts flags, r16			;
00012b 9478                      	sei				;Global enable interrupts
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Main Loop
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00012c 2700                      main:	clr r16			    ; Clear busy, No errors	
00012d 9300 0100                 JP02:	sts fdcStatus, r16	    ; "	     
00012f 983a                      	cbi PortE, 2		    ;Release TI
                                 	
000130 9100 0106                 LP00:	lds r16, flags		    ;Get flags
000132 ff07                      	sbrs r16, iflag		    ;Has TI has sent data?
000133 cffc                      	rjmp LP00
000134 2711                      	clr r17			    ;Clear flags
000135 9310 0106                 	sts flags, r17		    ; "		    
                                 	
000137 9100 0104                 	lds r16, fdcCommand	    ;
000139 3000                      	cpi r16, 0x00		    ;
00013a f3a9                      	breq LP00
                                 	
00013b 9a3a                      	sbi PortE, 2		    ;Put TI on hold while process command
00013c 9310 0104                 	sts fdcCommand, r17	    ;Clear command (r17=0 from above)
                                 ;	ldi r17, 0x01		    ;Set Busy bit
                                 ;	sts fdcStatus, r17	    ; "
                                 	
                                 ;	rcall USARTWrite	    ;Send command in r16 (enable for debbuging)
                                 	
                                 ;Our Mount Disk command	
                                 fdcCMD81:			    	
00013e 3801                      	cpi r16, 0x81		   
00013f f411                      	brne fdcCMD82
000140 d125                      	rcall ChgDisk
000141 cfa0                      	rjmp SetupDSK		    ;Setup disk addresses and last track
                                 ;Our Send all disk names command		
                                 fdcCMD82:			    
000142 3802                      	cpi r16, 0x82		    
000143 f411                      	brne fdcCMD0A
000144 d0fa                      	rcall SendNames
000145 cfe6                      	rjmp main
                                 ;0A Restore (h=1, V=0, r0r1=10)	
                                 fdcCMD0A:			   
000146 300a                      	cpi r16, 0x0A		    ;
000147 f439                      	brne fdcCMD1E
000148 2700                      	clr r16			    ;
000149 9300 0101                 	sts fdcTrack, r16	    ;Set to track 0
00014b 9300 0102                 	sts fdcSector, r16	    ;Set to sector 0
00014d 6004                      	sbr r16, 0x04		    ;Set track 0 in status
00014e cfde                      	rjmp JP02
                                 ;1E Seek h=1 V=1 r1r0=10
                                 fdcCMD1E:			    
00014f 310e                      	cpi r16, 0x1E		    ;
000150 f429                      	brne fdcCMD5A
000151 9100 0103                 	lds r16, fdcData
000153 9300 0101                 	sts fdcTrack, r16
000155 cfd6                      	rjmp main
                                 ;2x Step not used by TI
                                 ;5A Step-in T=1, h=1, V=0, r0r1=10	
                                 fdcCMD5A:			    
000156 350a                      	cpi r16, 0x5A		    ;
000157 f431                      	brne fdcCMD88
000158 9100 0101                 	lds r16, fdcTrack
00015a 9503                      	inc r16
00015b 9300 0101                 	sts fdcTrack, r16
00015d cfce                      	rjmp main
                                 ;6x Step-out not used by TI
                                 ;88 Read sector m=0 S=1 E=0 C=0		    
                                 fdcCMD88:			    
00015e 3808                         	cpi r16, 0x88		    ;
00015f f411                      	brne fdcCMDA8
000160 d042                      	rcall TIreadsec
000161 cfca                      	rjmp main
                                 ;A8 Write sector m=0 S=1 E=0 C=0 a=0
                                 fdcCMDA8:			    
000162 3a08                      	cpi r16, 0xA8		    ;
000163 f411                      	brne fdcCMDC0
000164 d02b                      	rcall TIwritesec
000165 cfc6                      mainRLY: rjmp main
                                 ;C0 Read ID E=0
                                 fdcCMDC0:			    
000166 3c00                      	cpi r16, 0xC0		    ;
000167 f411                      	brne fdcCMDF4
000168 d009                      	rcall TIreadID
000169 cfc2                      	rjmp main
                                 ;Ex Read track not used by TI
                                 ;F4 Write track (E=1)
                                 fdcCMDF4:			    
00016a 3f04                          	cpi r16, 0xF4		    ;
00016b f411                      	brne fdcCMDD0
00016c d0ac                      	rcall TIwritetrack
00016d cff7                      	rjmp mainRLY
                                 ;D0 Force interrupt
                                 fdcCMDD0:			    
00016e 3d00                          	cpi r16, 0xD0		    ;Sent after software reset (FTCN =)
00016f f7a9                      	brne mainRLY
000170 d337                      	rcall delay1ms
000171 cf70                      	rjmp SetupDSK		    ;Setup disks in case one was formatted
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadID:
000172 983a                      	cbi PortE, 2		;Release TI
000173 9100 0101                 	lds r16, fdcTrack	;Get track
000175 9300 0103                 	sts fdcData,r16		;Send to TI
000177 d072                      	rcall WaitTIread	; "
000178 2700                      	clr r16			;Side 0
000179 9987                      	sbic PinD, 7		;Get Side
00017a 9503                      	inc r16			;Side 1
00017b 9300 0103                 	sts fdcData,r16		;Send to TI
00017d d06c                      	rcall WaitTIread	; "
00017e 9100 0102                 	lds r16, fdcSector	;Get sector
000180 9300 0103                 	sts fdcData,r16		;Send to TI
000182 d067                      	rcall WaitTIread	; "
000183 2700                      	clr r16			;Sector lenght code?
000184 9300 0103                 	sts fdcData,r16		;Send to TI
000186 d063                      	rcall WaitTIread	; "
000187 2700                      	clr r16			;CRC byte1
000188 9300 0103                 	sts fdcData,r16		;Send to TI
00018a d05f                      	rcall WaitTIread	; "
00018b 2700                      	clr r16			;CRC byte2
00018c 9300 0103                 	sts fdcData,r16		;Send to TI
00018e d05b                      	rcall WaitTIread	; "
00018f 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritesec:
000190 e0f1                       	ldi ZH, high(TIbuffer)	;Get address to buffer
000191 e2e8                      	ldi ZL, low(TIbuffer)	; "
000192 e020                      	ldi r18, 0x00		;256 bytes per sector
                                 	
000193 983a                      	cbi PortE, 2		;Release TI
000194 d05f                      lp24:	rcall WaitTIwrite	;Wait for data from TI
000195 9100 0103                 	lds r16, fdcData	;Get next byte
000197 9301                      	st Z+, r16		;Save to buffer
000198 952a                      	dec r18
000199 f7d1                      	brne LP24
                                 	
00019a 9a3a                      	sbi PortE, 2		;Put TI on hold while process command
00019b e001                      	ldi r16,1
00019c 9b87                      	sbis PinD, 7		;Test pin, Skip if side 1
00019d 2700                      	clr r16
00019e 9300 0105                 	sts fdcSide,r16
0001a0 d014                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001a1 d06b                      	rcall TI_SD_wr		;Write to SD
0001a2 9508                      	ret	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadsec:
0001a3 e001                      	ldi r16,1
0001a4 9b87                      	sbis PinD, 7		;Test pin, Skip if side 1
0001a5 2700                      	clr r16
0001a6 9300 0105                 	sts fdcSide,r16
0001a8 d00c                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001a9 d054                      	rcall TI_SD_rd		;Get sector from SD
0001aa e0f1                      	ldi ZH, high(TIbuffer)	; Get address to buffer
0001ab e2e8                      	ldi ZL, low(TIbuffer)	; "
0001ac e020                      	ldi r18, 0x00		;256 bytes per sector
                                 	
0001ad 983a                      	cbi PortE, 2		;Release TI
0001ae 9101                      lp13:	ld r16, Z+		;Get next byte
0001af 9300 0103                 	sts fdcData,r16		;Send to TI
0001b1 d038                      	rcall WaitTIread	; "
0001b2 952a                      	dec r18
0001b3 f7d1                      	brne LP13
0001b4 9508                      	ret
                                 ;	
                                 ;Convert TI track&sector to SD sector	
                                 Track2Arg:
0001b5 9100 0101                 	lds r16, fdcTrack
0001b7 9110 0105                 	lds r17,fdcSide
0001b9 ff10                      	sbrs r17, 0		;Test bit, Skip if side 1	
0001ba c00c                      	rjmp j00
0001bb 9110 0113                 	lds r17, DSK1LastTrk	;
0001bd 9985                      	sbic PinD, 5		;
0001be 9110 0114                 	lds r17, DSK2LastTrk	;
0001c0 9986                      	sbic PinD, 6		;
0001c1 9110 0115                 	lds r17, DSK3LastTrk	;
0001c3 1b01                      	sub r16, R17		;Reverse track (0=-39 or -79) 
0001c4 9501                      	neg r16			;Make postive
0001c5 9513                      	inc r17			;
0001c6 0f01                      	add r16, r17		;Track + 40 or 80
                                 j00:	
0001c7 e019                      	ldi r17, 9		;Track*9
0001c8 9f01                      	mul r16, r17		;Result in r0 r1
0001c9 2711                      	clr r17			;Add sector offset 0-8		
0001ca 9100 0102                 	lds r16, fdcSector	; "
0001cc 0e00                      	add r0, r16		; "
0001cd 1e11                      	adc r1, r17		; "
                                 	
                                 	;Divide TI sector by 2 to put in upper or lower half of SD sector
0001ce 9200 0116                 	sts TIlowbyte, r0 	;save low byte for bit 0 test
0001d0 9416                      	lsr r1			;Divide 16 bits by 2
0001d1 9407                      	ror r0			; "	"	"
                                 	
                                 	;Add TI sector to DSKx SD start sector address and place in ARG
0001d2 e0f1                      	ldi ZH, high(DSK1address)   ;
0001d3 e0e7                      	ldi ZL, low(DSK1address)    ;
0001d4 9985                      	sbic PinD, 5		    ;
0001d5 9634                      	adiw Z,4		    ;DSK2address
0001d6 9986                      	sbic PinD, 6		    ;
0001d7 9638                      	adiw Z,8		    ;DSK3address
                                 
0001d8 9101                      	ld r16, Z+
0001d9 0d00                      	add r16, r0
0001da 9300 0119                 	sts arg, r16
0001dc 9101                      	ld r16, Z+
0001dd 1d01                      	adc r16, r1
0001de 9300 011a                 	sts arg+1, r16
0001e0 2400                      	clr r0			;carry not affected
0001e1 9101                      	ld r16, Z+
0001e2 1d00                      	adc r16, r0
0001e3 9300 011b                 	sts arg+2, r16
0001e5 8100                      	ld r16, Z
0001e6 1d00                      	adc r16, r0
0001e7 9300 011c                 	sts arg+3, r16
0001e9 9508                      	ret
                                 ;	
                                 WaitTIread:
0001ea 9100 0106                 	lds r16, flags		;Get flags
0001ec ff07                      	sbrs r16, iflag		;Has TI read data?
0001ed cffc                      	rjmp WaitTIread
0001ee 2711                      	clr r17			;Clear interrupt flag
0001ef 9310 0106                 	sts flags, r17		; "
0001f1 3803                      	cpi r16, 0x83		;Was it read data register
0001f2 f7b9                      	brne WaitTIread
0001f3 9508                      	ret
                                 WaitTIwrite:
0001f4 9100 0106                 	lds r16, flags		;Get flags
0001f6 ff07                      	sbrs r16, iflag		;Has TI written data?
0001f7 cffc                      	rjmp WaitTIwrite
0001f8 2711                      	clr r17			;Clear interrupt flag
0001f9 9310 0106                 	sts flags, r17		; "
0001fb 3807                      	cpi r16, 0x87		;Was it write data register
0001fc f7b9                      	brne WaitTIwrite
0001fd 9508                      	ret
                                 	
                                 TI_SD_rd:
0001fe d278                      	rcall readmmc		;512 bytes in sdbuffer
0001ff e2e8                      	ldi ZL, low(SDbuffer)
000200 e0f2                      	ldi ZH, high(SDbuffer)
000201 9100 0116                 	lds r16,TIlowbyte
000203 fd00                      	sbrc r16,0
000204 95f3                      	inc ZH			;Add 256 to Z
000205 e2c8                      	ldi YL, low(TIbuffer)
000206 e0d1                      	ldi YH, high(TIbuffer)
                                 ;Move 256 bytes from source(Z) to destination(Y)
000207 2700                      mov256:	clr r16		
000208 9111                      LP03:	ld r17, Z+ 
000209 9319                      	st Y+, r17
00020a 950a                      	dec r16
00020b f7e1                      	brne LP03
00020c 9508                      	ret	;and send to TI
                                 TI_SD_wr:
00020d d269                      	rcall readmmc	//512 bytes in sdbuffer
00020e e2e8                      	ldi ZL, low(TIbuffer)
00020f e0f1                      	ldi ZH, high(TIbuffer)
000210 e2c8                      	ldi YL, low(SDbuffer)
000211 e0d2                      	ldi YH, high(SDbuffer)
000212 9100 0116                 	lds r16,TIlowbyte
000214 fd00                      	sbrc r16,0
000215 95d3                      	inc YH			;Add 256 to Y
000216 dff0                      	rcall mov256
000217 d22c                      	rcall writemmc	//512 bytes in sdbuffer
000218 9508                      	ret	
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritetrack:
000219 e049                      	ldi r20,9
                                 LP25:	
00021a 983a                      	cbi PortE, 2		;Release TI
                                 	
                                 ;Get (FE, Track, Side, Sector, 1?, F7)	
                                 LP26:	
00021b dfd8                      	rcall WaitTIwrite	;Wait for data from TI
00021c 9100 0103                 	lds r16,fdcData		;Get next byte
00021e 3f0e                      	cpi r16,0xFE
00021f f7d9                      	brne LP26
                                 	
000220 dfd3                      	rcall WaitTIwrite	;Throw away Track, already loaded
                                 
000221 dfd2                      	rcall WaitTIwrite	;Wait for data from TI
000222 9100 0103                 	lds r16,fdcData	
                                 ;	ror r16			;Move bit0 to bit7
                                 ;	ror r16			; "
000224 9300 0105                 	sts fdcSide,r16		;Save Side
                                 	
000226 dfcd                      	rcall WaitTIwrite	;Wait for data from TI
000227 9100 0103                 	lds r16,fdcData	
000229 9300 0102                 	sts fdcSector,r16	;Save Sector
                                 
                                 ;Get (FB, 256 bytes E5, F7)	
                                 LP27:	
00022b dfc8                      	rcall WaitTIwrite	;Wait for data from TI
00022c 9100 0103                 	lds r16,fdcData		;Get next byte
00022e 3f0b                      	cpi r16,0xFB
00022f f7d9                      	brne LP27
                                 	
000230 e0f1                       	ldi ZH, high(TIbuffer)	;Get address to buffer
000231 e2e8                      	ldi ZL, low(TIbuffer)	; "
000232 e020                      	ldi r18, 0x00		;256 bytes per sector
                                 lp28:	
000233 dfc0                      	rcall WaitTIwrite	;Wait for data from TI
000234 9100 0103                 	lds r16, fdcData	;Get next byte
000236 9301                      	st Z+, r16		;Save to buffer
000237 952a                      	dec r18
000238 f7d1                      	brne LP28
                                 	
000239 9a3a                      	sbi PortE, 2		;Put TI on hold while process command
00023a df7a                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
00023b dfd1                      	rcall TI_SD_wr		;Write to SD
                                 	
00023c 954a                      	dec r20			;All 9 sectors done?
00023d f6e1                      	brne LP25      
00023e 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;All disks names 0-255 sent to TI
                                 ; ENTRY:
                                 ;
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 SendNames:
                                 ;Send disk numbers DSK1-3 
00023f e001                      	ldi r16, 0x01
000240 9300 0119                 	sts arg, r16		; (LSB) sector 00 00 00 01
000242 2700                       	clr r16
000243 9300 011a                 	sts arg+1, r16
000245 9300 011b                 	sts arg+2, r16
000247 9300 011c                 	sts arg+3, r16		; (MSB)
000249 d22d                      	rcall ReadMMC           ; Read sector 1
00024a e0f2                      	ldi ZH, high(SDbuffer+4)	; Point to disk #s in buffer
00024b e2ec                      	ldi ZL, low(SDbuffer+4)	; "
                                    
00024c e043                      	ldi r20, 3
00024d 9101                      lp93:	ld r16, Z+		;Mov char from buffer to fdcData
00024e 9300 0103                 	sts fdcData,r16		;
000250 983a                      	cbi PortE, 2		;Release TI
000251 df98                      	rcall WaitTIread	;Wait for TI to read
000252 9a3a                      	sbi PortE, 2		;Put TI on hold
000253 954a                      	dec r20
000254 f7c1                      	brne lp93
                                 	
                                 ;Send Names
000255 2755                      	clr r21			;Start at disk 0
000256 d02c                      lp91:	rcall Disk2Sector	;Convert disk# in R21 to sector address
000257 d21f                      	rcall ReadMMC           ;Read sector
000258 e2e8                      	ldi ZL, low(SDbuffer)	;Get address to buffer
000259 e0f2                      	ldi ZH, high(SDbuffer)	; "
                                 	
00025a e04a                      	ldi r20, 10
00025b 9101                      lp92:	ld r16, Z+		;Mov char from buffer to fdcData
00025c 9300 0103                 	sts fdcData,r16		;
00025e 983a                      	cbi PortE, 2		;Release TI
00025f df8a                      	rcall WaitTIread	;Wait for TI to read
000260 9a3a                      	sbi PortE, 2		;Put TI on hold
000261 954a                      	dec r20
000262 f7c1                      	brne lp92
                                 	
000263 9553                      	inc r21			;Next disk
000264 f789                      	brne LP91		;If roll over then finished
000265 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Change disk in drive
                                 ; ENTRY:
                                 ;	From TI	- r20 Drive 1-3 
                                 ;	From TI - r21 Disk 0-255
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r17 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ChgDisk:
                                 ;Get drive number from TI
000266 983a                      	cbi PortE, 2		;Release TI
000267 df8c                      	rcall WaitTIwrite	;Wait for data from TI
000268 9140 0103                 	lds r20, fdcData	;Get Drive number
00026a 7043                      	andi r20, 0x03		;
00026b 954a                      	dec r20			;DSK 1-3 to 0-2
                                 ;Get disk number from TI
00026c df87                      	rcall WaitTIwrite	;Wait for data from TI
00026d 9150 0103                 	lds r21, fdcData	;Get disk number
00026f 9a3a                      	sbi PortE, 2		;Put TI on hold
                                 	
                                 ;Put new disk number in sector 1	
000270 e001                      	ldi r16, 0x01
000271 9300 0119                 	sts arg, r16		; (LSB) sector 00 00 00 01
000273 2700                       	clr r16
000274 9300 011a                 	sts arg+1, r16
000276 9300 011b                 	sts arg+2, r16
000278 9300 011c                 	sts arg+3, r16		; (MSB)
00027a d1fc                      	rcall ReadMMC           ; Read sector 1
00027b e0f2                      	ldi ZH, high(SDbuffer)	; Get address to buffer
00027c e2e8                      	ldi ZL, low(SDbuffer)	; "
                                 ; Drive number r20
                                 ; Disk number r21
00027d 0fe4                      	add ZL, r20		;Point to drive in sector 1		
00027e 2700                      	clr r16			; "
00027f 1ff0                      	adc ZH, r16		; "
000280 8354                      	std Z+4, r21		; Save new disk number
000281 d1c2                      	rcall WriteMMC          ; Write sector 1 back to SD
000282 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Multiply DISK number and store sector address at DSKx addresses
                                 ; Entry:
                                 ;	r21 = disk number
                                 ;
                                 ; Exit:	    
                                 ;	Disk sector address store in arg also in r0-r3	
                                 ;	Registers used r0-r5 r16 r17 Z
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Disk2Sector:
000283 2e55                       	mov r5, r21		    ;Save dsisk number
                                 
000284 e0f1                      	ldi ZH, high(StartSector)   ; "
000285 e2e4                      	ldi ZL, low(StartSector)    ; "
000286 9001                      	ld r0, Z+		    ;initilize to start sector
000287 9011                      	ld r1, Z+		    ; "
000288 2422                      	clr r2			    ; "
000289 2433                      	clr r3			    ; "
00028a 9101                      	ld r16, Z+		    ;Get step sectors
00028b 9111                      	ld r17, Z+		    ; "   
                                 
00028c 2055                      	tst r5			    ; Test for Disk number zero
00028d f019                      	breq jp90		    ; skip if zero
00028e d009                      lp90:	rcall Add32_16		    ;Multiply disk number by step
00028f 945a                      	dec r5			    ; "
000290 f7e9                      	brne LP90		    ; "
                                 	
000291 e0f1                      jp90:	ldi ZH, high(arg)	    ;Place result in argument
000292 e1e9                      	ldi ZL, low(arg)	    ; "
000293 9201                       	st Z+, r0
000294 9211                      	st Z+, r1	
000295 9221                      	st Z+, r2	
000296 9231                      	st Z+, r3
000297 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Add 16 bits to 32 bits (lsbyte first)
                                 ; Entry		r0,r1,r2,r3 + r16,r17 
                                 ; Exit result	r0,r1,r2,r3
                                 ; r4 cleared, r16,r17 not destroyed	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Add32_16:	
000298 2444                      	clr r4
000299 0e00                      	add r0, r16  ;add low byte
00029a 1c14                      	adc r1, r4
00029b 1c24                      	adc r2, r4
00029c 1c34                      	adc r3, r4
00029d 0e11                      	add r1, r17 ;add high byte
00029e 1c24                      	adc r2, r4
00029f 1c34                      	adc r3, r4
0002a0 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; USART routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 USARTInit:
0002a1 b909                      	out UBRR0L, r16			  ;Set Baud rate
0002a2 bd10                      	out UBRR0H, r17
0002a3 e806                      	ldi r16, (1<<URSEL0)|(3<<UCSZ00)	  ;8N1
0002a4 bd00                      	out UCSR0C, r16
0002a5 e108                      	ldi r16, (1<<RXEN)|(1<<TXEN)	  ;Enable receive & transmit
0002a6 b90a                      	out UCSR0B, r16
0002a7 e002                      	ldi r16, (1<<U2X)		    ;Double the baud rate
0002a8 b90b                      	out UCSR0A, r16
0002a9 9508                      	ret
                                 USARTRead:
0002aa 9b5f                      	sbis	UCSR0A, RXC		  ;Wait until data is available
0002ab cffe                      	rjmp USARTRead
0002ac b10c                      	in r16, UDR			  ;Get received data
0002ad 9508                      	ret
                                 USARTWrite:
0002ae 9b5d                      	sbis	UCSR0A, UDRE		   ;Wait until transmit is ready
0002af cffe                      	rjmp USARTWrite
0002b0 b90c                      	out UDR, r16			   ;Send data
0002b1 9508                      	ret
                                 USARTFlush:
0002b2 9b5f                      	sbis UCSR0A, RXC
0002b3 9508                      	ret
0002b4 b10c                      	in r16, UDR
0002b5 cffc                      	rjmp USARTFlush
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; SPI routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SPIInit:
0002b6 e503                      	ldi r16, (1<<SPE)|(1<<MSTR)|(3<<SPR0)	;En SPI, Master, fosc/128(125k)
0002b7 b90d                      	out SPCR, r16	;DORD=MSB, CPOL=rising, CPHA=LeadSample/TrailSetup
                                 ;	ldi r16,(1<<SPI2X)			; SPI double speed
                                 ;	out SPSR,r16	
0002b8 9508                      	ret
                                 SPIRead:
0002b9 ef0f                      	ser r16			;Transmit ones to receive byte
                                 SPIWrite:
0002ba b90f                      	out SPDR, r16		;Send transmit byte
                                 SPIWait:	
0002bb 9b77                      	sbis SPSR, SPIF		;Wait Fot Transmission complete
0002bc cffe                      	rjmp SPIWait
0002bd b10f                      	in	r16, SPDR	; Get received byte
0002be 9508                      	ret
                                 FullThrottle:
0002bf 9868                      	cbi SPCR, SPR0
0002c0 9869                      	cbi SPCR, SPR1
0002c1 9a70                      	SBI SPSR, SPI2X
0002c2 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ; Access EXFAT find file TIVOL000
                                 ;	
                                 ;************************************************************************************
                                 ; Process Master Boot Sector
                                 ;************************************************************************************
                                 FindTIVOL:
0002c3 2700                      	clr r16				;Get MBR sector
0002c4 9300 0119                 	sts arg, r16			; (LSB) sector 00 00 00 00
0002c6 9300 011a                 	sts arg+1, r16
0002c8 9300 011b                 	sts arg+2, r16
0002ca 9300 011c                 	sts arg+3, r16			; (MSB)
0002cc d1aa                      	rcall ReadMMC           	; First 512 sector (uses ZL & ZH)
                                 		
0002cd eeee                      	ldi ZL, low(SDbuffer+0x1C6)	;Save VBR address
0002ce e0f3                      	ldi ZH, high(SDbuffer+0x1C6)	;
0002cf e2c0                      	ldi YL, low(vbr)    		; "
0002d0 e0d1                      	ldi YH, high(vbr)   		; "
0002d1 d21e                      	rcall mov4
                                 
                                 ;************************************************************************************
                                 ; Process Volume Boot Sector
                                 ;************************************************************************************
0002d2 e2e0                      	ldi ZL, low(vbr)		;Put vbr in arg
0002d3 e0f1                      	ldi ZH, high(vbr)		;
0002d4 e1c9                      	ldi YL, low(arg)    		; "
0002d5 e0d1                      	ldi YH, high(arg)   		; "
0002d6 d219                      	rcall mov4
0002d7 d19f                      	rcall ReadMMC           	; Get VBR sector	
                                 	
0002d8 e2e8                      	ldi ZL, low(SDbuffer)		;Point to buffer
0002d9 e0f2                      	ldi ZH, high(SDbuffer)		;
0002da e3c4                      	ldi YL, low(EXFATstr<<1)
0002db e0d1                      	ldi YH, high(EXFATstr<<1)
0002dc d200                      	rcall cmpstr
0002dd f509                      	brne DiskErrRly			;Partition is not EXFAT
                                 
0002de e8e8                      	ldi ZL, low(SDbuffer+0x60)	;Get RootDirectory cluster
0002df e0f2                      	ldi ZH, high(SDbuffer+0x60)	; "
0002e0 e1c9                      	ldi YL, low(arg)    		; "
0002e1 e0d1                      	ldi YH, high(arg)   		; "
0002e2 d20d                      	rcall mov4
                                 
0002e3 e9e5                      	ldi ZL, low(SDbuffer+0x6D)	;Point to SectorsPerCluster
0002e4 e0f2                      	ldi ZH, high(SDbuffer+0x6D)	;
0002e5 8130                      	ld r19, Z			;
0002e6 9330 011f                 	sts SectorsPerCluster, r19 	;Save SectorsPerCluster
0002e8 d1dd                      	rcall LslArg			;RootDirectory * SectorsPerCluster
                                 
                                 ;************************************************************************************
                                 ; Process Root Directory Sector	(Find VOLUMES folder)
                                 ;************************************************************************************
0002e9 e1a9                      	ldi XL, low(arg)		;Add VBR offset to RootDirectory in arg
0002ea e0b1                      	ldi XH, high(arg)		; "
0002eb e2c0                      	ldi YL, low(vbr)    		; "
0002ec e0d1                      	ldi YH, high(vbr)   		; "
0002ed d208                      	rcall AddDword			; "
0002ee d188                      	rcall ReadMMC           	;Get RootDirectory sector
                                 	    
0002ef e2e8                      	ldi ZL, low(SDbuffer)		;Point to buffer
0002f0 e0f2                      	ldi ZH, high(SDbuffer)		;
0002f1 e3ce                      	ldi YL, low(VOLstr<<1)
0002f2 e0d1                      	ldi YH, high(VOLstr<<1)
                                 
0002f3 8100                      LP06:	ld r16, Z
0002f4 3c01                      	cpi r16, 0xC1			;Check for type C1 entry
0002f5 f411                      	brne JP06
0002f6 d1e6                      	rcall cmpstr
0002f7 f041                      	breq JP03
                                 
0002f8 96b0                      JP06:	adiw ZH:ZL, 32			;Next entry
0002f9 e208                      	ldi R16, low(SDbuffer+512)
0002fa 17e0                      	cp ZL, r16			;Check end of buffer
0002fb f7b9                      	brne LP06  
0002fc e004                      	ldi R16, high(SDbuffer+512)
0002fd 17f0                      	cp ZH, r16			;Check end of buffer
0002fe f7a1                      	brne LP06  
                                 DiskErrRly:
0002ff c052                      	rjmp DiskErr			;VOLUMES not found
                                 
                                 JP03:	
000300 97b0                       	sbiw ZH:ZL, 32			;Back up from type C1 entry to C0 entry
000301 9674                       	adiw ZH:ZL, 20			;Point to VOLUMES folder cluster dword at 20
000302 e1c9                      	ldi YL, low(arg)    		; "
000303 e0d1                      	ldi YH, high(arg)   		; "
000304 d1eb                      	rcall mov4
000305 9130 011f                 	lds r19, SectorsPerCluster
000307 d1be                      	rcall LslArg			;VOLUMES folder * SectorsPerCluster
                                 
                                 ;************************************************************************************
                                 ; Process VOLUMES Sector	(Find TIVOL000 file sector)
                                 ;************************************************************************************
000308 e1a9                      	ldi XL, low(arg)		;Add VBR offset to VOLUMES folder in arg
000309 e0b1                      	ldi XH, high(arg)		; "
00030a e2c0                      	ldi YL, low(vbr)    		; "
00030b e0d1                      	ldi YH, high(vbr)   		; "
00030c d1e9                      	rcall AddDword			; "
00030d d169                      	rcall ReadMMC           	;Get VOLUMES folder sector
                                 	
00030e e2e8                      	ldi ZL, low(SDbuffer)		;Point to buffer
00030f e0f2                      	ldi ZH, high(SDbuffer)		;
000310 e4ce                      	ldi YL, low(TIVOLstr<<1)
000311 e0d1                      	ldi YH, high(TIVOLstr<<1)
                                 	
000312 8100                      LP04:	ld r16, Z
000313 3c01                      	cpi r16, 0xC1			;Check for type C1 entry
000314 f411                      	brne JP04
000315 d1c7                      	rcall cmpstr
000316 f041                      	breq JP05			;TIVOL000 found
                                 
000317 96b0                      JP04:	adiw ZH:ZL, 32			;Next entry
000318 e208                      	ldi R16, low(SDbuffer+512)
000319 17e0                      	cp ZL, r16			;Check end of buffer
00031a f7b9                      	brne LP04  
00031b e004                      	ldi R16, high(SDbuffer+512)
00031c 17f0                      	cp ZH, r16			;Check end of buffer
00031d f7a1                      	brne LP04  
00031e c033                      	rjmp DiskErr			;TIVOL000 not found
                                 
00031f 97b0                      JP05:	sbiw ZH:ZL, 32			;Back up from type C1 entry to C0 entry
000320 9674                      	adiw ZH:ZL, 20			;Point TIVOL000 file cluster dword at 20
000321 e1c9                      	ldi YL, low(arg)    		; TIVOL000 file cluster
000322 e0d1                      	ldi YH, high(arg)   		; "
000323 d1cc                      	rcall mov4
000324 9130 011f                 	lds r19, SectorsPerCluster
000326 d19f                      	rcall LslArg			;TIVOL000 file * SectorsPerCluster
                                 
000327 e1a9                      	ldi XL, low(arg)		;Add VBR offset to TIVOL000 file in arg
000328 e0b1                      	ldi XH, high(arg)		; "
000329 e2c0                      	ldi YL, low(vbr)    		; "
00032a e0d1                      	ldi YH, high(vbr)   		; "
00032b d1ca                      	rcall AddDword			;
00032c 9100 0119                 	lds r16, arg			;Save TIVOL000 start sector
00032e 9300 0124                 	sts StartSector, r16		; "
000330 9100 011a                 	lds r16, arg+1			; "
000332 9300 0125                 	sts StartSector+1, r16		; " 
                                 
000334 e1c9                      	ldi YL, low(arg)    		;Z left pointing to file size at 24
000335 e0d1                      	ldi YH, high(arg)   		;file size is qword but we will never exceed dword
000336 d1b9                      	rcall mov4
                                 		
000337 9130 011f                 	lds r19, SectorsPerCluster
000339 e009                      	ldi r16, 9
00033a 0f30                      	add r19, r16
00033b d1cb                      	rcall LsrArg			;Divide by SectorsPerCluster + 512 bytes per sector
00033c f44e                      	brtc JP01			;If t not set then no carry (no remainder)
00033d 91e0 0119                 	lds ZL, arg
00033f 91f0 011a                 	lds ZH, arg+1
000341 9631                      	adiw ZH:ZL, 1
000342 93e0 0119                 	sts arg, ZL
000344 93f0 011a                 	sts arg+1, ZH
000346 9130 011f                 JP01:	lds r19, SectorsPerCluster
000348 d17d                      	rcall LslArg			;Size in clusters back to size in sectors
                                 
000349 9100 0119                 	lds r16, arg			;Save sector step
00034b 9300 0126                 	sts StepSectors, r16		; "
00034d 9100 011a                 	lds r16, arg+1			; "
00034f 9300 0127                 	sts StepSectors+1, r16		; 
                                 	
000351 9418                      	sez				;Set Z bit (No error)
                                 DiskErr:				;Return error, Z bit cleared
000352 9508                      	ret				;On return will set disk ready status	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;	
                                 ; Low level SD card access
                                 ;	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send command to MMC, Uses cmd resp r16 r17 r18 nz=error
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendMMC:
                                     ;4.8ms delay, PNY 1GB had trouble without delay
000353 d154                          	rcall delay1ms
000354 d153                      	rcall delay1ms
000355 d152                      	rcall delay1ms
000356 d151                      	rcall delay1ms
000357 d150                      	rcall delay1ms
                                 		
000358 ef0f                      	ldi r16, 0xFF		;
000359 df60                             	rcall SPIWrite	;
00035a 9100 0118                 	lds r16,cmd		; Send the command byte
00035c df5d                      	rcall SPIWrite	;
00035d 9100 011c                 	lds r16, arg+3		; Send 4 argument bytes starting with MSB
00035f df5a                      	rcall SPIWrite	;
000360 9100 011b                 	lds r16, arg+2		;
000362 df57                      	rcall SPIWrite	;
000363 9100 011a                 	lds r16, arg+1		;
000365 df54                      	rcall SPIWrite	;
000366 9100 0119                 	lds r16, arg		;
000368 df51                      	rcall SPIWrite	;
000369 9100 011d                 	lds r16, crc		; Send the CRC7 byte (always use 95)
00036b df4e                             	rcall SPIWrite	;
                                 			
                                 WaitResp:
00036c 2722                      	clr r18
                                 LP10:
                                     ;.69ms delay, PNY 1GB had trouble without delay	
00036d d13a                      	rcall delay1ms		
                                 				
00036e df4a                      	rcall SPIRead	;
00036f 9110 011e                 	lds r17, resp
000371 1701                      	cp r16,r17		; expected response?
000372 f021                      	breq JP11		; YES - return
000373 952a                      	dec r18			; waiting period is over?
000374 f7c1                             	brne LP10		; NO - keep waiting
000375 d126                      	rcall SendErrorSPI	;
000376 9498                      	clz			; Clear zero flag for time out
000377 9508                      JP11:	ret			;
                                 
                                     
                                 ;********************************************************************
                                 ; Init SD/MMC memory card
                                 ;******************************************************************** 
                                 MMCInit:	
000378 9ac4                      	sbi PortB, CS		    ; disable MMC
000379 e01a                      	ldi r17, 10		    ; Send 80 dummy clocks
                                 LP20:
00037a df3e                      	rcall SPIRead	    ;
00037b 951a                             	dec R17			    ;
00037c f7e9                      	brne LP20		    ;
00037d 98c4                              cbi PortB, CS		    ; enable MMC         
                                 SendCMD0:
00037e e400                      	ldi r16, 0x40		    ; CMD0 GO_IDLE_STATE
00037f 9300 0118                 	sts cmd, r16              
000381 2700                             	clr r16			    ; LSB
000382 9300 0119                 	sts arg, r16                ; 0x00000000
000384 9300 011a                 	sts arg+1, r16              ;	
000386 9300 011b                 	sts arg+2, r16              ;	
000388 9300 011c                 	sts arg+3, r16              ; MSB
00038a e905                      	ldi r16, 0x95
00038b 9300 011d                        	sts crc, r16
00038d e001                      	ldi r16, 1
00038e 9300 011e                 	sts resp, r16		    ; expected response cnt 8
000390 dfc2                      	rcall SendMMC		    ;
000391 f761                             	brne SendCMD0		    ; Expected response timed out
                                 SendCMD8:
000392 e408                      	ldi r16, 0x48		    ; CMD8 SEND_IF_COND
000393 9300 0118                 	sts cmd, r16
000395 ea0a                      	ldi r16, 0xAA		    ; LSB
000396 9300 0119                 	sts arg, r16                ; 0x000001AA
000398 e001                      	ldi r16, 0x01		    ;
000399 9300 011a                 	sts arg+1, r16              ;
00039b 2700                      	clr r16			    ;
00039c 9300 011b                 	sts arg+2, r16              ;
00039e 9300 011c                 	sts arg+3, r16              ; MSB
0003a0 e807                      	ldi r16, 0x87
0003a1 9300 011d                 	sts crc, r16
0003a3 e001                      	ldi r16, 1		    ; Response V2=0x01 0x000001AA or V1=0x05
0003a4 9300 011e                 	sts resp, r16
0003a6 dfac                      	rcall SendMMC               ; 
0003a7 f571                      	brne SendCMD1
0003a8 df10                      	rcall SPIRead		    ; need to clear 0x000001AA
0003a9 df0f                      	rcall SPIRead		    ;	
0003aa df0e                              rcall SPIRead		    ;	      	
0003ab df0d                      	rcall SPIRead		    ;			; 
                                 			
                                 ;ACMD41 (CMD55+CMD41)			
                                 SendCMD55:
0003ac e707                      	ldi r16, 0x77		    ; CMD55 APP_CMD
0003ad 9300 0118                 	sts cmd, r16              
0003af 2700                             	clr r16			    ; LSB
0003b0 9300 0119                 	sts arg, r16                ; 0x00000000
0003b2 9300 011a                 	sts arg+1, r16              ;	
0003b4 9300 011b                 	sts arg+2, r16              ;	
0003b6 9300 011c                 	sts arg+3, r16              ; MSB
0003b8 ef0f                      	ldi r16, 0xFF
0003b9 9300 011d                        	sts crc, r16
0003bb e001                      	ldi r16, 1
0003bc 9300 011e                 	sts resp, r16		    ; expected response
0003be df94                      	rcall SendMMC		    ;
0003bf f761                             	brne SendCMD55		    ;  Expected response timed out	
                                 SendCMD41: 	
0003c0 e609                      	ldi r16, 0x69		    ; CMD41 SD_SEND_OP_COND
0003c1 9300 0118                 	sts cmd, r16              
0003c3 2700                             	clr r16			    ; LSB
0003c4 9300 0119                 	sts arg, r16                ; 0x40000000
0003c6 9300 011a                 	sts arg+1, r16              ;
0003c8 9300 011b                 	sts arg+2, r16              ;
0003ca e400                      	ldi r16, 0x40
0003cb 9300 011c                 	sts arg+3, r16              ; MSB
0003cd ef0f                      	ldi r16, 0xFF
0003ce 9300 011d                        	sts crc, r16
0003d0 2700                      	clr r16
0003d1 9300 011e                 	sts resp, r16		    ; expected response
0003d3 df7f                      	rcall SendMMC		    ;
0003d4 f6b9                             	brne SendCMD55		    ;  Expected response timed out
0003d5 c014                      	rjmp SendCMD58
                                 
                                 SendCMD1:
0003d6 e401                      	ldi r16, 0x41		    ; CMD1 SEND_OP_COND
0003d7 9300 0118                 	sts cmd, r16              
0003d9 2700                             	clr r16			    ; LSB
0003da 9300 0119                 	sts arg, r16                ; 0x00000000
0003dc 9300 011a                 	sts arg+1, r16              ;	
0003de 9300 011b                 	sts arg+2, r16              ;	
0003e0 9300 011c                 	sts arg+3, r16              ; MSB
0003e2 ef0f                      	ldi r16, 0xFF
0003e3 9300 011d                        	sts crc, r16
0003e5 2700                      	clr r16
0003e6 9300 011e                 	sts resp, r16		    ; expected response
0003e8 df6a                      	rcall SendMMC		    ;
0003e9 f761                             	brne SendCMD1		    ;  Expected response timed out
                                    			
                                 SendCMD58:
0003ea e70a                      	ldi r16, 0x7A		    ; CMD58 READ_OCR
0003eb 9300 0118                 	sts cmd, r16              
0003ed 2700                             	clr r16			    ; LSB
0003ee 9300 0119                 	sts arg, r16                ; 0x00000000
0003f0 9300 011a                 	sts arg+1, r16              ;	
0003f2 9300 011b                 	sts arg+2, r16              ;	
0003f4 9300 011c                 	sts arg+3, r16              ; MSB
0003f6 ef0f                      	ldi r16, 0xFF
0003f7 9300 011d                        	sts crc, r16
0003f9 2700                      	clr r16
0003fa 9300 011e                 	sts resp, r16		    ; expected response
0003fc df56                      	rcall SendMMC		    ;
0003fd f761                             	brne SendCMD58		    ;  Expected response timed out
                                 
0003fe e0f2                      	ldi ZH, high(SDbuffer)	    ; Get address to buffer
0003ff e2e8                      	ldi ZL, low(SDbuffer)	    ; "
000400 e034                      	ldi R19, 4
                                 LP21:
000401 deb7                      	rcall SPIRead		    ; Get MSByte 1 of 4 OCR register
000402 9301                      	st Z+, r16		    ; Save OCR to buffer
000403 953a                      	dec R19
000404 f7e1                      	brne LP21
000405 9100 0228                 	lds r16, SDbuffer
000407 9300 0117                 	sts ocr, r16		    ; bit6=1 SDHC
                                 
                                 SendCMD9:
000409 e409                      	ldi r16, 0x49		    ; CMD9 READ_CSD
00040a 9300 0118                 	sts cmd, r16              
00040c 2700                             	clr r16			    ;
00040d 9300 011e                 	sts resp, r16		    ; expected response
00040f df43                      	rcall SendMMC		    ;
000410 f7c1                      	brne SendCMD9		    ; Expected response timed out
000411 ef0e                      	ldi r16, 0xFE
000412 9300 011e                 	sts resp, r16
000414 df57                      	rcall WaitResp		    ; Wait for FE Start
000415 f799                      	brne SendCMD9
000416 e132                      	ldi r19, 18
                                 LP22:	
000417 dea1                      	rcall SPIRead
000418 953a                      	dec r19
000419 f7e9                      	brne LP22
                                 
                                 SendCMD10:
00041a e40a                          	ldi r16, 0x4A		    ; CMD10 READ_CID
00041b 9300 0118                 	sts cmd, r16              
00041d 2700                             	clr r16			    ;
00041e 9300 011e                 	sts resp, r16		    ; expected response
000420 df32                      	rcall SendMMC		    ;
000421 f7c1                      	brne SendCMD10		    ; Expected response timed out
000422 ef0e                      	ldi r16, 0xFE
000423 9300 011e                 	sts resp, r16
000425 df46                      	rcall WaitResp		    ; Wait for FE Start
000426 f799                      	brne SendCMD10
000427 e132                          	ldi r19, 18
                                 LP23:	
000428 de90                      	rcall SPIRead
000429 953a                      	dec r19
00042a f7e9                      	brne LP23
                                 
00042b de93                      	rcall FullThrottle
                                 			
                                 ; Let fall thru to Set Block			
                                 ;********************************************************************
                                 ; CMD16 SET_BLOCKLEN default 512
                                 ; The only valid block length for write is 512!
                                 ; Read is 1 to 2048
                                 ;********************************************************************
                                 SetBlockMMC: 
00042c 98c4                      	cbi PortB, CS		    ; enable MMC         
00042d e500                      	ldi r16, 0x50		    ; CMD16 SET_BLOCKLEN
00042e 9300 0118                 	sts cmd, r16              
000430 2700                             	clr r16			    ; LSB
000431 9300 0119                 	sts arg, r16                ; 0x00000200 (512 block)
000433 e002                      	ldi r16, 2
000434 9300 011a                 	sts arg+1, r16              ;
000436 2700                      	clr r16
000437 9300 011b                 	sts arg+2, r16              ;	
000439 9300 011c                 	sts arg+3, r16              ; MSB
00043b 2700                      	clr r16
00043c 9300 011d                 	sts crc, r16
00043e 9300 011e                 	sts resp, r16		    ; expected response
000440 df12                      	rcall SendMMC		    ;
000441 f751                             	brne SetBlockMMC	    ; Expected response timed out
000442 9ac4                      	sbi PortB, CS		    ; Disable MMC
000443 9508                      	ret 							;
                                 
                                 ;********************************************************************
                                 ; CMD24 WRITE_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ; Exit nz=write error
                                 ;********************************************************************
                                 WriteMMC:			    ;Write 1st 256 bytes of sector
000444 98c4                      	cbi PortB, CS		    ; enable MMC   
000445 d06d                      	rcall SaveArg		    ; Save argument, in case multipled
                                 	
000446 9100 0117                 	lds r16, ocr
000448 ff06                      	sbrs r16, ccs		    ; Skip bit 6 is 1 (SDHC)
000449 d07b                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 LP40:
00044a e508                      	ldi r16, 0x58		    ; CMD24 WRITE_BLOCK
00044b 9300 0118                 	sts cmd, r16 
00044d 2700                      	clr r16
00044e 9300 011d                 	sts crc, r16
000450 9300 011e                 	sts resp, r16		    ; expected response
000452 df00                      	rcall SendMMC		    ;
000453 f7b1                             	brne LP40		    ; Expected response timed out
                                 	
000454 de64                      	rcall SPIRead		    ; write prefix (Read writes FFFF)
000455 de63                      	rcall SPIRead
000456 ef0e                      	ldi r16, 0xFE		    ; Send start data token
000457 de62                      	rcall SPIWrite
                                 	
000458 e0f2                      	ldi ZH, high(SDbuffer)	    ; Get address to buffer
000459 e2e8                      	ldi ZL, low(SDbuffer)	    ; "
00045a 2733                      	clr R19			    ; Write 256 bytes to SD
                                 ;Write 1st 256 bytes of sector	
                                 LP41:
00045b 9101                      	ld r16,Z+
00045c de5d                      	rcall SPIWrite		    ; Write data byte
00045d 953a                      	dec R19
00045e f7e1                      	brne LP41
                                 ;Write 2nd 256 bytes of sector    		 
                                 LP42:
00045f 9101                      	ld r16,Z+
000460 de59                      	rcall SPIWrite		    ; Write data byte
000461 953a                      	dec R19
000462 f7e1                      	brne LP42				
000463 de55                      	rcall SPIRead		    ; write 2 bytes CRC 0xFF (Read writes FFFF)
000464 de54                      	rcall SPIRead		    ;  "
                                 	    
000465 de53                      	rcall SPIRead		    ; was data accepted			
000466 710f                      	andi r16, 0x1F
000467 3005                      	cpi r16, 5
000468 f449                      	brne JP45
000469 ef0f                      	ldi r16, 0xFF		    ; wait for 0xFF
00046a 9300 011e                 	sts resp, r16
00046c deff                      	rcall WaitResp
00046d f421                      	brne JP45
00046e d04d                      	rcall RestoreArg
00046f 9ac4                      	sbi PortB, CS		    ; Disable MMC
000470 9418                      	sez			    ;Set zero fla
000471 9508                             	ret			    ; normal return z-flag set
                                 JP45:
000472 d049                      	rcall RestoreArg
000473 d028                      	rcall SendErrorSPI         
000474 9ac4                      	sbi PortB, CS		    ; Disable MMC
000475 9498                      	clz			    ;Clr zero flag
000476 9508                      	ret			    ; write error return z-flag clear
                                  			
                                 			
                                       		
                                 ;********************************************************************
                                 ; CMD17 READ_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ;********************************************************************
                                 ReadMMC:			    ;Read 1st 256 bytes of sector
000477 98c4                      	cbi PortB, CS		    ; enable MMC   
000478 d03a                      	rcall SaveArg		    ; Save argument, in case multipled
                                 	
000479 9100 0117                 	lds r16, ocr
00047b ff06                      	sbrs r16, ccs		    ; Skip bit 6 is 1 (SDHC)
00047c d048                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 LP50:
00047d e501                      	ldi r16, 0x51		    ; CMD17 READ_SINGLE_BLOCK
00047e 9300 0118                 	sts cmd, r16 
000480 2700                      	clr r16
000481 9300 011d                 	sts crc, r16
000483 9300 011e                 	sts resp, r16		    ; expected response
000485 decd                      	rcall SendMMC		    ;
000486 f7b1                             	brne LP50		    ; Expected response timed out
                                 	
000487 ef0e                      	ldi r16, 0xFE		    ; Send start data token
000488 9300 011e                 	sts resp, r16
00048a dee1                      	rcall WaitResp		    ; Wait for FE Start
00048b f789                      	brne LP50
                                 ;Read 1st 256 bytes of sector	
00048c e0f2                      	ldi ZH, high(SDbuffer)	    ; Get address to buffer
00048d e2e8                      	ldi ZL, low(SDbuffer)	    ; "
00048e 2733                      	clr R19			    ; Always read 256 the size of buffer
                                 LP51:
00048f de29                      	rcall SPIRead		    ; Get data byte
000490 9301                      	st Z+, r16
000491 953a                      	dec R19
000492 f7e1                      	brne LP51
                                 ;Read 2nd 256 bytes of sector    		 
                                 LP52:
000493 de25                      	rcall SPIRead		    ; Get data byte
000494 9301                      	st Z+, r16
000495 953a                      	dec R19
000496 f7e1                      	brne LP52		
000497 de21                      	rcall SPIRead		    ; read 2 bytes CRC	
000498 de20                      	rcall SPIRead		    ; and discard	
000499 9ac4                      	sbi PortB, CS		    ; Disable MMC
00049a d021                       	rcall RestoreArg
00049b 9508                         	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send error command/response to PC
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendErrorSPI:
00049c de11                             	rcall USARTWrite	    ; Send response received
00049d 9100 011e                 	lds r16, resp		    
00049f de0e                      	rcall USARTWrite	    ; Send expected response
0004a0 9100 0118                 	lds r16, cmd
0004a2 de0b                      	rcall USARTWrite	    ; Send cmd used
0004a3 94aa                      	dec r10
                                 ErrLP:	
0004a4 f3f9                      	breq ErrLP		    ; Keep from runnig away, Until reset
0004a5 9508                      	ret			    ; Fail 2 or 3 times on start, Just return 
                                 	
                                 SendErrorMedia:
0004a6 0000                      	nop
0004a7 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 delay1ms:		;  15431x.0625us aprox 1ms, not exact(.965ms)
0004a8 930f                      	push r16	;   2
0004a9 931f                      	push r17	;   2
0004aa e114                      	ldi r17, 20	;   1
0004ab 2700                      	clr r16		;   1
0004ac 950a                      dly1:	dec r16		; 768x20=15360          
0004ad f7f1                              brne dly1	; 
0004ae 951a                      	dec r17		; 3x20=60   
0004af f7e1                      	brne dly1
0004b0 911f                      	pop r17		;   2
0004b1 910f                      	pop r16		;   2
0004b2 9508                      	ret		;   1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                  SaveArg:   
0004b3 9060 0119                     	lds r6, arg		; Save argument, in case multipled
0004b5 9070 011a                   	lds r7, arg+1
0004b7 9080 011b                   	lds r8, arg+2
0004b9 9090 011c                   	lds r9, arg+3
0004bb 9508                      	ret
                                 RestoreArg:
0004bc 9290 011c                 	sts arg+3, r9		; Restore argument
0004be 9280 011b                 	sts arg+2, r8 
0004c0 9270 011a                 	sts arg+1, r7  
0004c2 9260 0119                 	sts arg, r6
0004c4 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 Mul512Arg:
0004c5 e039                      	ldi r19, 9		; multiply arg by 512
                                 LslArg:				; shift arg left per r19
                                 LP60:	
0004c6 9100 0119                 	lds r16, arg
0004c8 0f00                      	lsl r16
0004c9 9300 0119                 	sts arg, r16
0004cb 9100 011a                 	lds r16, arg+1
0004cd 1f00                      	rol r16
0004ce 9300 011a                 	sts arg+1, r16
0004d0 9100 011b                 	lds r16, arg+2
0004d2 1f00                      	rol r16
0004d3 9300 011b                 	sts arg+2, r16
0004d5 9100 011c                 	lds r16, arg+3
0004d7 1f00                      	rol r16
0004d8 9300 011c                 	sts arg+3, r16
0004da 953a                      	dec r19
0004db f751                      	brne LP60
0004dc 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004dd 93ef                      cmpstr:	push ZL
0004de 93ff                      	push ZH
0004df 93cf                      	push YL
0004e0 93df                      	push YH
                                 		
0004e1 018f                      	movw r17:r16,ZH:ZL  ;LPM only works with Z
0004e2 01fe                      	movw ZH:ZL,YH:YL
0004e3 01e8                      	movw YH:YL,r17:r16
                                   	
0004e4 9105                      LP07:	lpm r16, Z+
0004e5 3f0f                      	cpi r16, 0xFF	;Check end of string
0004e6 f021                      	breq JP07
0004e7 9119                      	ld r17, Y+
0004e8 1701                      	cp r16, r17
0004e9 f409                      	brne JP07	;Not equal, return
0004ea cff9                      	rjmp LP07	;Next char
0004eb 91df                      JP07:	pop YH
0004ec 91cf                      	pop YL
0004ed 91ff                      	pop ZH
0004ee 91ef                      	pop ZL
0004ef 9508                      	ret		
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004f0 e004                      mov4:	ldi r16, 4		    ;
0004f1 9111                      LP01:	ld r17, Z+ 
0004f2 9319                      	st Y+, r17
0004f3 950a                      	dec r16
0004f4 f7e1                      	brne LP01
0004f5 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Add Dword pointed to by X & Y Result pointed to by X
                                 AddDword:
0004f6 910c                      	ld r16, X
0004f7 9119                      	ld r17, Y+
0004f8 0f01                      	add r16, r17
0004f9 930d                      	st X+, r16
                                 
0004fa 910c                      	ld r16, X
0004fb 9119                      	ld r17, Y+
0004fc 1f01                      	adc r16, r17
0004fd 930d                      	st X+, r16
                                 
0004fe 910c                      	ld r16, X
0004ff 9119                      	ld r17, Y+
000500 1f01                      	adc r16, r17
000501 930d                      	st X+, r16
                                 
000502 910c                      	ld r16, X
000503 9119                      	ld r17, Y+
000504 1f01                      	adc r16, r17
000505 930d                      	st X+, r16
000506 9508                      	ret
                                 
                                 ; shift arg right per r19
000507 94e8                      LsrArg:	clt			
000508 9100 011c                 LP61:	lds r16, arg+3
00050a 9506                      	lsr r16
00050b 9300 011c                 	sts arg+3, r16
00050d 9100 011b                 	lds r16, arg+2
00050f 9507                      	ror r16
000510 9300 011b                 	sts arg+2, r16
000512 9100 011a                 	lds r16, arg+1
000514 9507                      	ror r16
000515 9300 011a                 	sts arg+1, r16
000517 9100 0119                 	lds r16, arg
000519 9507                      	ror r16
00051a 9300 0119                 	sts arg, r16
00051c f408                      	brcc JP61
00051d 9468                      	set		;Set t bit if carry
00051e 953a                      JP61:	dec r19
00051f f741                      	brne LP61


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega162" register use summary:
x  :  11 y  :  12 z  :  38 r0 :  11 r1 :   8 r2 :   5 r3 :   5 r4 :   6 
r5 :   3 r6 :   2 r7 :   2 r8 :   2 r9 :   2 r10:   2 r11:   0 r12:   0 
r13:   2 r14:   2 r15:   7 r16: 408 r17:  61 r18:  12 r19:  24 r20:  12 
r21:   8 r22:   2 r23:   2 r24:   2 r25:   2 r26:   7 r27:   7 r28:  24 
r29:  25 r30:  48 r31:  48 
Registers used: 33 out of 35 (94.3%)

"ATmega162" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  14 add   :   9 adiw  :  11 and   :   0 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :   8 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  68 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  16 cbr   :   2 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  48 cls   :   0 
clt   :   1 clv   :   0 clz   :   2 com   :   1 cp    :   6 cpc   :   0 
cpi   :  24 cpse  :   0 dec   :  26 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  14 inc   :   6 jmp   :   3 
ld    :  32 ldd   :   0 ldi   : 176 lds   :  61 lpm   :   1 lsl   :   1 
lsr   :   2 mov   :   4 movw  :   3 mul   :   1 muls  :   0 mulsu :   0 
neg   :   1 nop   :   3 or    :   0 ori   :   0 out   :  21 pop   :  24 
push  :  26 rcall : 138 ret   :  36 reti  :   2 rjmp  :  26 rol   :   3 
ror   :   4 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   6 sbis  :   6 
sbiw  :   3 sbr   :   5 sbrc  :   5 sbrs  :   6 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   2 ses   :   0 set   :   1 sev   :   0 
sez   :   2 sleep :   0 spm   :   0 st    :  20 std   :   1 sts   : 137 
sub   :   2 subi  :   0 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 56 out of 113 (49.6%)

"ATmega162" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a42   2482     44   2526   16384  15.4%
[.dseg] 0x000100 0x000428      0    808    808    1024  78.9%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
