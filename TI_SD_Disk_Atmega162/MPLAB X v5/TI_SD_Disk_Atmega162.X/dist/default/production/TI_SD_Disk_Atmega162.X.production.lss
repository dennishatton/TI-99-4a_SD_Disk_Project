
AVRASM ver. 2.2.8  main.asm Fri Sep 24 16:15:57 2021

[builtin](2): Including file 'C:/Users/denni/.mchp_packs/Microchip/ATmega_DFP/2.2.108/avrasm/inc\m162def.inc'
[builtin](2): Including file 'C:/Users/denni/.mchp_packs/Microchip/ATmega_DFP/2.2.108/avrasm/inc\m162def.inc'
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega162.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m162def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega162
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega162
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M162DEF_INC_
                                 #define _M162DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega162
                                 #pragma AVRPART ADMIN PART_NAME ATmega162
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x94
                                 .equ	SIGNATURE_002	= 0x04
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	UBRR1H	= 0x3c
                                 .equ	UCSR1C	= 0x3c
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	EMCUCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	TCCR2	= 0x27
                                 .equ	ASSR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	TCNT2	= 0x23
                                 .equ	OCR2	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRR0H	= 0x20
                                 .equ	UCSR0C	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	PORTE	= 0x07
                                 .equ	DDRE	= 0x06
                                 .equ	PINE	= 0x05
                                 .equ	OSCCAL	= 0x04
                                 .equ	OCDR	= 0x04
                                 .equ	UDR1	= 0x03
                                 .equ	UCSR1A	= 0x02
                                 .equ	UCSR1B	= 0x01
                                 .equ	UBRR1L	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 3	; Force Output Compare for Channel A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select1 bit 0
                                 .equ	CS11	= 1	; Clock Select1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Pulse Width Modulator Select Bit 1
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Forde Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE2	= 2	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 4	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 2	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 4	; Output Compare Flag 2
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 3B
                                 .equ	OCF3A	= 4	; Output Compare Flag 3A
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	WGM31	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	FOC3B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC3A	= 3	; Force Output Compare for Channel A
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select3 bit 0
                                 .equ	CS31	= 1	; Clock Select3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	WGM33	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR	= UDR0	; For compatibility
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	USR	= UCSR0A	; For compatibility
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	U2X	= U2X0	; For compatibility
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	DOR	= DOR0	; For compatibility
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	FE	= FE0	; For compatibility
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	UDRE	= UDRE0	; For compatibility
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	TXC	= TXC0	; For compatibility
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 .equ	RXC	= RXC0	; For compatibility
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	UCR	= UCSR0B	; For compatibility
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	TXB8	= TXB80	; For compatibility
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	RXB8	= RXB80	; For compatibility
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	TXEN	= TXEN0	; For compatibility
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	RXEN	= RXEN0	; For compatibility
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	UDRIE	= UDRIE0	; For compatibility
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	TXCIE	= TXCIE0	; For compatibility
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 .equ	RXCIE	= RXCIE0	; For compatibility
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UBRRHI	= UCSR0C	; For compatibility
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 .equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 ;.equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= UBRR0L	; For compatibility
                                 .equ	UBRR	= UBRR0L	; For compatibility
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART1 I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART1 I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART1 I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART1 I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART1 I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART1 I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART1 I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART1 I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	CHR91	= UCSZ12	; For compatibility
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 .equ	URSEL1	= 7	; Register Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Highg Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ;.equ	UBRR1	= UBRR1L	; For compatibility
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 1
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SM	= SM1	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRW	= SRW10	; For compatibility
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	SM2	= 5	; Sleep Mode Select Bit 2
                                 .equ	JDT	= 7	; JTAG Interface Disable
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 .equ	ISC2	= 0	; Interrupt Sense Control 2
                                 .equ	SRW11	= 1	; Wait State Select Bit 1 for Upper Sector
                                 .equ	SRW00	= 2	; Wait State Select Bit 0 for Lower Sector
                                 .equ	SRW01	= 3	; Wait State Select Bit 1 for Lower Sector
                                 .equ	SRL0	= 4	; Wait State Sector Limit Bit 0
                                 .equ	SRL1	= 5	; Wait State Sector Limit Bit 1
                                 .equ	SRL2	= 6	; Wait State Sector Limit Bit 2
                                 .equ	SM0	= 7	; Sleep mode Select Bit 0
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 
                                 ; CLKPR - Clock prescale register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR310	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSR310	; For compatibility
                                 .equ	PSR0	= PSR310	; For compatibility
                                 .equ	PSR1	= PSR310	; For compatibility
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	XMM0	= 3	; External Memory High Mask Bit 0
                                 .equ	XMM1	= 4	; External Memory High Mask Bit 1
                                 .equ	XMM2	= 5	; External Memory High Mask Bit 2
                                 .equ	XMBK	= 6	; External Memory Bus Keeper Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter 0 Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter 0 Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Timer/Counter 0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0	= 0	; Timer/Counter0 Output Compare Match Interrupt register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0	= 0	; Output Compare Flag 0
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 ;.equ	ISC2	= 0	; Interrupt Sense Control 2
                                 
                                 ; GICR - General Interrupt Control Register
                                 .equ	EIMSK	= GICR	; For compatibility
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PCIE0	= 3	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 4	; Pin Change Interrupt Enable 1
                                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	PCIF0	= 3	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 4	; Pin Change Interrupt Flag 1
                                 .equ	INTF2	= 5	; External Interrupt Flag 2
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 1	; Brown out detector trigger level
                                 .equ	BODLEVEL1	= 2	; Brown out detector trigger level
                                 .equ	BODLEVEL2	= 3	; Brown out detector trigger level
                                 .equ	M161C	= 4	; ATMega 161 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x04ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 16384
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1c00
                                 .equ	NRWW_STOP_ADDR	= 0x1fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1bff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x1f80
                                 .equ	SECONDBOOTSTART	= 0x1f00
                                 .equ	THIRDBOOTSTART	= 0x1e00
                                 .equ	FOURTHBOOTSTART	= 0x1c00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	PCI0addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	ICP3addr	= 0x000c	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x000e	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0010	; Timer/Counter3 Compare Match B
                                 .equ	OVF3addr	= 0x0012	; Timer/Counter3 Overflow
                                 .equ	OC2addr	= 0x0014	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0016	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0018	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x001a	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001c	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001e	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x0020	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0022	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0024	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0026	; USART0, Rx Complete
                                 .equ	URXC1addr	= 0x0028	; USART1, Rx Complete
                                 .equ	UDRE0addr	= 0x002a	; USART0 Data register Empty
                                 .equ	UDRE1addr	= 0x002c	; USART1, Data register Empty
                                 .equ	UTXC0addr	= 0x002e	; USART0, Tx Complete
                                 .equ	UTXC1addr	= 0x0030	; USART1, Tx Complete
                                 .equ	ERDYaddr	= 0x0032	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0034	; Analog Comparator
                                 .equ	SPMRaddr	= 0x0036	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 56	; size in words
                                 
                                 #endif  /* _M162DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 ;    TI SD Disk.asm
                                 ;
                                 ; Created: 1/1/2019 3:45:02 PM
                                 ; Author : Dennis Hatton
                                 ;
                                 ; Fuses FF D9 FF
                                 ; 16mhz ext crystal
                                 ;
                                 ;   Atmega8515 Converted to Atmega162		
                                 ;    PortA	PortB	    Portc	PortD	    PortE			
                                 ;    0<Data0	0<A0	    0>Data0	0<RXD	    0<!INT2			
                                 ;    1<Data1	1<A1	    1>Data1	1>TXD	    1<!WE		
                                 ;    2<Data2	2<	    2>Data2	2<	    2>!ready			
                                 ;    3<Data3	3<	    3>Data3	3>HLD			
                                 ;    4<Data4	4>CS	    4>Data4	4<Drive1
                                 ;    5<Data5	5>MOSI	    5>Data5	5<Drive2    
                                 ;    6<Data6	6<MISO	    6>Data6	6<Drive3
                                 ;    7<Data7	7>SCK	    7>Data7	7<Side   
                                 ;
                                 ; IN PINx
                                 ; OUT PORTx
                                 ; OUT PINx turns on pullup						
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
                                 
                                 			
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Equates
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PortE bits
                                 			.equ intbit = PE0
                                 			.equ webit = PE1
                                 			.equ rdybit = PE2
                                 			
                                 ; Dedicated registers			
                                 ; INT2:	XL XH r13 r14 r15			
                                 ; SD error count: r10			
                                 ; Save arg: r6-r9
                                 ;			
                                 		
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.DSEG
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ;FDC variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 fdcRegisters:
000100                           fdcStatus:	.byte 1			;TI 5FF0 Read Status
000101                           fdcTrack:	.byte 1			;TI 5FF2/5FFA Rd/Wr Track Register
000102                           fdcSector:	.byte 1			;TI 5FF4/5FFC Rd/Wr Sector Register
000103                           fdcData:	.byte 1			;TI 5FF6/5FFE Rd/Wr Data Register
000104                           fdcCommand:	.byte 1			;TI 5FF8 Write Command Register
000105                           fdcSide:	.byte 1			;	
                                 
000106                           flags:		.byte 1			;flags + address
                                 			.equ iflag = 7	;1 int occured
                                 			.equ wflag = 2	;1 write occured
000107                           DSK0volume:	.byte	0			
000107                           DSK0address:	.byte	4	;LSB -- MSB
00010b                           DSK1address:	.byte	4	;LSB -- MSB			
00010f                           DSK2address:	.byte	4	;LSB -- MSB
000113                           DSK3address:	.byte	4	;LSB -- MSB
000117                           DSK0LastTrk:	.byte	1
000118                           DSK1LastTrk:	.byte	1
000119                           DSK2LastTrk:	.byte	1
00011a                           DSK3LastTrk:	.byte	1
00011b                           TIlowbyte:	.byte	1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ;SD variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 		.equ CS = PB4
00011c                           ocr:		.byte	1
                                 		.equ ccs = 6	;bit 6
00011d                           cmd:		.byte	1
00011e                           arg:		.byte	4	;LSB -- MSB		
000122                           crc:		.byte	1
000123                           resp:		.byte	1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Disk variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 SectorsPerCluster:		;in Powers of 2 (Number of left shifts to use)
000124                           		.byte	1
000125                           Offset:		.byte	4	;LSB -- MSB	
000129                           StartSector:	.byte	2
00012b                           StepSectors:	.byte	2
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Serial interrupt variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
00012d                           SerWrPtr:	.byte	1
00012e                           SerRdPtr:	.byte	1
00012f                           SerCnt:		.byte	1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; XMODEM variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.equ SOH = 1
                                 	.equ EOT = 4
                                 	.equ CAN = 24
                                 	.equ NAK = 21
                                 	.equ ACK = 6
                                 	.equ CR = 13
000130                           PAKNUM:	.byte 2		;16 bit packet# (LSByte - MSByte)
000132                           CHKSUM:	.byte 1
000133                           CRCFLG:	.byte 1
000134                           TELFLG:	.byte 1
                                 ;CRC r1:r0		;also uses r2
                                 	
                                 VAR_END:	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Buffers
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 		.equ Serbuffsize = 160
000135                           Serbuffer:	.byte	Serbuffsize
0001d5                           TIbuffer:	.byte	256
0002d5                           SDbuffer:	.byte	512
                                 	
                                 ;Stack area	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Interrupts vector tables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 	.CSEG		;8515 use rjmp 162 use jmp
                                 	.org $000
000000 940c 00e6                 	jmp setup	;Reset Handler
                                 	.org URXC0addr	;8515 URXCaddr,162 URXC0addr
000026 940c 0054                 	jmp USART_RXC	;USART RX Complete Handler  
                                 	.org INT2addr
000006 940c 0038                 	jmp EXT_INT2	;IRQ2 Handler
                                 	
                                 
                                 ;Interrupt Service Routines
                                 	.org INT_VECTORS_SIZE		;End of Int vector table
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; IRQ2 Interrupt Handler
                                 ; XH XL r13 r14 r15 not saved
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; cycle = 62.5ns
                                 EXT_INT2:
000038 b6df                          	in r13,SREG			;Save SREG			1
000039 2ee0                      	mov r14,r16			;				1
00003a b306                      	in r16,PinB			;Get FDC address		1
00003b 7003                      	andi r16,0x03			;				1
00003c 24ff                      	clr r15				;				1								
00003d e0b1                      	ldi XH,high(fdcRegisters)	;Point X to FDC_Registers base	1
00003e e0a0                      	ldi XL,low(fdcRegisters)	; "				1
00003f 0fa0                      	add XL,r16			;add FDC address offset		1
000040 1dbf                      	adc XH,r15			; "				1
000041 90fc                      	ld r15,X			;Get data in FDC register	2
000042 bafb                      	out PortA,r15			;Send it to TI			1
000043 6800                      	sbr r16,1<<iflag		;Set our interrupt flag		1
000044 0000                      	nop				;				1
000045 0000                      	nop				;				1
                                  ;Need 13-19 cycles to here,Min 15 without errors			15
                                 	
000046 9929                      	sbic PinE,webit		;Test !we
000047 c007                      	rjmp isr2end			;Read if 1
000048 b2f3                      	in r15,PinC			;Get  write data
000049 94f0                      	com r15				;TI sends inverted data
00004a 6004                      	sbr r16,1<<wflag		;Set write flag
00004b 3804                      	cpi r16,0x84			;Check If Command
00004c f409                      	brne NotCMD			; "
00004d 9614                      	adiw X,4			;Point to Command registers
                                 NotCMD:	
00004e 92fc                      	st X,r15			;Write data to FDC register
                                 isr2end:
00004f 9300 0106                 	sts flags,r16			;
000051 2d0e                      	mov r16,r14			;
000052 bedf                      	out SREG,r13			;Restore SREG	
000053 9518                      	reti
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; USART RX Complete Interrupt Handler	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 USART_RXC:
000054 930f                      	push r16
000055 b70f                      	in r16,SREG	;Push SREG
000056 930f                      	push r16	; "
000057 93ff                      	push ZH
000058 93ef                      	push ZL
                                 	
                                 ;Move Stat & Char to buffer
000059 9100 012f                 	lds r16,SerCnt
00005b 9503                      	inc r16
00005c 9300 012f                 	sts SerCnt,r16
                                 
00005e e0f1                      	ldi ZH,high(Serbuffer)
00005f e3e5                      	ldi ZL,low(Serbuffer)
000060 9100 012d                 	lds r16,SerWrPtr
000062 0fe0                      	add ZL,r16		;
                                 ;	clr r17
                                 ;	adc ZH,r17
                                 	
000063 9503                      	inc r16
000064 3a00                      	cpi r16,Serbuffsize		;
000065 f409                      	brne jp00
000066 2700                      	clr r16
000067 9300 012d                 jp00:	sts SerWrPtr,r16
                                 
                                 ;	in r16,UCSR0A		;Get status
                                 ;	st Z+,r16		;Put in buffer
000069 b10c                      	in r16,UDR		;Get data (We know data is there because of Recv interrupt)
00006a 8300                      	st Z,r16		;Put in buffer
                                 	
                                 ;Check If AT+#xCRLF is in buffer (x is Char used below)
00006b 300a                      	cpi r16,10	;check if LF
00006c f469                      	brne jp09
                                 	
00006d 9102                      	ld r16,-Z
00006e 300d                      	cpi r16,13	;check if CR
00006f f451                      	brne jp09
                                 
000070 9734                      	sbiw Z,4
000071 9101                      	ld r16,Z+
000072 3401                      	cpi r16,'A'	;
000073 f431                      	brne jp09
                                 
000074 9101                      	ld r16,Z+
000075 3504                      	cpi r16,'T'	;	
000076 f419                      	brne jp09
                                 
000077 9101                      	ld r16,Z+
000078 3203                      	cpi r16,'#'	;
000079 f011                      	breq jp08
00007a 940c 00ca                 jp09:	jmp RXCrtn
                                  
00007c 8100                      jp08:	ld r16,Z	; 
                                 
00007d 93df                      	push YH
00007e 93cf                      	push YL
00007f 93bf                      	push XH
000080 93af                      	push XL
000081 939f                      	push r25
000082 938f                      	push r24
000083 937f                      	push r23
000084 936f                      	push r22
000085 935f                      	push r21
000086 934f                      	push r20
000087 933f                      	push r19
000088 932f                      	push r18
000089 931f                      	push r17
                                 	
00008a 3502                      chkR:	cpi r16,'R'		    ;Send reg 16-31,SREG,Ret PC
00008b f429                      	brne chkS
00008c b7fe                      	in ZH,SPH
00008d b7ed                      	in ZL,SPL
00008e 9631                      	adiw Z,1
00008f e113                      	ldi r17,19
000090 c026                      	rjmp TXLP0
                                 	
000091 3503                      chkS:	cpi r16,'S'		    ;Send all calls on stack
000092 f439                      	brne chkB
000093 b7fe                      	in ZH,SPH
000094 b7ed                      	in ZL,SPL
000095 9671                      	adiw Z,17
000096 ef1f                      	ldi r17,low(RAMEND)
000097 1b1e                      	sub r17,ZL
000098 9631                      	adiw Z,1
000099 c01d                      	rjmp TXLP0
                                 	
00009a 3402                      chkB:	cpi r16,'B'		    ;Send Serial buffer
00009b f421                      	brne chkT
00009c ea10                      	ldi r17,Serbuffsize
00009d e0f1                      	ldi ZH,high(Serbuffer)	    ; Get address to Serial buffer
00009e e3e5                      	ldi ZL,low(Serbuffer)	    ; "
00009f c017                      	rjmp TXLP0
                                 	
0000a0 3504                      chkT:	cpi r16,'T'		    ;Send TIbuffer
0000a1 f421                      	brne chkU
0000a2 2711                      	clr r17
0000a3 e0f1                      	ldi ZH,high(TIbuffer)	    ;Point to TIbuffer
0000a4 ede5                      	ldi ZL,low(TIbuffer)	    ; "
0000a5 c011                      	rjmp TXLP0
                                 	
0000a6 3505                      chkU: 	cpi r16,'U'		    ;Send upper 256 bytes of SDbuffer
0000a7 f421                      	brne chkL
0000a8 2711                      	clr r17
0000a9 e0f2                      	ldi ZH,high(SDbuffer)	    ;Point to SDbuffer
0000aa ede5                      	ldi ZL,low(SDbuffer)	    ; "
0000ab c00b                      	rjmp TXLP0
                                 	
0000ac 340c                      chkL: 	cpi r16,'L'		    ;Send lower 256 bytes of SDbuffer
0000ad f421                      	brne chkV
0000ae 2711                      	clr r17
0000af e0f3                      	ldi ZH,high(SDbuffer+128)   ;Point to lower SDbuffer
0000b0 e5e5                      	ldi ZL,low(SDbuffer+128)    ; "
0000b1 c005                      	rjmp TXLP0
                                 	
0000b2 3506                      chkV: 	cpi r16,'V'	;Send all sram (variables) except buffers
0000b3 f449                      	brne jp13
0000b4 e315                      	ldi r17,VAR_END-SRAM_START  ;Count between fdcRegisters & buffers
0000b5 e0f1                      	ldi ZH,high(SRAM_START)	    ; Get sram start address
0000b6 e0e0                      	ldi ZL,low(SRAM_START)	    ; "
                                 	
0000b7 9101                      TXLP0:	ld r16,Z+
0000b8 9b5d                      lp08:	sbis UCSR0A,UDRE	;Wait until transmit is ready
0000b9 cffe                      	rjmp lp08
0000ba b90c                      	out UDR,r16		;Send data
0000bb 951a                      	dec R17
0000bc f7d1                      	brne TXLP0
                                 	
0000bd 911f                      jp13:	pop r17
0000be 912f                      	pop r18
0000bf 913f                      	pop r19
0000c0 914f                      	pop r20
0000c1 915f                      	pop r21
0000c2 916f                      	pop r22
0000c3 917f                      	pop r23
0000c4 918f                      	pop r24
0000c5 919f                      	pop r25
0000c6 91af                      	pop XL
0000c7 91bf                      	pop XH
0000c8 91cf                      	pop YL
0000c9 91df                      	pop YH
                                 	
0000ca 91ef                      RXCrtn:	pop ZL
0000cb 91ff                      	pop ZH
0000cc 910f                      	pop r16		;pop SREG
0000cd bf0f                       	out SREG,r16	; "
0000ce 910f                      	pop r16
0000cf 9518                        	reti
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Constants
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Use to access program memory	
                                 ; ldi ZH,high(hello<<1)	;Shift (address*2) because program memory is 16 bits
                                 ; ldi ZL,low(hello<<1)	;When address bit0 is 0 low byte of word is accessed
                                 ; lpm r16,Z+		;When address bit0 is 1 high byte of word is accessed
                                 ;			;Effectively changing to byte access
                                 ;hello:
                                 ;	.db "HELLO",0
0000d0 76eb
0000d1 4590
0000d2 4658
0000d3 5441
0000d4 00ff                      EXFATstr: .db 0xEB,0x76,0x90,"EXFAT",0xFF,0 ;make even bytes
0000d5 00c1
0000d6 0056
0000d7 004f
0000d8 004c
0000d9 0055
0000da 004d
0000db 0045
0000dc ff53                      VOLstr:	.db 0xC1,0,'V',0,'O',0,'L',0,'U',0,'M',0,'E',0,'S',0xFF
0000dd 00c1
0000de 0054
0000df 0049
0000e0 0056
0000e1 004f
0000e2 004c
0000e3 0030
0000e4 0030
0000e5 ff30                      TIVOLstr: .db 0xC1,0,'T',0,'I',0,'V',0,'O',0,'L',0,'0',0,'0',0,'0',0xFF
                                  
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Setup
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 setup:
0000e6 ef0f                      	ldi r16,low(RAMEND)		;Init stack
0000e7 bf0d                      	out spl,r16			;	"
0000e8 e004                      	ldi r16,high(RAMEND)		;	"
0000e9 bf0e                      	out sph,r16			;	"
                                 ;Setup ports
0000ea ef0f                      	ser	r16			;PortA (FF) output mode for TI read
0000eb bb0a                      	out DDRA,r16			; "
0000ec 2700                      	clr	r16			;PortC (00) input mode for TI write
0000ed bb04                      	out DDRC,r16			; "
0000ee eb00                      	ldi	r16,0b10110000		;SCK,MI,MO,CS,0,0,A1,A0
0000ef bb07                      	out DDRB,r16			;O  ,I ,O ,O ,I,I,I ,I
0000f0 9ac6                      	sbi PortB,PB6			;Pullup MISO
0000f1 e00a                      	ldi	r16,0b00001010		;Side,DR3,DR2,DR1,HLD,0,TDX,RXD
0000f2 bb01                      	out DDRD,r16			;I   ,I  ,I  ,I  ,O  ,I,O  ,I
0000f3 e004                      	ldi	r16,0b00000100		;0,0,0,0,0,!Ready,!WE,!INT
0000f4 b906                      	out DDRE,r16			;I,I,I,I,I,O     ,I  ,I
                                 	
0000f5 e800                      	ldi r16,0x80			;Set TI to read status NotReady 
0000f6 bb0b                      	out PortA,r16			;Until Int2 enabled	
0000f7 983a                      	cbi PortE,rdybit		;Enable TI hardwire
                                 
0000f8 b706                      	in r16,EMCUCR			;Set INT2 falling edge trigger
0000f9 7f0e                      	cbr r16,1<<ISC2		; " ISC2=bit0 same as andi r16,0xFE
0000fa bf06                      	out EMCUCR,r16			; "
0000fb b70b                      	in r16,GICR			;Enable INT2
0000fc 6200                      	sbr r16,1<<INT2		; " INT2=bit5 same as ori r16,32
0000fd bf0b                      	out GICR,r16			; "	
                                 ;Set status				;NotReady  track0  busy
0000fe e004                      	ldi r16,0x04			;b7=0      b2=1    b0=0
0000ff 9300 0100                 	sts fdcStatus,r16		;
000101 2700                      	clr r16				; 
000102 9300 0101                 	sts fdcTrack,r16		;
000104 9300 0102                 	sts fdcSector,r16		;
000106 9300 0103                 	sts fdcData,r16		;
000108 9300 0104                 	sts fdcCommand,r16		;
00010a 9893                      	cbi PortD,3			;data not ready
                                 ;Setup USART				;baud @ 16MHz
00010b e010                      	ldi r17,0			;230.4k=0,3 115.2k=0,8(double 8&16)
00010c e008                      	ldi r16,8			;Disabled doubling
00010d d201                      	rcall USARTInit	
00010e b10a                      	in r16,UCSR0B			;Enable RXC interrupt
00010f 6800                      	sbr r16,1<<RXCIE		; "
000110 b90a                      	out UCSR0B,r16			; "	
                                 ;Setup SPI
000111 e100                      	ldi r16,16
000112 2ea0                      	mov r10,r16			;SD error count,So it doesn't run away
000113 d25a                      	rcall SPIInit  
000114 d332                      	rcall MMCInit
                                 ;Setup Drives	
                                 SetupStartStep:  
000115 d265                      	rcall FindTIVOL		;Find TIVOL000,Save Start and Step
000116 f031                      	breq SetupDSK
000117 e800                      	ldi r16,0x80		;disk error,not ready
000118 9300 0100                 	sts fdcStatus,r16	;
                                 ;Get DSKx addresses from SD sector 1    
                                 SetupDSK0:
00011a ef0f                      	ldi r16,255		;DSK0 use default volume 255
00011b 9300 0107                 	sts DSK0volume,r16
                                 SetupDSK:
00011d e001                      	ldi r16,0x01
00011e 9300 011e                 	sts arg,r16		; (LSB) sector 00 00 00 01
000120 2700                       	clr r16
000121 9300 011f                 	sts arg+1,r16
000123 9300 0120                 	sts arg+2,r16
000125 9300 0121                 	sts arg+3,r16		; (MSB)
000127 d41e                      	rcall ReadMMC           ; First half 512 sector (uses ZL & ZH)
                                 	
                                 ;XL & XH ok to use before interrupts are enabled    	
000128 ede6                      	ldi ZL,low(SDbuffer+1)	    ;+1 skip DSK0
000129 e0f2                      	ldi ZH,high(SDbuffer+1)	    ;
                                 
00012a 9100 0107                 	lds r16,DSK0volume	    ;Get Drive 0 Disk #
00012c 930f                      	push r16		    ;DSK0 not saved in sector 1
00012d 9101                      	ld r16,Z+		    ;Get Drive 1 Disk #
00012e 930f                      	push r16		    ;		    
00012f 9101                      	ld r16,Z+		    ;Get Drive 2 Disk #
000130 930f                      	push r16		    ;
000131 9101                      	ld r16,Z+		    ;Get Drive 3 Disk #
000132 930f                      	push r16
                                 	
000133 e1c3                      	ldi YL,low(DSK3address)    ;
000134 e0d1                      	ldi YH,high(DSK3address)   ;
                                 	
000135 e024                      	ldi r18,4
000136 915f                      lp02:	pop r21			    ;Restore disk number (stepping 3 - 0)
000137 d1b9                      	rcall Disk2Sector	    ;Convert disk # to sector address
000138 9209                      	st Y+,r0		    ;Save into DSKXaddress
000139 9219                      	st Y+,r1		    ;
00013a 9229                      	st Y+,r2		    ;
00013b 9239                      	st Y+,r3		    ;
00013c 9728                      	sbiw Y,8		    ;Back to start of current drive + start preceding drive
00013d 952a                      	dec r18			    ;
00013e f7b9                      	brne lp02		    ;All 3 drives done 
                                 	
                                 ;Set last track for drives
00013f e0e7                      	ldi ZL,low(DSK0address)    ;LSB -- MSB
000140 e0f1                      	ldi ZH,high(DSK0address)   ;
000141 e1ce                      	ldi YL,low(arg)	    ;
000142 e0d1                      	ldi YH,high(arg)	    ;
000143 d47e                      	rcall mov4		    ;
000144 d401                      	rcall ReadMMC 		    ;First half 512 sector (uses ZL & ZH)
000145 e207                      	ldi r16,39
000146 9110 02df                 	lds r17,SDbuffer+10
000148 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000149 e40f                      	ldi r16,79
00014a 9300 0117                 	sts DSK0LastTrk,r16
                                 	
00014c e0eb                      	ldi ZL,low(DSK1address)    ;LSB -- MSB
00014d e0f1                      	ldi ZH,high(DSK1address)   ;
00014e e1ce                      	ldi YL,low(arg)	    ;
00014f e0d1                      	ldi YH,high(arg)	    ;
000150 d471                      	rcall mov4		    ;
000151 d3f4                      	rcall ReadMMC 		    ;First half 512 sector (uses ZL & ZH)
000152 e207                      	ldi r16,39
000153 9110 02df                 	lds r17,SDbuffer+10
000155 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000156 e40f                      	ldi r16,79
000157 9300 0118                 	sts DSK1LastTrk,r16
                                 	
000159 e0ef                      	ldi ZL,low(DSK2address)    ;LSB -- MSB
00015a e0f1                      	ldi ZH,high(DSK2address)   ;
00015b e1ce                      	ldi YL,low(arg)	    ;
00015c e0d1                      	ldi YH,high(arg)	    ;
00015d d464                      	rcall mov4		    ;
00015e d3e7                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
00015f e207                      	ldi r16,39
000160 9110 02df                 	lds r17,SDbuffer+10
000162 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000163 e40f                      	ldi r16,79
000164 9300 0119                 	sts DSK2LastTrk,r16
                                 	
000166 e1e3                      	ldi ZL,low(DSK3address)    ;LSB -- MSB
000167 e0f1                      	ldi ZH,high(DSK3address)   ;
000168 e1ce                      	ldi YL,low(arg)	    ;
000169 e0d1                      	ldi YH,high(arg)	    ;
00016a d457                      	rcall mov4		    ;
00016b d3da                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
00016c e207                      	ldi r16,39
00016d 9110 02df                 	lds r17,SDbuffer+10
00016f fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000170 e40f                      	ldi r16,79
000171 9300 011a                 	sts DSK3LastTrk,r16
                                 	
                                 ;Enable interrupts	
000173 2700                      	clr r16				;Clear flags
000174 9300 0106                 	sts flags,r16			;
000176 9300 012e                 	sts SerRdPtr,r16		;Init Serial pointers
000178 9300 012d                 	sts SerWrPtr,r16
00017a 9300 012f                 	sts SerCnt,r16
00017c 9478                      	sei				;Global enable interrupts
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Main Loop
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00017d 2700                      main:	clr r16			    ; Clear busy,No errors	
00017e 9300 0100                 jp02:	sts fdcStatus,r16	    ; "	     
000180 983a                      	cbi PortE,2		    ;Release TI
                                 	
000181 9100 0106                 lp00:	lds r16,flags		    ;Get flags
000183 ff07                      	sbrs r16,iflag		    ;Has TI has sent data?
000184 cffc                      	rjmp lp00
000185 2711                      	clr r17			    ;Clear flags
000186 9310 0106                 	sts flags,r17		    ; "		    
                                 	
000188 9100 0104                 	lds r16,fdcCommand	    ;
00018a 3000                      	cpi r16,0x00		    ;
00018b f3a9                      	breq lp00
                                 	
00018c 9a3a                      	sbi PortE,2		    ;Put TI on hold while process command
00018d 9310 0104                 	sts fdcCommand,r17	    ;Clear command (r17=0 from above)
                                 ;	ldi r17,0x01		    ;Set Busy bit
                                 ;	sts fdcStatus,r17	    ; "
                                 	
                                 ;	rcall USARTWrite	    ;Send command in r16 (enable for debbuging)
                                 	
                                 ;Our Mount Disk command	
                                 fdcCMD81:			    	
00018f 3801                      	cpi r16,0x81		   
000190 f411                      	brne fdcCMD82
000191 d13e                      	rcall ChgDisk
000192 cf8a                      	rjmp SetupDSK		    ;Setup disk addresses and last track
                                 ;Our Send all disk names command		
                                 fdcCMD82:			    
000193 3802                      	cpi r16,0x82		    
000194 f411                      	brne usartCMD83
000195 d113                      	rcall SendNames
000196 cfe6                      	rjmp main
                                 ;Read Usart status
                                 usartCMD83:			    
000197 3803                      	cpi r16,0x83		    
000198 f411                      	brne usartCMD84
000199 d188                      	rcall TIrdUsartStat
00019a cfe2                      	rjmp main
                                 ;Read Usart data
                                 usartCMD84:			    
00019b 3804                      	cpi r16,0x84		    
00019c f411                      	brne usartCMD85
00019d d192                      	rcall TIrdUsartData
00019e cfde                      	rjmp main
                                 ;Write Usart data
                                 usartCMD85:			    
00019f 3805                      	cpi r16,0x85		    
0001a0 f411                      	brne usartCMD86
0001a1 d1aa                      	rcall TIwrUsartData
0001a2 cfda                      	rjmp main
                                 ;Usart Sub Command
                                 usartCMD86:			    
0001a3 3806                      	cpi r16,0x86		    
0001a4 f411                      	brne xmdCMD87
0001a5 d1ac                      	rcall TIwrUsartSub
0001a6 cfd6                      	rjmp main
                                 ;Xmodem Volume Transfer
                                 xmdCMD87:			    
0001a7 3807                      	cpi r16,0x87		    
0001a8 f411                      	brne fdcCMD0A
0001a9 d449                      	rcall XMODEM
0001aa cfd2                      	rjmp main	
                                 ;0A Restore (h=1,V=0,r0r1=10)	
                                 fdcCMD0A:			   
0001ab 300a                      	cpi r16,0x0A		    ;
0001ac f439                      	brne fdcCMD1E
0001ad 2700                      	clr r16			    ;
0001ae 9300 0101                 	sts fdcTrack,r16	    ;Set to track 0
0001b0 9300 0102                 	sts fdcSector,r16	    ;Set to sector 0
0001b2 6004                      	sbr r16,0x04		    ;Set track 0 in status
0001b3 cfca                      	rjmp jp02
                                 ;1E Seek h=1 V=1 r1r0=10
                                 fdcCMD1E:			    
0001b4 310e                      	cpi r16,0x1E		    ;
0001b5 f429                      	brne fdcCMD5A
0001b6 9100 0103                 	lds r16,fdcData
0001b8 9300 0101                 	sts fdcTrack,r16
0001ba cfc2                      	rjmp main
                                 ;2x Step not used by TI
                                 ;5A Step-in T=1,h=1,V=0,r0r1=10	
                                 fdcCMD5A:			    
0001bb 350a                      	cpi r16,0x5A		    ;
0001bc f431                      	brne fdcCMD88
0001bd 9100 0101                 	lds r16,fdcTrack
0001bf 9503                      	inc r16
0001c0 9300 0101                 	sts fdcTrack,r16
0001c2 cfba                      	rjmp main
                                 ;6x Step-out not used by TI
                                 ;88 Read sector m=0 S=1 E=0 C=0		    
                                 fdcCMD88:			    
0001c3 3808                         	cpi r16,0x88		    ;
0001c4 f411                      	brne fdcCMDA8
0001c5 d042                      	rcall TIreadsec
0001c6 cfb6                      	rjmp main
                                 ;A8 Write sector m=0 S=1 E=0 C=0 a=0
                                 fdcCMDA8:			    
0001c7 3a08                      	cpi r16,0xA8		    ;
0001c8 f411                      	brne fdcCMDC0
0001c9 d02b                      	rcall TIwritesec
0001ca cfb2                      mainRLY: rjmp main
                                 ;C0 Read ID E=0
                                 fdcCMDC0:			    
0001cb 3c00                      	cpi r16,0xC0		    ;
0001cc f411                      	brne fdcCMDF4
0001cd d009                      	rcall TIreadID
0001ce cfae                      	rjmp main
                                 ;Ex Read track not used by TI
                                 ;F4 Write track (E=1)
                                 fdcCMDF4:			    
0001cf 3f04                          	cpi r16,0xF4		    ;
0001d0 f411                      	brne fdcCMDD0
0001d1 d0b1                      	rcall TIwritetrack
0001d2 cff7                      	rjmp mainRLY
                                 ;D0 Force interrupt
                                 fdcCMDD0:			    
0001d3 3d00                          	cpi r16,0xD0		    ;Sent after software reset (FTCN =)
0001d4 f7a9                      	brne mainRLY
0001d5 d3a4                      	rcall delay1ms
0001d6 cf46                      	rjmp SetupDSK		    ;Setup disks in case one was formatted
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadID:
0001d7 983a                      	cbi PortE,2		;Release TI
0001d8 9100 0101                 	lds r16,fdcTrack	;Get track
0001da 9300 0103                 	sts fdcData,r16		;Send to TI
0001dc d077                      	rcall WaitTIread	; "
0001dd 2700                      	clr r16			;Side 0
0001de 9987                      	sbic PinD,7		;Get Side
0001df 9503                      	inc r16			;Side 1
0001e0 9300 0103                 	sts fdcData,r16		;Send to TI
0001e2 d071                      	rcall WaitTIread	; "
0001e3 9100 0102                 	lds r16,fdcSector	;Get sector
0001e5 9300 0103                 	sts fdcData,r16		;Send to TI
0001e7 d06c                      	rcall WaitTIread	; "
0001e8 2700                      	clr r16			;Sector lenght code?
0001e9 9300 0103                 	sts fdcData,r16		;Send to TI
0001eb d068                      	rcall WaitTIread	; "
0001ec 2700                      	clr r16			;CRC byte1
0001ed 9300 0103                 	sts fdcData,r16		;Send to TI
0001ef d064                      	rcall WaitTIread	; "
0001f0 2700                      	clr r16			;CRC byte2
0001f1 9300 0103                 	sts fdcData,r16		;Send to TI
0001f3 d060                      	rcall WaitTIread	; "
0001f4 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritesec:
0001f5 e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
0001f6 ede5                      	ldi ZL,low(TIbuffer)	; "
0001f7 e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001f8 983a                      	cbi PortE,2		;Release TI
0001f9 d064                      lp24:	rcall WaitTIwrite	;Wait for data from TI
0001fa 9100 0103                 	lds r16,fdcData	;Get next byte
0001fc 9301                      	st Z+,r16		;Save to buffer
0001fd 952a                      	dec r18
0001fe f7d1                      	brne lp24
                                 	
0001ff 9a3a                      	sbi PortE,2		;Put TI on hold while process command
000200 e001                      	ldi r16,1
000201 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
000202 2700                      	clr r16
000203 9300 0105                 	sts fdcSide,r16
000205 d014                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
000206 d070                      	rcall TI_SD_wr		;Write to SD
000207 9508                      	ret	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadsec:
000208 e001                      	ldi r16,1
000209 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
00020a 2700                      	clr r16
00020b 9300 0105                 	sts fdcSide,r16
00020d d00c                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
00020e d059                      	rcall TI_SD_rd		;Get sector from SD
00020f e0f1                      	ldi ZH,high(TIbuffer)	; Get address to buffer
000210 ede5                      	ldi ZL,low(TIbuffer)	; "
000211 e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
000212 983a                      	cbi PortE,2		;Release TI
000213 9101                      lp13:	ld r16,Z+		;Get next byte
000214 9300 0103                 	sts fdcData,r16		;Send to TI
000216 d03d                      	rcall WaitTIread	; "
000217 952a                      	dec r18
000218 f7d1                      	brne lp13
000219 9508                      	ret
                                 ;	
                                 ;Convert TI track&sector to SD sector	
                                 Track2Arg:
00021a 9100 0101                 	lds r16,fdcTrack
00021c 9110 0105                 	lds r17,fdcSide
00021e ff10                      	sbrs r17,0		;Test bit,Skip if side 1	
00021f c00f                      	rjmp jp10
000220 9110 0117                 	lds r17,DSK0LastTrk	;Drive 0 If below drives are skipped
000222 9984                      	sbic PinD,4		;Skip If not drive 1
000223 9110 0118                 	lds r17,DSK1LastTrk	;
000225 9985                      	sbic PinD,5		;Skip If not drive 2
000226 9110 0119                 	lds r17,DSK2LastTrk	;
000228 9986                      	sbic PinD,6		;Skip If not drive 3
000229 9110 011a                 	lds r17,DSK3LastTrk	;
00022b 1b01                      	sub r16,R17		;Reverse track (0=-39 or -79) 
00022c 9501                      	neg r16			;Make postive
00022d 9513                      	inc r17			;
00022e 0f01                      	add r16,r17		;Track + 40 or 80
                                 jp10:	
00022f e019                      	ldi r17,9		;Track*9
000230 9f01                      	mul r16,r17		;Result in r0 r1
000231 2711                      	clr r17			;Add sector offset 0-8		
000232 9100 0102                 	lds r16,fdcSector	; "
000234 0e00                      	add r0,r16		; "
000235 1e11                      	adc r1,r17		; "
                                 	
                                 	;Divide TI sector by 2 to put in upper or lower half of SD sector
000236 9200 011b                 	sts TIlowbyte,r0 	;save low byte for bit 0 test
000238 9416                      	lsr r1			;Divide 16 bits by 2
000239 9407                      	ror r0			; "	"	"
                                 	
                                 	;Add TI sector to DSKx SD start sector address and place in ARG
00023a e0f1                      	ldi ZH,high(DSK0address)    ;Start DSK0address
00023b e0e7                      	ldi ZL,low(DSK0address)	    ; "
00023c 9984                      	sbic PinD,4		    ;Skip If not drive 1
00023d 9634                      	adiw Z,4		    ;DSK1address
00023e 9985                      	sbic PinD,5		    ;Skip If not drive 2
00023f 9638                      	adiw Z,8		    ;DSK2address
000240 9986                      	sbic PinD,6		    ;Skip If not drive 3
000241 963c                      	adiw Z,12		    ;DSK3address
                                 
000242 9101                      	ld r16,Z+
000243 0d00                      	add r16,r0
000244 9300 011e                 	sts arg,r16
000246 9101                      	ld r16,Z+
000247 1d01                      	adc r16,r1
000248 9300 011f                 	sts arg+1,r16
00024a 2400                      	clr r0			;carry not affected
00024b 9101                      	ld r16,Z+
00024c 1d00                      	adc r16,r0
00024d 9300 0120                 	sts arg+2,r16
00024f 8100                      	ld r16,Z
000250 1d00                      	adc r16,r0
000251 9300 0121                 	sts arg+3,r16
000253 9508                      	ret
                                 ;	
                                 WaitTIread:
000254 9100 0106                 	lds r16,flags		;Get flags
000256 ff07                      	sbrs r16,iflag		;Has TI read data?
000257 cffc                      	rjmp WaitTIread
000258 2711                      	clr r17			;Clear interrupt flag
000259 9310 0106                 	sts flags,r17		; "
00025b 3803                      	cpi r16,0x83		;Was it read data register
00025c f7b9                      	brne WaitTIread
00025d 9508                      	ret
                                 WaitTIwrite:
00025e 9100 0106                 	lds r16,flags		;Get flags
000260 ff07                      	sbrs r16,iflag		;Has TI written data?
000261 cffc                      	rjmp WaitTIwrite
000262 2711                      	clr r17			;Clear interrupt flag
000263 9310 0106                 	sts flags,r17		; "
000265 3807                      	cpi r16,0x87		;Was it write data register
000266 f7b9                      	brne WaitTIwrite
000267 9508                      	ret
                                 	
                                 TI_SD_rd:
000268 d2dd                      	rcall readmmc		;512 bytes in sdbuffer
000269 ede5                      	ldi ZL,low(SDbuffer)
00026a e0f2                      	ldi ZH,high(SDbuffer)
00026b 9100 011b                 	lds r16,TIlowbyte
00026d fd00                      	sbrc r16,0
00026e 95f3                      	inc ZH			;Add 256 to Z
00026f edc5                      	ldi YL,low(TIbuffer)
000270 e0d1                      	ldi YH,high(TIbuffer)
                                 ;Move 256 bytes from source(Z) to destination(Y)
000271 2700                      mov256:	clr r16		
000272 9111                      lp03:	ld r17,Z+ 
000273 9319                      	st Y+,r17
000274 950a                      	dec r16
000275 f7e1                      	brne lp03
000276 9508                      	ret	;and send to TI
                                 TI_SD_wr:
000277 d2ce                      	rcall readmmc	//512 bytes in sdbuffer
000278 ede5                      	ldi ZL,low(TIbuffer)
000279 e0f1                      	ldi ZH,high(TIbuffer)
00027a edc5                      	ldi YL,low(SDbuffer)
00027b e0d2                      	ldi YH,high(SDbuffer)
00027c 9100 011b                 	lds r16,TIlowbyte
00027e fd00                      	sbrc r16,0
00027f 95d3                      	inc YH			;Add 256 to Y
000280 dff0                      	rcall mov256
000281 d291                      	rcall writemmc	//512 bytes in sdbuffer
000282 9508                      	ret	
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritetrack:
000283 e049                      	ldi r20,9
                                 lp25:	
000284 983a                      	cbi PortE,2		;Release TI
                                 	
                                 ;Get (FE,Track,Side,Sector,1?,F7)	
                                 lp26:	
000285 dfd8                      	rcall WaitTIwrite	;Wait for data from TI
000286 9100 0103                 	lds r16,fdcData		;Get next byte
000288 3f0e                      	cpi r16,0xFE
000289 f7d9                      	brne lp26
                                 	
00028a dfd3                      	rcall WaitTIwrite	;Throw away Track,already loaded
                                 
00028b dfd2                      	rcall WaitTIwrite	;Wait for data from TI
00028c 9100 0103                 	lds r16,fdcData	
                                 ;	ror r16			;Move bit0 to bit7
                                 ;	ror r16			; "
00028e 9300 0105                 	sts fdcSide,r16		;Save Side
                                 	
000290 dfcd                      	rcall WaitTIwrite	;Wait for data from TI
000291 9100 0103                 	lds r16,fdcData	
000293 9300 0102                 	sts fdcSector,r16	;Save Sector
                                 
                                 ;Get (FB,256 bytes E5,F7)	
                                 lp27:	
000295 dfc8                      	rcall WaitTIwrite	;Wait for data from TI
000296 9100 0103                 	lds r16,fdcData		;Get next byte
000298 3f0b                      	cpi r16,0xFB
000299 f7d9                      	brne lp27
                                 	
00029a e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
00029b ede5                      	ldi ZL,low(TIbuffer)	; "
00029c e020                      	ldi r18,0x00		;256 bytes per sector
                                 lp28:	
00029d dfc0                      	rcall WaitTIwrite	;Wait for data from TI
00029e 9100 0103                 	lds r16,fdcData	;Get next byte
0002a0 9301                      	st Z+,r16		;Save to buffer
0002a1 952a                      	dec r18
0002a2 f7d1                      	brne lp28
                                 	
0002a3 9a3a                      	sbi PortE,2		;Put TI on hold while process command
0002a4 df75                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0002a5 dfd1                      	rcall TI_SD_wr		;Write to SD
                                 	
0002a6 954a                      	dec r20			;All 9 sectors done?
0002a7 f6e1                      	brne lp25      
0002a8 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;All disks names 0-255 sent to TI
                                 ; ENTRY:
                                 ;
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 SendNames:
                                 ;Send disk numbers DSK1-3 
0002a9 e001                      	ldi r16,0x01
0002aa 9300 011e                 	sts arg,r16		; (LSB) sector 00 00 00 01
0002ac 2700                       	clr r16
0002ad 9300 011f                 	sts arg+1,r16
0002af 9300 0120                 	sts arg+2,r16
0002b1 9300 0121                 	sts arg+3,r16		; (MSB)
0002b3 d292                      	rcall ReadMMC           ; Read sector 1
0002b4 e0f2                      	ldi ZH,high(SDbuffer+1)	; Point to disk #s in buffer
0002b5 ede6                      	ldi ZL,low(SDbuffer+1)	; Skip DSK0 start with DSK1
                                    
0002b6 e043                      	ldi r20,3
0002b7 9101                      lp93:	ld r16,Z+		;Mov char from buffer to fdcData
0002b8 9300 0103                 	sts fdcData,r16		;
0002ba 983a                      	cbi PortE,2		;Release TI
0002bb df98                      	rcall WaitTIread	;Wait for TI to read
0002bc 9a3a                      	sbi PortE,2		;Put TI on hold
0002bd 954a                      	dec r20
0002be f7c1                      	brne lp93
                                 	
                                 ;Send Names
0002bf 2755                      	clr r21			;Start at disk 0
0002c0 d030                      lp91:	rcall Disk2Sector	;Convert disk# in R21 to sector address
0002c1 d284                      	rcall ReadMMC           ;Read sector
0002c2 ede5                      	ldi ZL,low(SDbuffer)	;Get address to buffer
0002c3 e0f2                      	ldi ZH,high(SDbuffer)	; "
                                 	
0002c4 e04a                      	ldi r20,10
0002c5 9101                      lp92:	ld r16,Z+		;Mov char from buffer to fdcData
0002c6 9300 0103                 	sts fdcData,r16		;
0002c8 983a                      	cbi PortE,2		;Release TI
0002c9 df8a                      	rcall WaitTIread	;Wait for TI to read
0002ca 9a3a                      	sbi PortE,2		;Put TI on hold
0002cb 954a                      	dec r20
0002cc f7c1                      	brne lp92
                                 	
0002cd 9553                      	inc r21			;Next disk
0002ce f789                      	brne lp91		;If roll over then finished
0002cf 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Change disk in drive
                                 ; ENTRY:
                                 ;	From TI	- r20 Drive 1-3 
                                 ;	From TI - r21 Disk 0-255
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r17 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ChgDisk:
                                 ;Get drive number from TI
0002d0 983a                      	cbi PortE,2		;Release TI
0002d1 df8c                      	rcall WaitTIwrite	;Wait for data from TI
0002d2 9140 0103                 	lds r20,fdcData		;Get Drive number
0002d4 7043                      	andi r20,0x03		;
                                 ;	dec r20			;DSK 1-3 to 0-2
                                 ;Get disk number from TI
0002d5 df88                      	rcall WaitTIwrite	;Wait for data from TI
0002d6 9150 0103                 	lds r21,fdcData		;Get disk number
0002d8 9a3a                      	sbi PortE,2		;Put TI on hold
                                 	
0002d9 3040                      	cpi r20,0		;Check If DSK0
0002da f419                      	brne jp23
0002db 9350 0107                 	sts DSK0volume,r21	;Store DSK0 volume
0002dd c012                      	rjmp jp24		;But don't save in sector 1
                                 	
                                 ;Put new disk number in sector 1	
0002de e001                      JP23:	ldi r16,0x01
0002df 9300 011e                 	sts arg,r16		; (LSB) sector 00 00 00 01
0002e1 2700                       	clr r16
0002e2 9300 011f                 	sts arg+1,r16
0002e4 9300 0120                 	sts arg+2,r16
0002e6 9300 0121                 	sts arg+3,r16		; (MSB)
0002e8 d25d                      	rcall ReadMMC           ; Read sector 1
0002e9 e0f2                      	ldi ZH,high(SDbuffer)	; Get address to buffer
0002ea ede5                      	ldi ZL,low(SDbuffer)	; "
                                 ; Drive number r20
                                 ; Disk number r21
0002eb 0fe4                      	add ZL,r20		;Point to DSK0,DSK1,DSK2,DSK3	
0002ec 2700                      	clr r16			;Note 1st byte DSK0 not used
0002ed 1ff0                      	adc ZH,r16		; "
0002ee 8350                      	st Z,r21		; Save new disk number
0002ef d223                      	rcall WriteMMC          ; Write sector 1 back to SD
0002f0 9508                      jp24:	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Multiply DISK number and store sector address at DSKx addresses
                                 ; Entry:
                                 ;	r21 = disk number
                                 ;
                                 ; Exit:	    
                                 ;	Disk sector address store in arg also in r0-r3	
                                 ;	Registers used r0-r5 r16 r17 Z
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Disk2Sector:
0002f1 2e55                       	mov r5,r21		    ;Save dsisk number
                                 
0002f2 e0f1                      	ldi ZH,high(StartSector)   ; "
0002f3 e2e9                      	ldi ZL,low(StartSector)    ; "
0002f4 9001                      	ld r0,Z+		    ;initilize to start sector
0002f5 9011                      	ld r1,Z+		    ; "
0002f6 2422                      	clr r2			    ; "
0002f7 2433                      	clr r3			    ; "
0002f8 9101                      	ld r16,Z+		    ;Get step sectors
0002f9 9111                      	ld r17,Z+		    ; "   
                                 
0002fa 2055                      	tst r5			    ; Test for Disk number zero
0002fb f019                      	breq jp90		    ; skip if zero
0002fc d009                      lp90:	rcall Add32_16		    ;Multiply disk number by step
0002fd 945a                      	dec r5			    ; "
0002fe f7e9                      	brne lp90		    ; "
                                 	
0002ff e0f1                      jp90:	ldi ZH,high(arg)	    ;Place result in argument
000300 e1ee                      	ldi ZL,low(arg)	    ; "
000301 9201                       	st Z+,r0
000302 9211                      	st Z+,r1	
000303 9221                      	st Z+,r2	
000304 9231                      	st Z+,r3
000305 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Add 16 bits to 32 bits (lsbyte first)
                                 ; Entry		r0,r1,r2,r3 + r16,r17 
                                 ; Exit result	r0,r1,r2,r3
                                 ; r4 cleared,r16,r17 not destroyed	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Add32_16:	
000306 2444                      	clr r4
000307 0e00                      	add r0,r16  ;add low byte
000308 1c14                      	adc r1,r4
000309 1c24                      	adc r2,r4
00030a 1c34                      	adc r3,r4
00030b 0e11                      	add r1,r17 ;add high byte
00030c 1c24                      	adc r2,r4
00030d 1c34                      	adc r3,r4
00030e 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; USART routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 USARTInit:
00030f b909                      	out UBRR0L,r16			;Set Baud rate
000310 bd10                      	out UBRR0H,r17
000311 e806                      	ldi r16,(1<<URSEL0)|(3<<UCSZ00)	;8N1
000312 bd00                      	out UCSR0C,r16
000313 e108                      	ldi r16,(1<<RXEN)|(1<<TXEN)	;Enable receive & transmit
000314 b90a                      	out UCSR0B,r16
                                 ;	ldi r16,(1<<U2X)		;Double the baud rate
                                 ;	out UCSR0A,r16
000315 9508                      	ret
                                 USARTRead:
000316 9b5f                      	sbis UCSR0A,RXC			;Wait until data is available
000317 cffe                      	rjmp USARTRead
000318 b10c                      	in r16,UDR			;Get received data
000319 9508                      	ret
                                 USARTWrite:
00031a 9b5d                      	sbis UCSR0A,UDRE		;Wait until transmit is ready
00031b cffe                      	rjmp USARTWrite
00031c b90c                      	out UDR,r16			;Send data
00031d 9508                      	ret
                                 USARTFlush:
00031e 9b5f                      	sbis UCSR0A,RXC
00031f 9508                      	ret
000320 b10c                      	in r16,UDR
000321 cffc                      	rjmp USARTFlush
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; TI access to USART
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIrdUsartStat:
000322 b10a                          	in r16,UCSR0B		;Check if RXC interrupt enabled
000323 ff07                      	sbrs r16,RXCIE		;Skip if intr set
000324 c006                      	rjmp jp16		;Get data from USART
                                 	    
000325 9100 012f                 	lds r16,SerCnt
000327 3000                      	cpi r16,0
000328 f019                      	breq jp17		;Send 0 No data available
000329 ee02                      	ldi r16,226		;Send 226 status If buffer not 0
00032a c001                      	rjmp jp17		;
                                 
00032b b10b                      jp16:	in r16,UCSR0A
00032c 9300 0103                 jp17:	sts fdcData,r16		;Send to TI
00032e 983a                      	cbi PortE,2		;Release TI
00032f 9508                      	ret
                                 
                                 TIrdUsartData:
000330 b10a                              in r16,UCSR0B		;Check if RXC interrupt enabled
000331 ff07                      	sbrs r16,RXCIE		;Skip if intr set
000332 c014                      	rjmp jp18		;Get data from USART
                                     
000333 9100 012f                 	lds r16,SerCnt
000335 3000                      	cpi r16,0
000336 f089                      	breq jp19		;Send 0 No data available
000337 950a                      	dec r16
000338 9300 012f                 	sts SerCnt,r16
                                 	
00033a e0f1                      	ldi ZH,high(Serbuffer)
00033b e3e5                      	ldi ZL,low(Serbuffer)
00033c 9100 012e                 	lds r16,SerRdPtr	;ptr Status byte
00033e 0fe0                      	add ZL,r16		;Point Z to Char byte
                                 ;	clr r17			;
                                 ;	adc ZH,r17
00033f 9503                      	inc r16			;ptr next entry
000340 3a00                      	cpi r16,Serbuffsize
000341 f409                      	brne jp14
000342 2700                      	clr r16
000343 9300 012e                 jp14:	sts SerRdPtr,r16
000345 8100                      	ld r16,Z		;Get char from buffer
000346 c001                      	rjmp jp19
                                 	
000347 b10c                      jp18:	in r16,UDR		;Get char from USART
000348 9300 0103                 jp19:	sts fdcData,r16		;Send to TI
00034a 983a                      	cbi PortE,2		;Release TI
00034b 9508                      	ret 
                                 	 
                                 TIwrUsartData:
00034c 983a                      	cbi PortE,2		;Release TI
00034d df10                      	rcall WaitTIwrite	;Wait for data from TI
00034e 9100 0103                 	lds r16,fdcData
000350 dfc9                      	rcall USARTWrite
000351 9508                      	ret
                                     
                                 TIwrUsartSub:
000352 983a                      	cbi PortE,2		;Release TI
000353 df0a                      	rcall WaitTIwrite	;Wait for data from TI
000354 9100 0103                 	lds r16,fdcData
000356 9a3a                      	sbi PortE,2		;Hold TI
                                 
000357 3000                      	cpi r16,0		;Flush Buffer
000358 f449                      	brne jp20
000359 dfc4                      	rcall USARTFlush
00035a 2700                      	clr r16			;
00035b 9300 012e                 	sts SerRdPtr,r16	;Reset pointers
00035d 9300 012d                 	sts SerWrPtr,r16
00035f 9300 012f                 	sts SerCnt,r16
000361 9508                      	ret
                                 
000362 3001                      jp20:	cpi r16,1		;Turn on 128 buffer
000363 f421                      	brne jp21		;
000364 b10a                      	in r16,UCSR0B		;Enable RXC interrupt
000365 6800                      	sbr r16,1<<RXCIE	; "
000366 b90a                      	out UCSR0B,r16		; "
000367 9508                      	ret			;		
                                 
000368 3002                      jp21:	cpi r16,2		;Turn off 128 buffer
000369 f419                      	brne jp22		;
00036a b10a                      	in r16,UCSR0B		;Disable RXC interrupt
00036b 770f                      	cbr r16,1<<RXCIE	; "
00036c b90a                      	out UCSR0B,r16		; "
00036d 9508                      jp22:	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; SPI routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SPIInit:
00036e e503                      	ldi r16,(1<<SPE)|(1<<MSTR)|(3<<SPR0)	;En SPI,Master,fosc/128(125k)
00036f b90d                      	out SPCR,r16	;DORD=MSB,CPOL=rising,CPHA=LeadSample/TrailSetup
                                 ;	ldi r16,(1<<SPI2X)			; SPI double speed
                                 ;	out SPSR,r16	
000370 9508                      	ret
                                 SPIRead:
000371 ef0f                      	ser r16			;Transmit ones to receive byte
                                 SPIWrite:
000372 b90f                      	out SPDR,r16		;Send transmit byte
                                 SPIWait:	
000373 9b77                      	sbis SPSR,SPIF		;Wait Fot Transmission complete
000374 cffe                      	rjmp SPIWait
000375 b10f                      	in	r16,SPDR	; Get received byte
000376 9508                      	ret
                                 FullThrottle:
000377 9868                      	cbi SPCR,SPR0
000378 9869                      	cbi SPCR,SPR1
000379 9a70                      	SBI SPSR,SPI2X
00037a 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ; Access EXFAT find file TIVOL000
                                 ;	
                                 ;************************************************************************************
                                 ; Process Master Boot Sector
                                 ;************************************************************************************
                                 FindTIVOL:
00037b 2700                      	clr r16				;Get MBR sector
00037c 9300 011e                 	sts arg,r16			; (LSB) sector 00 00 00 00
00037e 9300 011f                 	sts arg+1,r16
000380 9300 0120                 	sts arg+2,r16
000382 9300 0121                 	sts arg+3,r16			; (MSB)
000384 d1c1                      	rcall ReadMMC           	; First 512 sector (uses ZL & ZH)
                                 		
000385 e9eb                      	ldi ZL,low(SDbuffer+0x1C6)	;Save VBR in Offset
000386 e0f4                      	ldi ZH,high(SDbuffer+0x1C6)	; "
000387 e2c5                      	ldi YL,low(Offset)		; "
000388 e0d1                      	ldi YH,high(Offset)		; "
000389 d238                      	rcall mov4
                                 
                                 ;************************************************************************************
                                 ; Process Volume Boot Sector
                                 ;************************************************************************************
00038a e2e5                      	ldi ZL,low(Offset)		;Put vbr in arg
00038b e0f1                      	ldi ZH,high(Offset)		;
00038c e1ce                      	ldi YL,low(arg)    		; "
00038d e0d1                      	ldi YH,high(arg)   		; "
00038e d233                      	rcall mov4
00038f d1b6                      	rcall ReadMMC           	; Get VBR sector	
                                 	
000390 ede5                      	ldi ZL,low(SDbuffer)		;Point to buffer
000391 e0f2                      	ldi ZH,high(SDbuffer)		;
000392 eac0                      	ldi YL,low(EXFATstr<<1)
000393 e0d1                      	ldi YH,high(EXFATstr<<1)
000394 d21a                      	rcall cmpstr
000395 f561                      	brne DiskErrRly			;Partition is not EXFAT
                                 	
000396 e2cd                      	ldi YL,low(SDbuffer+0x58)	;Save HeapOffset+VBR
000397 e0d3                      	ldi YH,high(SDbuffer+0x58)	; "
000398 e2a5                      	ldi XL,low(OffSet)    		; "
000399 e0b1                      	ldi XH,high(Offset)   		; "
00039a d22d                      	rcall AddDword			; Result in Offset
                                 
00039b e3e5                      	ldi ZL,low(SDbuffer+0x60)	;Get RootDirectory cluster
00039c e0f3                      	ldi ZH,high(SDbuffer+0x60)	; "
00039d e1ce                      	ldi YL,low(arg)    		; "
00039e e0d1                      	ldi YH,high(arg)   		; "
00039f d222                      	rcall mov4
                                 	
0003a0 9100 011e                 	lds r16,arg			; Start cluster - 2
0003a2 950a                      	dec r16				;
0003a3 950a                      	dec r16				;
0003a4 9300 011e                 	sts arg,r16			;
                                 
0003a6 e4e2                      	ldi ZL,low(SDbuffer+0x6D)	;Point to SectorsPerClusterShift
0003a7 e0f3                      	ldi ZH,high(SDbuffer+0x6D)	;
0003a8 8130                      	ld r19,Z			;
0003a9 9330 0124                 	sts SectorsPerCluster,r19 	;Save SectorsPerClusterShift
0003ab d1ec                      	rcall LslArg			;RootDirectory * SectorsPerClusterShift
                                 
                                 ;************************************************************************************
                                 ; Process Root Directory Sector	(Find VOLUMES folder)
                                 ;************************************************************************************
0003ac e1ae                      	ldi XL,low(arg)		;Add VBR+HeapOffset to RootDirectory in arg
0003ad e0b1                      	ldi XH,high(arg)		; "
0003ae e2c5                      	ldi YL,low(OffSet)    		; "
0003af e0d1                      	ldi YH,high(Offset)   		; "
0003b0 d217                      	rcall AddDword			; "
0003b1 d194                      	rcall ReadMMC           	;Get RootDirectory sector
                                 	    
0003b2 ede5                      	ldi ZL,low(SDbuffer)		;Point to buffer
0003b3 e0f2                      	ldi ZH,high(SDbuffer)		;
0003b4 eaca                      	ldi YL,low(VOLstr<<1)
0003b5 e0d1                      	ldi YH,high(VOLstr<<1)
                                 
0003b6 8100                      lp06:	ld r16,Z
0003b7 3c01                      	cpi r16,0xC1			;Check for type C1 entry
0003b8 f411                      	brne jp06
0003b9 d1f5                      	rcall cmpstr
0003ba f041                      	breq jp03
                                 
0003bb 96b0                      jp06:	adiw ZH:ZL,32			;Next entry
0003bc ed05                      	ldi R16,low(SDbuffer+512)
0003bd 17e0                      	cp ZL,r16			;Check end of buffer
0003be f7b9                      	brne lp06  
0003bf e004                      	ldi R16,high(SDbuffer+512)
0003c0 17f0                      	cp ZH,r16			;Check end of buffer
0003c1 f7a1                      	brne lp06  
                                 DiskErrRly:
0003c2 c05e                      	rjmp DiskErr			;VOLUMES not found
                                 
                                 jp03:	
0003c3 97b0                       	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
0003c4 9674                       	adiw ZH:ZL,20			;Point to VOLUMES folder cluster dword at 20
0003c5 e1ce                      	ldi YL,low(arg)    		; "
0003c6 e0d1                      	ldi YH,high(arg)   		; "
0003c7 d1fa                      	rcall mov4
                                 	
0003c8 9100 011e                 	lds r16,arg			; Start cluster - 2
0003ca 950a                      	dec r16				;
0003cb 950a                      	dec r16				;
0003cc 9300 011e                 	sts arg,r16			;
                                 
0003ce 9130 0124                 	lds r19,SectorsPerCluster
0003d0 d1c7                      	rcall LslArg			;VOLUMES folder * SectorsPerCluster
                                 
                                 ;************************************************************************************
                                 ; Process VOLUMES Sector	(Find TIVOL000 file sector)
                                 ;************************************************************************************
0003d1 e1ae                      	ldi XL,low(arg)		;Add VBR+HeapOffset to VOLUMES folder in arg
0003d2 e0b1                      	ldi XH,high(arg)		; "
0003d3 e2c5                      	ldi YL,low(Offset)    		; "
0003d4 e0d1                      	ldi YH,high(Offset)   		; "
0003d5 d1f2                      	rcall AddDword			; "
0003d6 d16f                      	rcall ReadMMC           	;Get VOLUMES folder sector
                                 	
0003d7 ede5                      	ldi ZL,low(SDbuffer)		;Point to buffer
0003d8 e0f2                      	ldi ZH,high(SDbuffer)		;
0003d9 ebca                      	ldi YL,low(TIVOLstr<<1)
0003da e0d1                      	ldi YH,high(TIVOLstr<<1)
                                 	
0003db 8100                      lp04:	ld r16,Z
0003dc 3c01                      	cpi r16,0xC1			;Check for type C1 entry
0003dd f411                      	brne jp04
0003de d1d0                      	rcall cmpstr
0003df f041                      	breq jp05			;TIVOL000 found
                                 
0003e0 96b0                      jp04:	adiw ZH:ZL,32			;Next entry
0003e1 ed05                      	ldi R16,low(SDbuffer+512)
0003e2 17e0                      	cp ZL,r16			;Check end of buffer
0003e3 f7b9                      	brne lp04  
0003e4 e004                      	ldi R16,high(SDbuffer+512)
0003e5 17f0                      	cp ZH,r16			;Check end of buffer
0003e6 f7a1                      	brne lp04  
0003e7 c039                      	rjmp DiskErr			;TIVOL000 not found
                                 
0003e8 97b0                      jp05:	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
0003e9 9674                      	adiw ZH:ZL,20			;Point TIVOL000 file cluster dword at 20
0003ea e1ce                      	ldi YL,low(arg)    		; TIVOL000 file cluster
0003eb e0d1                      	ldi YH,high(arg)   		; "
0003ec d1d5                      	rcall mov4
                                 	
0003ed 9100 011e                 	lds r16,arg			; Start cluster - 2
0003ef 950a                      	dec r16				;
0003f0 950a                      	dec r16				;
0003f1 9300 011e                 	sts arg,r16			;
                                 	
0003f3 9130 0124                 	lds r19,SectorsPerCluster
0003f5 d1a2                      	rcall LslArg			;TIVOL000 file * SectorsPerCluster
                                 
0003f6 e1ae                      	ldi XL,low(arg)		;Add VBR+HeapOffset to TIVOL000 file in arg
0003f7 e0b1                      	ldi XH,high(arg)		; "
0003f8 e2c5                      	ldi YL,low(OffSet)    		; "
0003f9 e0d1                      	ldi YH,high(OffSet)   		; "
0003fa d1cd                      	rcall AddDword			;
0003fb 9100 011e                 	lds r16,arg			;Save TIVOL000 start sector
0003fd 9300 0129                 	sts StartSector,r16		; "
0003ff 9100 011f                 	lds r16,arg+1			; "
000401 9300 012a                 	sts StartSector+1,r16		; " 
                                 
000403 e1ce                      	ldi YL,low(arg)    		;Z left pointing to file size at 24
000404 e0d1                      	ldi YH,high(arg)   		;file size is qword but we will never exceed dword
000405 d1bc                      	rcall mov4
                                 		
000406 9130 0124                 	lds r19,SectorsPerCluster
000408 e009                      	ldi r16,9
000409 0f30                      	add r19,r16
00040a d1ce                      	rcall LsrArg			;Divide by SectorsPerCluster + 512 bytes per sector
00040b f44e                      	brtc jp01			;If t not set then no carry (no remainder)
00040c 91e0 011e                 	lds ZL,arg
00040e 91f0 011f                 	lds ZH,arg+1
000410 9631                      	adiw ZH:ZL,1
000411 93e0 011e                 	sts arg,ZL
000413 93f0 011f                 	sts arg+1,ZH
000415 9130 0124                 jp01:	lds r19,SectorsPerCluster
000417 d180                      	rcall LslArg			;Size in clusters back to size in sectors
                                 
000418 9100 011e                 	lds r16,arg			;Save sector step
00041a 9300 012b                 	sts StepSectors,r16		; "
00041c 9100 011f                 	lds r16,arg+1			; "
00041e 9300 012c                 	sts StepSectors+1,r16		; 
                                 	
000420 9418                      	sez				;Set Z bit (No error)
                                 DiskErr:				;Return error,Z bit cleared
000421 9508                      	ret				;On return will set disk ready status	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;	
                                 ; Low level SD card access
                                 ;	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send command to MMC,Uses cmd resp r16 r17 r18 nz=error
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendMMC:
                                     ;4.8ms delay,PNY 1GB had trouble without delay
000422 d157                          	rcall delay1ms
000423 d156                      	rcall delay1ms
000424 d155                      	rcall delay1ms
000425 d154                      	rcall delay1ms
000426 d153                      	rcall delay1ms
                                 		
000427 ef0f                      	ldi r16,0xFF		;
000428 df49                             	rcall SPIWrite	;
000429 9100 011d                 	lds r16,cmd		; Send the command byte
00042b df46                      	rcall SPIWrite	;
00042c 9100 0121                 	lds r16,arg+3		; Send 4 argument bytes starting with MSB
00042e df43                      	rcall SPIWrite	;
00042f 9100 0120                 	lds r16,arg+2		;
000431 df40                      	rcall SPIWrite	;
000432 9100 011f                 	lds r16,arg+1		;
000434 df3d                      	rcall SPIWrite	;
000435 9100 011e                 	lds r16,arg		;
000437 df3a                      	rcall SPIWrite	;
000438 9100 0122                 	lds r16,crc		; Send the CRC7 byte (always use 95)
00043a df37                             	rcall SPIWrite	;
                                 			
                                 WaitResp:
00043b 2722                      	clr r18
                                 lp10:
                                     ;.69ms delay,PNY 1GB had trouble without delay	
00043c d13d                      	rcall delay1ms		
                                 				
00043d df33                      	rcall SPIRead	;
00043e 9110 0123                 	lds r17,resp
000440 1701                      	cp r16,r17		; expected response?
000441 f021                      	breq jp11		; YES - return
000442 952a                      	dec r18			; waiting period is over?
000443 f7c1                             	brne lp10		; NO - keep waiting
000444 d126                      	rcall SendErrorSPI	;
000445 9498                      	clz			; Clear zero flag for time out
000446 9508                      jp11:	ret			;
                                 
                                     
                                 ;********************************************************************
                                 ; Init SD/MMC memory card
                                 ;******************************************************************** 
                                 MMCInit:	
000447 9ac4                      	sbi PortB,CS		    ; disable MMC
000448 e01a                      	ldi r17,10		    ; Send 80 dummy clocks
                                 lp20:
000449 df27                      	rcall SPIRead	    ;
00044a 951a                             	dec R17			    ;
00044b f7e9                      	brne lp20		    ;
00044c 98c4                              cbi PortB,CS		    ; enable MMC         
                                 SendCMD0:
00044d e400                      	ldi r16,0x40		    ; CMD0 GO_IDLE_STATE
00044e 9300 011d                 	sts cmd,r16              
000450 2700                             	clr r16			    ; LSB
000451 9300 011e                 	sts arg,r16                ; 0x00000000
000453 9300 011f                 	sts arg+1,r16              ;	
000455 9300 0120                 	sts arg+2,r16              ;	
000457 9300 0121                 	sts arg+3,r16              ; MSB
000459 e905                      	ldi r16,0x95
00045a 9300 0122                        	sts crc,r16
00045c e001                      	ldi r16,1
00045d 9300 0123                 	sts resp,r16		    ; expected response cnt 8
00045f dfc2                      	rcall SendMMC		    ;
000460 f761                             	brne SendCMD0		    ; Expected response timed out
                                 SendCMD8:
000461 e408                      	ldi r16,0x48		    ; CMD8 SEND_IF_COND
000462 9300 011d                 	sts cmd,r16
000464 ea0a                      	ldi r16,0xAA		    ; LSB
000465 9300 011e                 	sts arg,r16                ; 0x000001AA
000467 e001                      	ldi r16,0x01		    ;
000468 9300 011f                 	sts arg+1,r16              ;
00046a 2700                      	clr r16			    ;
00046b 9300 0120                 	sts arg+2,r16              ;
00046d 9300 0121                 	sts arg+3,r16              ; MSB
00046f e807                      	ldi r16,0x87
000470 9300 0122                 	sts crc,r16
000472 e001                      	ldi r16,1		    ; Response V2=0x01 0x000001AA or V1=0x05
000473 9300 0123                 	sts resp,r16
000475 dfac                      	rcall SendMMC               ; 
000476 f571                      	brne SendCMD1
000477 def9                      	rcall SPIRead		    ; need to clear 0x000001AA
000478 def8                      	rcall SPIRead		    ;	
000479 def7                              rcall SPIRead		    ;	      	
00047a def6                      	rcall SPIRead		    ;			; 
                                 			
                                 ;ACMD41 (CMD55+CMD41)			
                                 SendCMD55:
00047b e707                      	ldi r16,0x77		    ; CMD55 APP_CMD
00047c 9300 011d                 	sts cmd,r16              
00047e 2700                             	clr r16			    ; LSB
00047f 9300 011e                 	sts arg,r16                ; 0x00000000
000481 9300 011f                 	sts arg+1,r16              ;	
000483 9300 0120                 	sts arg+2,r16              ;	
000485 9300 0121                 	sts arg+3,r16              ; MSB
000487 ef0f                      	ldi r16,0xFF
000488 9300 0122                        	sts crc,r16
00048a e001                      	ldi r16,1
00048b 9300 0123                 	sts resp,r16		    ; expected response
00048d df94                      	rcall SendMMC		    ;
00048e f761                             	brne SendCMD55		    ;  Expected response timed out	
                                 SendCMD41: 	
00048f e609                      	ldi r16,0x69		    ; CMD41 SD_SEND_OP_COND
000490 9300 011d                 	sts cmd,r16              
000492 2700                             	clr r16			    ; LSB
000493 9300 011e                 	sts arg,r16                ; 0x40000000
000495 9300 011f                 	sts arg+1,r16              ;
000497 9300 0120                 	sts arg+2,r16              ;
000499 e400                      	ldi r16,0x40
00049a 9300 0121                 	sts arg+3,r16              ; MSB
00049c ef0f                      	ldi r16,0xFF
00049d 9300 0122                        	sts crc,r16
00049f 2700                      	clr r16
0004a0 9300 0123                 	sts resp,r16		    ; expected response
0004a2 df7f                      	rcall SendMMC		    ;
0004a3 f6b9                             	brne SendCMD55		    ;  Expected response timed out
0004a4 c014                      	rjmp SendCMD58
                                 
                                 SendCMD1:
0004a5 e401                      	ldi r16,0x41		    ; CMD1 SEND_OP_COND
0004a6 9300 011d                 	sts cmd,r16              
0004a8 2700                             	clr r16			    ; LSB
0004a9 9300 011e                 	sts arg,r16                ; 0x00000000
0004ab 9300 011f                 	sts arg+1,r16              ;	
0004ad 9300 0120                 	sts arg+2,r16              ;	
0004af 9300 0121                 	sts arg+3,r16              ; MSB
0004b1 ef0f                      	ldi r16,0xFF
0004b2 9300 0122                        	sts crc,r16
0004b4 2700                      	clr r16
0004b5 9300 0123                 	sts resp,r16		    ; expected response
0004b7 df6a                      	rcall SendMMC		    ;
0004b8 f761                             	brne SendCMD1		    ;  Expected response timed out
                                    			
                                 SendCMD58:
0004b9 e70a                      	ldi r16,0x7A		    ; CMD58 READ_OCR
0004ba 9300 011d                 	sts cmd,r16              
0004bc 2700                             	clr r16			    ; LSB
0004bd 9300 011e                 	sts arg,r16                ; 0x00000000
0004bf 9300 011f                 	sts arg+1,r16              ;	
0004c1 9300 0120                 	sts arg+2,r16              ;	
0004c3 9300 0121                 	sts arg+3,r16              ; MSB
0004c5 ef0f                      	ldi r16,0xFF
0004c6 9300 0122                        	sts crc,r16
0004c8 2700                      	clr r16
0004c9 9300 0123                 	sts resp,r16		    ; expected response
0004cb df56                      	rcall SendMMC		    ;
0004cc f761                             	brne SendCMD58		    ;  Expected response timed out
                                 
0004cd e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
0004ce ede5                      	ldi ZL,low(SDbuffer)	    ; "
0004cf e034                      	ldi R19,4
                                 lp21:
0004d0 dea0                      	rcall SPIRead		    ; Get MSByte 1 of 4 OCR register
0004d1 9301                      	st Z+,r16		    ; Save OCR to buffer
0004d2 953a                      	dec R19
0004d3 f7e1                      	brne lp21
0004d4 9100 02d5                 	lds r16,SDbuffer
0004d6 9300 011c                 	sts ocr,r16		    ; bit6=1 SDHC
                                 
                                 SendCMD9:
0004d8 e409                      	ldi r16,0x49		    ; CMD9 READ_CSD
0004d9 9300 011d                 	sts cmd,r16              
0004db 2700                             	clr r16			    ;
0004dc 9300 0123                 	sts resp,r16		    ; expected response
0004de df43                      	rcall SendMMC		    ;
0004df f7c1                      	brne SendCMD9		    ; Expected response timed out
0004e0 ef0e                      	ldi r16,0xFE
0004e1 9300 0123                 	sts resp,r16
0004e3 df57                      	rcall WaitResp		    ; Wait for FE Start
0004e4 f799                      	brne SendCMD9
0004e5 e132                      	ldi r19,18
                                 lp22:	
0004e6 de8a                      	rcall SPIRead
0004e7 953a                      	dec r19
0004e8 f7e9                      	brne lp22
                                 
                                 SendCMD10:
0004e9 e40a                          	ldi r16,0x4A		    ; CMD10 READ_CID
0004ea 9300 011d                 	sts cmd,r16              
0004ec 2700                             	clr r16			    ;
0004ed 9300 0123                 	sts resp,r16		    ; expected response
0004ef df32                      	rcall SendMMC		    ;
0004f0 f7c1                      	brne SendCMD10		    ; Expected response timed out
0004f1 ef0e                      	ldi r16,0xFE
0004f2 9300 0123                 	sts resp,r16
0004f4 df46                      	rcall WaitResp		    ; Wait for FE Start
0004f5 f799                      	brne SendCMD10
0004f6 e132                          	ldi r19,18
                                 lp23:	
0004f7 de79                      	rcall SPIRead
0004f8 953a                      	dec r19
0004f9 f7e9                      	brne lp23
                                 
0004fa de7c                      	rcall FullThrottle
                                 			
                                 ; Let fall thru to Set Block			
                                 ;********************************************************************
                                 ; CMD16 SET_BLOCKLEN default 512
                                 ; The only valid block length for write is 512!
                                 ; Read is 1 to 2048
                                 ;********************************************************************
                                 SetBlockMMC: 
0004fb 98c4                      	cbi PortB,CS		    ; enable MMC         
0004fc e500                      	ldi r16,0x50		    ; CMD16 SET_BLOCKLEN
0004fd 9300 011d                 	sts cmd,r16              
0004ff 2700                             	clr r16			    ; LSB
000500 9300 011e                 	sts arg,r16                ; 0x00000200 (512 block)
000502 e002                      	ldi r16,2
000503 9300 011f                 	sts arg+1,r16              ;
000505 2700                      	clr r16
000506 9300 0120                 	sts arg+2,r16              ;	
000508 9300 0121                 	sts arg+3,r16              ; MSB
00050a 2700                      	clr r16
00050b 9300 0122                 	sts crc,r16
00050d 9300 0123                 	sts resp,r16		    ; expected response
00050f df12                      	rcall SendMMC		    ;
000510 f751                             	brne SetBlockMMC	    ; Expected response timed out
000511 9ac4                      	sbi PortB,CS		    ; Disable MMC
000512 9508                      	ret 							;
                                 
                                 ;********************************************************************
                                 ; CMD24 WRITE_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ; Exit nz=write error
                                 ;********************************************************************
                                 WriteMMC:			    ;Write 1st 256 bytes of sector
000513 98c4                      	cbi PortB,CS		    ; enable MMC   
000514 d070                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
000515 9100 011c                 	lds r16,ocr
000517 ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
000518 d07e                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 lp40:
000519 e508                      	ldi r16,0x58		    ; CMD24 WRITE_BLOCK
00051a 9300 011d                 	sts cmd,r16 
00051c 2700                      	clr r16
00051d 9300 0122                 	sts crc,r16
00051f 9300 0123                 	sts resp,r16		    ; expected response
000521 df00                      	rcall SendMMC		    ;
000522 f7b1                             	brne lp40		    ; Expected response timed out
                                 	
000523 de4d                      	rcall SPIRead		    ; write prefix (Read writes FFFF)
000524 de4c                      	rcall SPIRead
000525 ef0e                      	ldi r16,0xFE		    ; Send start data token
000526 de4b                      	rcall SPIWrite
                                 	
000527 e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
000528 ede5                      	ldi ZL,low(SDbuffer)	    ; "
000529 2733                      	clr R19			    ; Write 256 bytes to SD
                                 ;Write 1st 256 bytes of sector	
                                 lp41:
00052a 9101                      	ld r16,Z+
00052b de46                      	rcall SPIWrite		    ; Write data byte
00052c 953a                      	dec R19
00052d f7e1                      	brne lp41
                                 ;Write 2nd 256 bytes of sector    		 
                                 lp42:
00052e 9101                      	ld r16,Z+
00052f de42                      	rcall SPIWrite		    ; Write data byte
000530 953a                      	dec R19
000531 f7e1                      	brne lp42				
000532 de3e                      	rcall SPIRead		    ; write 2 bytes CRC 0xFF (Read writes FFFF)
000533 de3d                      	rcall SPIRead		    ;  "
                                 	    
000534 de3c                      	rcall SPIRead		    ; was data accepted			
000535 710f                      	andi r16,0x1F
000536 3005                      	cpi r16,5
000537 f449                      	brne jp45
000538 ef0f                      	ldi r16,0xFF		    ; wait for 0xFF
000539 9300 0123                 	sts resp,r16
00053b deff                      	rcall WaitResp
00053c f421                      	brne jp45
00053d d050                      	rcall RestoreArg
00053e 9ac4                      	sbi PortB,CS		    ; Disable MMC
00053f 9418                      	sez			    ;Set zero fla
000540 9508                             	ret			    ; normal return z-flag set
                                 jp45:
000541 d04c                      	rcall RestoreArg
000542 d028                      	rcall SendErrorSPI         
000543 9ac4                      	sbi PortB,CS		    ; Disable MMC
000544 9498                      	clz			    ;Clr zero flag
000545 9508                      	ret			    ; write error return z-flag clear
                                  			
                                 			
                                       		
                                 ;********************************************************************
                                 ; CMD17 READ_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ;********************************************************************
                                 ReadMMC:			    ;Read 1st 256 bytes of sector
000546 98c4                      	cbi PortB,CS		    ; enable MMC   
000547 d03d                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
000548 9100 011c                 	lds r16,ocr
00054a ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
00054b d04b                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 lp50:
00054c e501                      	ldi r16,0x51		    ; CMD17 READ_SINGLE_BLOCK
00054d 9300 011d                 	sts cmd,r16 
00054f 2700                      	clr r16
000550 9300 0122                 	sts crc,r16
000552 9300 0123                 	sts resp,r16		    ; expected response
000554 decd                      	rcall SendMMC		    ;
000555 f7b1                             	brne lp50		    ; Expected response timed out
                                 	
000556 ef0e                      	ldi r16,0xFE		    ; Send start data token
000557 9300 0123                 	sts resp,r16
000559 dee1                      	rcall WaitResp		    ; Wait for FE Start
00055a f789                      	brne lp50
                                 ;Read 1st 256 bytes of sector	
00055b e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
00055c ede5                      	ldi ZL,low(SDbuffer)	    ; "
00055d 2733                      	clr R19			    ; Always read 256 the size of buffer
                                 lp51:
00055e de12                      	rcall SPIRead		    ; Get data byte
00055f 9301                      	st Z+,r16
000560 953a                      	dec R19
000561 f7e1                      	brne lp51
                                 ;Read 2nd 256 bytes of sector    		 
                                 lp52:
000562 de0e                      	rcall SPIRead		    ; Get data byte
000563 9301                      	st Z+,r16
000564 953a                      	dec R19
000565 f7e1                      	brne lp52		
000566 de0a                      	rcall SPIRead		    ; read 2 bytes CRC	
000567 de09                      	rcall SPIRead		    ; and discard	
000568 9ac4                      	sbi PortB,CS		    ; Disable MMC
000569 d024                       	rcall RestoreArg
00056a 9508                         	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send error command/response to PC
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendErrorSPI:
00056b ddae                             	rcall USARTWrite	    ; Send response received
00056c 9100 0123                 	lds r16,resp		    
00056e ddab                      	rcall USARTWrite	    ; Send expected response
00056f 9100 011d                 	lds r16,cmd
000571 dda8                      	rcall USARTWrite	    ; Send cmd used
000572 94aa                      	dec r10
                                 ErrLP:	
000573 f3f9                      	breq ErrLP		    ; Keep from runnig away,Until reset
000574 9508                      	ret			    ; Fail 2 or 3 times on start,Just return 
                                 	
                                 SendErrorMedia:
000575 0000                      	nop
000576 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 dlylong:
000577 931f                      	push r17	;
000578 2711                      	clr r17		;
000579 c002                      	rjmp jp51
                                 delay1ms:		;  15431x.0625us aprox 1ms,not exact(.965ms)
00057a 931f                      	push r17	;   2
00057b e114                      	ldi r17,20	;   1
00057c 930f                      jp51:	push r16	;   2
00057d 2700                      	clr r16		;   1
00057e 950a                      dly1:	dec r16		; 768x20=15360          
00057f f7f1                              brne dly1	; 
000580 951a                      	dec r17		; 3x20=60   
000581 f7e1                      	brne dly1
000582 910f                      	pop r16		;   2
000583 911f                      	pop r17 	;   2
000584 9508                      	ret		;   1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                  SaveArg:   
000585 9060 011e                     	lds r6,arg		; Save argument,in case multipled
000587 9070 011f                   	lds r7,arg+1
000589 9080 0120                   	lds r8,arg+2
00058b 9090 0121                   	lds r9,arg+3
00058d 9508                      	ret
                                 RestoreArg:
00058e 9290 0121                 	sts arg+3,r9		; Restore argument
000590 9280 0120                 	sts arg+2,r8 
000592 9270 011f                 	sts arg+1,r7  
000594 9260 011e                 	sts arg,r6
000596 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 Mul512Arg:
000597 e039                      	ldi r19,9		; multiply arg by 512
                                 LslArg:				; shift arg left per r19
                                 lp60:	
000598 9100 011e                 	lds r16,arg
00059a 0f00                      	lsl r16
00059b 9300 011e                 	sts arg,r16
00059d 9100 011f                 	lds r16,arg+1
00059f 1f00                      	rol r16
0005a0 9300 011f                 	sts arg+1,r16
0005a2 9100 0120                 	lds r16,arg+2
0005a4 1f00                      	rol r16
0005a5 9300 0120                 	sts arg+2,r16
0005a7 9100 0121                 	lds r16,arg+3
0005a9 1f00                      	rol r16
0005aa 9300 0121                 	sts arg+3,r16
0005ac 953a                      	dec r19
0005ad f751                      	brne lp60
0005ae 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005af 93ef                      cmpstr:	push ZL
0005b0 93ff                      	push ZH
0005b1 93cf                      	push YL
0005b2 93df                      	push YH
                                 		
0005b3 018f                      	movw r17:r16,ZH:ZL  ;LPM only works with Z
0005b4 01fe                      	movw ZH:ZL,YH:YL
0005b5 01e8                      	movw YH:YL,r17:r16
                                   	
0005b6 9105                      lp07:	lpm r16,Z+
0005b7 3f0f                      	cpi r16,0xFF	;Check end of string
0005b8 f021                      	breq jp07
0005b9 9119                      	ld r17,Y+
0005ba 1701                      	cp r16,r17
0005bb f409                      	brne jp07	;Not equal,return
0005bc cff9                      	rjmp lp07	;Next char
0005bd 91df                      jp07:	pop YH
0005be 91cf                      	pop YL
0005bf 91ff                      	pop ZH
0005c0 91ef                      	pop ZL
0005c1 9508                      	ret		
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005c2 e004                      mov4:	ldi r16,4		    ;
0005c3 9111                      lp01:	ld r17,Z+ 
0005c4 9319                      	st Y+,r17
0005c5 950a                      	dec r16
0005c6 f7e1                      	brne lp01
0005c7 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Add Dword pointed to by X & Y Result pointed to by X
                                 AddDword:
0005c8 910c                      	ld r16,X
0005c9 9119                      	ld r17,Y+
0005ca 0f01                      	add r16,r17
0005cb 930d                      	st X+,r16
                                 
0005cc 910c                      	ld r16,X
0005cd 9119                      	ld r17,Y+
0005ce 1f01                      	adc r16,r17
0005cf 930d                      	st X+,r16
                                 
0005d0 910c                      	ld r16,X
0005d1 9119                      	ld r17,Y+
0005d2 1f01                      	adc r16,r17
0005d3 930d                      	st X+,r16
                                 
0005d4 910c                      	ld r16,X
0005d5 9119                      	ld r17,Y+
0005d6 1f01                      	adc r16,r17
0005d7 930d                      	st X+,r16
0005d8 9508                      	ret
                                 
                                 ; shift arg right per r19
0005d9 94e8                      LsrArg:	clt			
0005da 9100 0121                 lp61:	lds r16,arg+3
0005dc 9506                      	lsr r16
0005dd 9300 0121                 	sts arg+3,r16
0005df 9100 0120                 	lds r16,arg+2
0005e1 9507                      	ror r16
0005e2 9300 0120                 	sts arg+2,r16
0005e4 9100 011f                 	lds r16,arg+1
0005e6 9507                      	ror r16
0005e7 9300 011f                 	sts arg+1,r16
0005e9 9100 011e                 	lds r16,arg
0005eb 9507                      	ror r16
0005ec 9300 011e                 	sts arg,r16
0005ee f408                      	brcc jp61
0005ef 9468                      	set		;Set t bit if carry
0005f0 953a                      jp61:	dec r19
0005f1 f741                      	brne lp61
0005f2 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Xmodem Volume transfer
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0005f3 983a                      XMODEM:	cbi PortE,2		;Release TI
0005f4 dc69                      	rcall WaitTIwrite	;Wait for volume# from TI
0005f5 9150 0103                 	lds r21,fdcData		;Save volume in r21
                                 	
0005f7 dc66                      	rcall WaitTIwrite	;Wait Telnet mode from TI
0005f8 9100 0103                 	lds r16,fdcData
0005fa 9300 0134                 	sts TELFLG,r16
                                 	
0005fc dc61                      	rcall WaitTIwrite	;Wait send/receive mode from TI
0005fd 9140 0103                 	lds r20,fdcData		;Save in r20
                                 	
0005ff b70b                      	in r16,GICR		;Disable INT2
000600 7d0f                      	cbr r16,1<<INT2		; "
000601 bf0b                      	out GICR,r16		; "	
000602 e800                      	ldi r16,0x80		;Set TI to read status NotReady 
000603 bb0b                      	out PortA,r16		;Until Int2 enabled
                                 
000604 2700                      	clr r16
000605 9300 0133                 	sts CRCFLG,r16		;Init CRC flag to checksum mode
000607 9300 0131                 	sts PAKNUM+1,r16	;Init packet # to 1
000609 9503                      	inc r16			; "
00060a 9300 0130                 	sts PAKNUM,r16		; "
00060c dce4                      	rcall Disk2Sector	;Entry r21=disk, Exit arg=SD sector address
00060d d13f                      	rcall BUFFL		;Clear buffer
                                 	
00060e 2344                      	tst r20			;Send/Receive
00060f f409                      	brne SEND 
000610 c057                      	rjmp RECV	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; Send Volume	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
000611 d0ed                      SEND:	rcall SERRD		;Wait for starting NAK
000612 f3f1                      	breq SEND		;Timed out,Loop back
000613 3118                      	cpi r17,CAN		;Check if remote sent cancel
000614 f1d1                      	breq CANRL1		;Cancel Exit Can't continue
000615 3115                      	cpi r17,NAK		;Did remote sent checksum start
000616 f029                      	breq NXTSEC		;flag already set for checksum mode
000617 3413                      	cpi r17,'C'		;Did remote sent CRC start
000618 f7c1                      	brne SEND
000619 e001                      	ldi r16,1		;Set flag for CRC mode
00061a 9300 0133                 	sts CRCFLG,r16		; "		
                                 
00061c d139                      NXTSEC:	rcall RDSEC
00061d e011                      SAMSEC:	ldi r17,SOH		;Send start
00061e d11f                      	rcall UARTWR		; "	
00061f 9110 0130                 	lds r17,PAKNUM		;Send LSByte packet#
000621 d11c                      	rcall UARTWR		; "
000622 9510                      	com r17			;Send LSByte inverted packet#
000623 d11a                      	rcall UARTWR		;
                                 	
000624 e0b2                      	ldi XH,high(SDbuffer)	;Set SDbuffer pointer
000625 eda5                      	ldi XL,low(SDbuffer)
000626 2799                      	clr r25
000627 9180 0130                 	lds r24,PAKNUM
000629 958a                      	dec r24			;(1-4) to (0-3)
00062a 7083                      	andi r24,0x03		;Keep 2 lsbits
00062b e007                      	ldi r16,7		;r25:24 times 128
00062c d144                      	rcall lsl_r25r24	; "
00062d 0fa8                      	add XL,r24		;Add to SDbuffer pointer
00062e 1fb9                      	adc XH,r25
                                 	
00062f 2400                      	clr r0			;Init CRC
000630 2411                      	clr r1
000631 9200 0132                 	sts CHKSUM,r0		;Init checksum
000633 e820                      	ldi r18,128		;Init byte counter
000634 911d                      lp29:	ld r17,X+
000635 d108                      	rcall UARTWR
000636 9100 0132                 	lds r16,CHKSUM
000638 0f01                      	add r16,r17
000639 9300 0132                 	sts CHKSUM,r16
00063b d0a7                      	rcall CRC16		;r17 added to crc in r1:r0
00063c 952a                      	dec r18
00063d f7b1                      	brne lp29
                                 
00063e 9100 0133                 	lds r16,CRCFLG
000640 2300                      	tst r16
000641 f029                      	breq jp29
                                 
000642 2d11                      	mov r17,r1		;Send high byte of CRC
000643 d0fa                      	rcall UARTWR
000644 2d10                      	mov r17,r0		;Send low byte of CRC
000645 d0f8                      	rcall UARTWR
000646 c003                      	rjmp lp30
                                 	
000647 9110 0132                 jp29:	lds r17,CHKSUM		;Send checksum
000649 d0f4                      	rcall UARTWR
                                 
00064a d0b4                      lp30:	rcall SERRD		;Wait for Response
                                 ;	breq SAMSEC		;Timed out,Assume NAK
00064b f3f1                      	breq lp30
00064c 3115                      	cpi r17,NAK		;If NAK
00064d f279                      	breq SAMSEC		;Resend from same sector	
00064e 3118                      	cpi r17,CAN		;If remote cancel
00064f f0b1                      CANRL1:	breq CANRLY		;Exit Can't continue
000650 3016                      	cpi r17,ACK		;If not ACK,Ignore
000651 f7c1                      	brne lp30
                                 
                                 ;ACK
000652 9180 0130                 	lds r24,PAKNUM		;Inc byte packet number
000654 9190 0131                 	lds r25,PAKNUM+1
000656 9601                      	adiw r25:r24,1
000657 9390 0131                 	sts PAKNUM+1,r25
000659 9380 0130                 	sts PAKNUM,r24
00065b 3481                      	cpi r24,0x41		;If packet 2881 then done
00065c f411                      	brne jp30		; "
00065d 309b                      	cpi r25,0x0B		; "
00065e f021                      	breq jp31		; "
                                 	
00065f 7083                      jp30:	andi r24,0x03		;Check if next packet is 1
000660 3081                      	cpi r24,0x01		
000661 f029                      	breq NXTRLY		;Read new sector If zero
000662 cfba                      	rjmp SAMSEC 
                                 	
000663 e014                      jp31:	ldi r17,EOT		;Transfer completed
000664 d0d9                      	rcall UARTWR
000665 c077                      EXTRLY:	rjmp EXIT		;Exit normal
000666 c071                      CANRLY:	rjmp CANCEL
000667 cfb4                      NXTRLY:	rjmp NXTSEC
                                        
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Receive volume
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000668 e028                      RECV: 	ldi r18,8		;Send 'C' 8 times
000669 e413                      lp31:	ldi r17,'C'
00066a d0d3                      	rcall UARTWR
00066b d093                      	rcall SERRD
                                 	
00066c f011                      	breq jp32		;Skip if nothing read
00066d 3011                      	cpi r17,SOH 
00066e f019                      	breq jp33		;Jump CRC
00066f 952a                      jp32:	dec r18
000670 f7c1                      	brne lp31
000671 c006                      	rjmp NAKLP		;Jump Checksum
                                 ;CRC	
000672 9310 0133                 jp33:	sts CRCFLG,r17		;Set flag 01 for CRC mode	
000674 df02                      	rcall dlylong
000675 df01                      	rcall dlylong
000676 df00                      	rcall dlylong
000677 c008                      	rjmp STARTR		;r17 already SOH
                                 ;Checksum
                                 ;
                                 ;
000678 d0d4                      NAKLP:	rcall BUFFL		;Clear buffer
000679 e115                      	ldi r17,NAK		;1st response NAK to start
00067a defc                      ACKLP:	rcall dlylong
00067b defb                      	rcall dlylong
00067c defa                      	rcall dlylong
00067d d0c0                      	rcall UARTWR		;Send response
00067e d080                      	rcall SERRD		;Get SOH of packet
00067f f3c1                      	breq NAKLP		;Timed out,Resend NAK
                                 ;	
000680 9310 0132                 STARTR:	sts CHKSUM,r17		;Init checksum
000682 3014                      	cpi r17,EOT
000683 f309                      	breq EXTRLY
000684 3118                      	cpi r17,CAN
000685 f301                      	breq CANRLY
000686 3011                      	cpi r17,SOH
000687 f781                      	brne NAKLP	
                                 
000688 d076                      	rcall SERRD		;Get packet number
000689 f371                      	breq NAKLP		;Timed out,Resend NAK	
00068a 9100 0132                 	lds r16,CHKSUM		;Add packet number to checksum
00068c 0f01                      	add r16,r17
00068d 9300 0132                 	sts CHKSUM,r16
00068f 9100 0130                 	lds r16,PAKNUM		;LSByte packet#	
000691 1710                      	cp r17,r16		;Does Received packet = Expected packet
000692 f729                      	brne NAKLP	
                                 
000693 d06b                      	rcall SERRD		;Get inverted packet number
000694 f319                      	breq NAKLP		;Timed out,Resend NAK
000695 9100 0132                 	lds r16,CHKSUM		;Add Inv packet number to checksum
000697 0f01                      	add r16,r17		;Sets Z only for r0 thru r7
000698 9300 0132                 	sts CHKSUM,r16
00069a 2300                      	tst r16
00069b f6e1                      	brne NAKLP		;Does SOH+PACKET#+INV PACKET#=0
                                 	
00069c e0b2                      	ldi XH,high(SDbuffer)	;Set SDbuffer pointer
00069d eda5                      	ldi XL,low(SDbuffer)
00069e 2799                      	clr r25
00069f 9180 0130                 	lds r24,PAKNUM
0006a1 958a                      	dec r24			;(1-4) to (0-3)
0006a2 7083                      	andi r24,0x03		;Keep 2 lsbits
0006a3 e007                      	ldi r16,7		;r25:24 times 128
0006a4 d0cc                      	rcall lsl_r25r24	; "
0006a5 0fa8                      	add XL,r24		;Add to SDbuffer pointer
0006a6 1fb9                      	adc XH,r25
                                 	
0006a7 2400                      	clr r0			;Init CRC
0006a8 2411                      	clr r1
0006a9 9200 0132                 	sts CHKSUM,r0		;Init checksum
0006ab e820                      	ldi r18,128		;Init byte counter
0006ac d052                      lp34:	rcall SERRD		;Read packet
0006ad f251                      	breq NAKLP		;Timed out,Resend NAK
0006ae 931d                      	st X+,r17
0006af 9100 0132                 	lds r16,CHKSUM		;Add byte to checksum
0006b1 0f01                      	add r16,r17
0006b2 9300 0132                 	sts CHKSUM,r16
0006b4 d02e                      	rcall CRC16		;r17 added to crc in r1:r0
0006b5 952a                      	dec r18
0006b6 f7a9                      	brne lp34
                                 
0006b7 d047                      	rcall SERRD		;Get Checksum or MSByte of CRC
0006b8 f059                      	breq NAKRLY		;Timed out,Resend NAK
0006b9 9100 0133                 	lds r16,CRCFLG
0006bb 2300                      	tst r16
0006bc f041                      	breq jp35
                                 ;CRC
0006bd 1511                      	cp r17,r1		;Compare of MSByte CRC
0006be f429                      	brne NAKRLY
0006bf d03f                      	rcall SERRD		;Get LSByte CRC
0006c0 f019                      	breq NAKRLY		;Timed out,Resend NAK
0006c1 1510                      	cp r17,r0		;Compare LSByte of CRC
0006c2 f409                      	brne NAKRLY	
0006c3 c005                      	rjmp jp36
                                 	
0006c4 cfb3                      NAKRLY: rjmp NAKLP
                                 ;Checksum	
0006c5 9100 0132                 jp35:	lds r16,CHKSUM
0006c7 1710                      	cp r17,r16
0006c8 f7d9                      	brne NAKRLY
                                 
                                 ; ACK
0006c9 9180 0130                 jp36:	lds r24,PAKNUM		;Inc byte packet number
0006cb 9190 0131                 	lds r25,PAKNUM+1
0006cd 9601                      	adiw r25:r24,1
0006ce 9390 0131                 	sts PAKNUM+1,r25
0006d0 9380 0130                 	sts PAKNUM,r24	
                                 	
0006d2 7083                      	andi r24,0x03		;Check if next packet is 1
0006d3 3081                      	cpi r24,0x01		
0006d4 f409                      	brne jp37		;Write SDbuffer If buffer finished
0006d5 d083                      	rcall WRSEC		;
0006d6 e016                      jp37:	ldi r17,ACK		;Send ACK response
0006d7 cfa2                      	rjmp ACKLP		;Get next packet
                                     
0006d8 e900                      CANCEL:	ldi r16,0x90		;TI status NotReady & Error 
0006d9 bb0b                      	out PortA,r16		;	
0006da 2700                      	clr r16			;Give TI time to read status
0006db 950a                      lp35:	dec r16			;		
0006dc f7f1                      	brne lp35		;
                                 	
0006dd e016                      EXIT:	ldi r17,ACK
0006de d05f                      	rcall UARTWR    
0006df b70b                      	in r16,GICR		;Enable INT2
0006e0 6200                      	sbr r16,1<<INT2		; "
0006e1 bf0b                      	out GICR,r16		; "
                                 	
0006e2 9508                              ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; CRC-16/XMODEM
                                 ;
                                 ; On entry r17  = byte
                                 ;          r0 = old CRC low byte
                                 ;          r1 = old CRC high byte
                                 ; On exit  r0 = new CRC low byte
                                 ;          r1 = new CRC high byte
                                 ;          r17,r2 = undefined
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 CRC16:
0006e3 2511                              eor     r17,r1           
0006e4 2e11                              mov     r1,r17            
0006e5 9512                              swap    r17               
0006e6 701f                              andi    r17,0x0f          
0006e7 2511                              eor     r17,r1            
0006e8 2e11                              mov     r1,r17            
0006e9 9512                              swap    r17               
0006ea 2e21                              mov     r2,r17            
0006eb 7f10                              andi    r17,0xf0         
0006ec 2510                              eor     r17,r0 
                                 	
0006ed 931f                      	push	r17		; xch r17,r2            
0006ee 922f                      	push	r2
0006ef 911f                      	pop	r17
0006f0 902f                      	pop	r2
                                 	
0006f1 fb17                      	bst	r17,7		; rl r17
0006f2 0f11                      	lsl	r17
0006f3 f910                      	bld	r17,0
                                 	
0006f4 2e01                              mov     r0,r17            
0006f5 7e10                              andi    r17,0xe0         
0006f6 2511                              eor     r17,r1 
                                 	
0006f7 931f                      	push	r17		; xch r17,r0            
0006f8 920f                      	push	r0
0006f9 911f                      	pop	r17
0006fa 900f                      	pop	r0
                                 	
0006fb 711f                      	andi    r17,0x1f          
0006fc 2512                              eor     r17,r2            
0006fd 2e11                              mov     r1,r17            
0006fe 9508                              ret
                                 ;
                                 ;Exit r17 = byte read form USART
                                 ;Equ set if timed out
                                 ;discard nul after cr
0006ff d00e                      SERRD:	rcall UARTST		
000700 f061                      	breq jp42		;Equ set if timed out
000701 d023                      	rcall UARTRD		;data returned in r16
000702 2f10                      	MOV r17,R16
                                 	
000703 9100 0134                 	lds r16,TELFLG		;If telnet
000705 2300                      	tst r16
000706 f029                      	breq jp49
                                 	
000707 301d                      	cpi r17,0x0D		;Check 13 cr
000708 f419                      	brne JP49		;
                                 		
000709 d004                      	rcall UARTST		
00070a f011                      	breq jp42		;Equ set if timed out
00070b d019                      	rcall UARTRD		;data returned in r16
                                 	
00070c 9498                      jp49:	clz			;Clear EQU status
00070d 9508                      jp42:	ret
                                 ;
                                 ;Read USART status into r16
                                 ;
00070e e555                      UARTST:	ldi r21,85		;85=10Sec
00070f 2744                      	clr r20
000710 2733                      	clr r19
                                 	
                                 lp36:	
000711 b10a                      	in r16,UCSR0B		;Check if RXC interrupt enabled
000712 fd07                      	sbrc r16,RXCIE		;Skip if not set
000713 c004                      	rjmp jp50		;Get data from buffer
                                 	
000714 b10b                      	in r16,UCSR0A		;Get status here, Interrrupt disabled
000715 7800                      	andi r16,0x80
000716 f039                      	breq jp43		;No data
000717 c00c                      	rjmp jp44		;Data in USART
                                 	
000718 9100 012f                 jp50:	lds r16,SerCnt		;Get status here, Interrrupt enabled
00071a 3000                      	cpi r16,0
00071b f011                      	breq jp43		;No data	    
00071c ee02                      	ldi r16,226		;Data in buffer, Send status 226
00071d c006                      	rjmp jp44		;Equ not set
                                 	
                                 jp43:	
00071e 953a                      	dec r19
00071f f789                      	brne lp36
000720 954a                      	dec r20
000721 f779                      	brne lp36
000722 955a                      	dec r21
000723 f769                       	brne lp36		;Timed out, EQU set
                                     
000724 9508                      jp44:	ret
                                 ;
                                 ;Read USART data into r16
                                 ;
                                 UARTRD: 
000725 b10a                      	in r16,UCSR0B		;Check if RXC interrupt enabled
000726 fd07                      	sbrc r16,RXCIE		;Skip if not set
000727 c002                      	rjmp jp47		;Get data from buffer
000728 b10c                      	in r16,UDR		;Get data from USART
000729 c013                      	rjmp jp48
                                    
00072a 9100 012f                 jp47:	lds r16,SerCnt
00072c 3000                      	cpi r16,0
00072d f079                      	breq jp48		;Sent data from USART
00072e 950a                      	dec r16
00072f 9300 012f                 	sts SerCnt,r16
                                 	
000731 e0f1                      	ldi ZH,high(Serbuffer)
000732 e3e5                      	ldi ZL,low(Serbuffer)
000733 9100 012e                 	lds r16,SerRdPtr	;ptr Status byte
000735 0fe0                      	add ZL,r16		;Point Z to Char byte
000736 9503                      	inc r16			;ptr next entry
000737 3a00                      	cpi r16,Serbuffsize
000738 f409                      	brne jp46
000739 2700                      	clr r16
00073a 9300 012e                 jp46:	sts SerRdPtr,r16
00073c 8100                      	ld r16,Z		;Get char from buffer
                                 
00073d 9508                      jp48:	ret 
                                 ;
                                 ;Send data in r17 to USART
                                 ;Add nul after cr & 2nd ff after ff
00073e 2f01                      UARTWR:	mov r16,r17
00073f dbda                      	rcall USARTWrite	;Write data in r16 to USART
000740 9100 0134                 	lds r16,TELFLG
000742 2300                      	tst r16
000743 f041                      	breq jp41		;Return,If not Telnet
                                 	
000744 301d                      	cpi r17,0x0D		;Check 13 cr
000745 f411                      	brne JP39		;
000746 2700                      	clr r16			;Send 2nd 0x00
000747 c003                      	rjmp JP40
                                 	
000748 3f1f                      jp39:	cpi r17,0xFF		;Check 255
000749 f411                      	brne JP41		;
00074a ef0f                      	ldi r16,0xFF		;Send 2nd 0xFF
                                 	
00074b dbce                      jp40:	rcall USARTWrite	;Write data in r16 to USART
00074c 9508                      jp41:	ret
                                 ;
                                 ; Flush buffer
                                 ;	
00074d dbd0                      BUFFL:	rcall USARTFlush
00074e 2700                      	clr r16			;
00074f 9300 012e                 	sts SerRdPtr,r16	;Reset pointers
000751 9300 012d                 	sts SerWrPtr,r16
000753 9300 012f                 	sts SerCnt,r16
000755 9508                      	ret
                                 ;
                                 ; Write/Read sector to SD card
                                 ;
000756 ddef                      RDSEC:	rcall ReadMMC
000757 940c 075a                 	jmp jp38
000759 ddb9                      WRSEC:	rcall WriteMMC
                                 ;Increment arg (next sector)    
00075a e011                      jp38:   ldi r17,1	
00075b 9100 011e                 	lds r16,arg
00075d 0f01                      	add r16,r17	    ;Inc doesn't affect carry
00075e 9300 011e                 	sts arg,r16
                                 	
000760 2711                      	clr r17
000761 9100 011f                 	lds r16,arg+1
000763 1f01                      	adc r16,r17
000764 9300 011f                 	sts arg+1,r16
                                 	
000766 9100 0120                 	lds r16,arg+2
000768 1f01                      	adc r16,r17
000769 9300 0120                 	sts arg+2,r16
                                 	
00076b 9100 0121                 	lds r16,arg+3
00076d 1f01                      	adc r16,r17
00076e 9300 0121                 	sts arg+3,r16    
000770 9508                      	ret
                                 ;
                                 ;Logical shift left r25:r24 times r16
                                 ; 
                                 lsl_r25r24:
000771 0f88                      	lsl r24
000772 1f99                      	rol r25
000773 950a                      	dec r16
000774 f7e1                      	brne lsl_r25r24


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega162" register use summary:
x  :  13 y  :  12 z  :  48 r0 :  21 r1 :  18 r2 :   9 r3 :   5 r4 :   6 
r5 :   3 r6 :   2 r7 :   2 r8 :   2 r9 :   2 r10:   2 r11:   0 r12:   0 
r13:   2 r14:   2 r15:   7 r16: 586 r17: 136 r18:  18 r19:  26 r20:  16 
r21:  12 r22:   2 r23:   2 r24:  22 r25:  14 r26:  12 r27:  12 r28:  26 
r29:  27 r30:  58 r31:  55 
Registers used: 33 out of 35 (94.3%)

"ATmega162" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  19 add   :  19 adiw  :  14 and   :   0 
andi  :  12 asr   :   0 bclr  :   0 bld   :   1 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  38 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  : 109 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  :   0 cbi   :  21 cbr   :   3 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  68 cls   :   0 
clt   :   1 clv   :   0 clz   :   3 com   :   2 cp    :  10 cpc   :   0 
cpi   :  65 cpse  :   0 dec   :  43 eor   :   5 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  27 inc   :  11 jmp   :   5 
ld    :  40 ldd   :   0 ldi   : 223 lds   : 102 lpm   :   1 lsl   :   3 
lsr   :   2 mov   :  13 movw  :   3 mul   :   1 muls  :   0 mulsu :   0 
neg   :   1 nop   :   3 or    :   0 ori   :   0 out   :  28 pop   :  28 
push  :  32 rcall : 195 ret   :  51 reti  :   2 rjmp  :  58 rol   :   4 
ror   :   4 sbc   :   0 sbci  :   0 sbi   :  14 sbic  :   8 sbis  :   7 
sbiw  :   4 sbr   :   7 sbrc  :   8 sbrs  :   8 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   2 ses   :   0 set   :   1 sev   :   0 
sez   :   2 sleep :   0 spm   :   0 st    :  23 std   :   0 sts   : 181 
sub   :   2 subi  :   0 swap  :   2 tst   :   7 wdr   :   0 
Instructions used: 59 out of 113 (52.2%)

"ATmega162" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000eec   3676     44   3720   16384  22.7%
[.dseg] 0x000100 0x0004d5      0    981    981    1024  95.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
