
AVRASM ver. 2.2.8  C:\Users\denni\Documents\Microchip Studio\7.0\TI_SD_Disk_Atmega162\TI_SD_Disk_Atmega162\main.asm Mon Aug 09 09:41:15 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m162def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m162def.inc'
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega162.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m162def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega162
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega162
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M162DEF_INC_
                                 #define _M162DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega162
                                 #pragma AVRPART ADMIN PART_NAME ATmega162
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x94
                                 .equ	SIGNATURE_002	= 0x04
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	UBRR1H	= 0x3c
                                 .equ	UCSR1C	= 0x3c
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	EMCUCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	TCCR2	= 0x27
                                 .equ	ASSR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	TCNT2	= 0x23
                                 .equ	OCR2	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRR0H	= 0x20
                                 .equ	UCSR0C	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	PORTE	= 0x07
                                 .equ	DDRE	= 0x06
                                 .equ	PINE	= 0x05
                                 .equ	OSCCAL	= 0x04
                                 .equ	OCDR	= 0x04
                                 .equ	UDR1	= 0x03
                                 .equ	UCSR1A	= 0x02
                                 .equ	UCSR1B	= 0x01
                                 .equ	UBRR1L	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 3	; Force Output Compare for Channel A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select1 bit 0
                                 .equ	CS11	= 1	; Clock Select1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Pulse Width Modulator Select Bit 1
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Forde Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE2	= 2	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 4	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 2	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 4	; Output Compare Flag 2
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 3B
                                 .equ	OCF3A	= 4	; Output Compare Flag 3A
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	WGM31	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	FOC3B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC3A	= 3	; Force Output Compare for Channel A
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select3 bit 0
                                 .equ	CS31	= 1	; Clock Select3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	WGM33	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR	= UDR0	; For compatibility
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	USR	= UCSR0A	; For compatibility
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	U2X	= U2X0	; For compatibility
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	DOR	= DOR0	; For compatibility
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	FE	= FE0	; For compatibility
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	UDRE	= UDRE0	; For compatibility
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	TXC	= TXC0	; For compatibility
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 .equ	RXC	= RXC0	; For compatibility
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	UCR	= UCSR0B	; For compatibility
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	TXB8	= TXB80	; For compatibility
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	RXB8	= RXB80	; For compatibility
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	TXEN	= TXEN0	; For compatibility
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	RXEN	= RXEN0	; For compatibility
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	UDRIE	= UDRIE0	; For compatibility
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	TXCIE	= TXCIE0	; For compatibility
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 .equ	RXCIE	= RXCIE0	; For compatibility
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UBRRHI	= UCSR0C	; For compatibility
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 .equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 ;.equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= UBRR0L	; For compatibility
                                 .equ	UBRR	= UBRR0L	; For compatibility
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART1 I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART1 I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART1 I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART1 I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART1 I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART1 I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART1 I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART1 I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	CHR91	= UCSZ12	; For compatibility
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 .equ	URSEL1	= 7	; Register Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Highg Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ;.equ	UBRR1	= UBRR1L	; For compatibility
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 1
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SM	= SM1	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRW	= SRW10	; For compatibility
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	SM2	= 5	; Sleep Mode Select Bit 2
                                 .equ	JDT	= 7	; JTAG Interface Disable
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 .equ	ISC2	= 0	; Interrupt Sense Control 2
                                 .equ	SRW11	= 1	; Wait State Select Bit 1 for Upper Sector
                                 .equ	SRW00	= 2	; Wait State Select Bit 0 for Lower Sector
                                 .equ	SRW01	= 3	; Wait State Select Bit 1 for Lower Sector
                                 .equ	SRL0	= 4	; Wait State Sector Limit Bit 0
                                 .equ	SRL1	= 5	; Wait State Sector Limit Bit 1
                                 .equ	SRL2	= 6	; Wait State Sector Limit Bit 2
                                 .equ	SM0	= 7	; Sleep mode Select Bit 0
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 
                                 ; CLKPR - Clock prescale register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR310	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSR310	; For compatibility
                                 .equ	PSR0	= PSR310	; For compatibility
                                 .equ	PSR1	= PSR310	; For compatibility
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	XMM0	= 3	; External Memory High Mask Bit 0
                                 .equ	XMM1	= 4	; External Memory High Mask Bit 1
                                 .equ	XMM2	= 5	; External Memory High Mask Bit 2
                                 .equ	XMBK	= 6	; External Memory Bus Keeper Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter 0 Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter 0 Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Timer/Counter 0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0	= 0	; Timer/Counter0 Output Compare Match Interrupt register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0	= 0	; Output Compare Flag 0
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 ;.equ	ISC2	= 0	; Interrupt Sense Control 2
                                 
                                 ; GICR - General Interrupt Control Register
                                 .equ	EIMSK	= GICR	; For compatibility
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PCIE0	= 3	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 4	; Pin Change Interrupt Enable 1
                                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	PCIF0	= 3	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 4	; Pin Change Interrupt Flag 1
                                 .equ	INTF2	= 5	; External Interrupt Flag 2
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 1	; Brown out detector trigger level
                                 .equ	BODLEVEL1	= 2	; Brown out detector trigger level
                                 .equ	BODLEVEL2	= 3	; Brown out detector trigger level
                                 .equ	M161C	= 4	; ATMega 161 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x04ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 16384
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1c00
                                 .equ	NRWW_STOP_ADDR	= 0x1fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1bff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x1f80
                                 .equ	SECONDBOOTSTART	= 0x1f00
                                 .equ	THIRDBOOTSTART	= 0x1e00
                                 .equ	FOURTHBOOTSTART	= 0x1c00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	PCI0addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	ICP3addr	= 0x000c	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x000e	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0010	; Timer/Counter3 Compare Match B
                                 .equ	OVF3addr	= 0x0012	; Timer/Counter3 Overflow
                                 .equ	OC2addr	= 0x0014	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0016	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0018	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x001a	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001c	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001e	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x0020	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0022	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0024	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0026	; USART0, Rx Complete
                                 .equ	URXC1addr	= 0x0028	; USART1, Rx Complete
                                 .equ	UDRE0addr	= 0x002a	; USART0 Data register Empty
                                 .equ	UDRE1addr	= 0x002c	; USART1, Data register Empty
                                 .equ	UTXC0addr	= 0x002e	; USART0, Tx Complete
                                 .equ	UTXC1addr	= 0x0030	; USART1, Tx Complete
                                 .equ	ERDYaddr	= 0x0032	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0034	; Analog Comparator
                                 .equ	SPMRaddr	= 0x0036	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 56	; size in words
                                 
                                 #endif  /* _M162DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 ;    TI SD Disk.asm
                                 ;
                                 ; Created: 1/1/2019 3:45:02 PM
                                 ; Author : Dennis Hatton
                                 ;
                                 ; Fuses FF D9 FF
                                 ; 16mhz ext crystal
                                 ;
                                 ;   Atmega8515 Converted to Atmega162		
                                 ;    PortA	PortB	    Portc	PortD	    PortE			
                                 ;    0<Data0	0<A0	    0>Data0	0<RXD	    0<!INT2			
                                 ;    1<Data1	1<A1	    1>Data1	1>TXD	    1<!WE		
                                 ;    2<Data2	2<	    2>Data2	2<	    2>!ready			
                                 ;    3<Data3	3<	    3>Data3	3>HLD			
                                 ;    4<Data4	4>CS	    4>Data4	4<Drive1
                                 ;    5<Data5	5>MOSI	    5>Data5	5<Drive2    
                                 ;    6<Data6	6<MISO	    6>Data6	6<Drive3
                                 ;    7<Data7	7>SCK	    7>Data7	7<Side   
                                 ;
                                 ; IN PINx
                                 ; OUT PORTx
                                 ; OUT PINx turns on pullup						
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
                                 
                                 			
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Equates
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PortE bits
                                 			.equ intbit = PE0
                                 			.equ webit = PE1
                                 			.equ rdybit = PE2
                                 			
                                 ; Dedicated registers			
                                 ; INT2:	XL XH r13 r14			
                                 ; SD error count: r10			
                                 ; Save arg: r6-r9
                                 ;			
                                 		
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.DSEG
                                 fdcRegisters:
000100                           fdcStatus:	.byte 1			;TI 5FF0 Read Status
000101                           fdcTrack:	.byte 1			;TI 5FF2/5FFA Rd/Wr Track Register
000102                           fdcSector:	.byte 1			;TI 5FF4/5FFC Rd/Wr Sector Register
000103                           fdcData:	.byte 1			;TI 5FF6/5FFE Rd/Wr Data Register
000104                           fdcCommand:	.byte 1			;TI 5FF8 Write Command Register
000105                           fdcSide:	.byte 1			;	
                                 
000106                           flags:		.byte 1			;flags + address
                                 			.equ iflag = 7	;1 int occured
                                 			.equ wflag = 2	;1 write occured
                                 
000107                           DSK1address:	.byte	4	;LSB -- MSB			
00010b                           DSK2address:	.byte	4	;LSB -- MSB
00010f                           DSK3address:	.byte	4	;LSB -- MSB
000113                           DSK1LastTrk:	.byte	1
000114                           DSK2LastTrk:	.byte	1
000115                           DSK3LastTrk:	.byte	1
000116                           TIlowbyte:	.byte	1
                                 	
                                 	
                                 ;SD variables
                                 		.equ CS = PB4
000117                           ocr:		.byte	1
                                 		.equ ccs = 6	;bit 6
000118                           cmd:		.byte	1
000119                           arg:		.byte	4	;LSB -- MSB		
00011d                           crc:		.byte	1
00011e                           resp:		.byte	1
                                 
                                 SectorsPerCluster:		;in Powers of 2 (Number of left shifts to use)
00011f                           		.byte	1
000120                           Offset:		.byte	4	;LSB -- MSB	
000124                           StartSector:	.byte	2
000126                           StepSectors:	.byte	2
                                 	
000128                           SerWrPtr:	.byte	1
000129                           SerRdPtr:	.byte	1
00012a                           SerCnt:		.byte	1
                                 VAR_END:	
                                 	
                                 		.equ Serbuffsize = 160
00012b                           Serbuffer:	.byte	Serbuffsize
0001cb                           TIbuffer:	.byte	256
0002cb                           SDbuffer:	.byte	512
                                 	
                                 ;Stack area	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Interrupts vector tables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 	.CSEG		;8515 use rjmp 162 use jmp
                                 	.org $000
000000 940c 00e6                 	jmp setup	;Reset Handler
                                 	.org URXC0addr	;8515 URXCaddr,162 URXC0addr
000026 940c 0054                 	jmp USART_RXC	;USART RX Complete Handler  
                                 	.org INT2addr
000006 940c 0038                 	jmp EXT_INT2	;IRQ2 Handler
                                 	
                                 
                                 ;Interrupt Service Routines
                                 	.org INT_VECTORS_SIZE		;End of Int vector table
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; IRQ2 Interrupt Handler
                                 ; XH XL r13 r14 r15 not saved
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; cycle = 62.5ns
                                 EXT_INT2:
000038 b6df                          	in r13,SREG			;Save SREG			1
000039 2ee0                      	mov r14,r16			;				1
00003a b306                      	in r16,PinB			;Get FDC address		1
00003b 7003                      	andi r16,0x03			;				1
00003c 24ff                      	clr r15				;				1								
00003d e0b1                      	ldi XH,high(fdcRegisters)	;Point X to FDC_Registers base	1
00003e e0a0                      	ldi XL,low(fdcRegisters)	; "				1
00003f 0fa0                      	add XL,r16			;add FDC address offset		1
000040 1dbf                      	adc XH,r15			; "				1
000041 90fc                      	ld r15,X			;Get data in FDC register	2
000042 bafb                      	out PortA,r15			;Send it to TI			1
000043 6800                      	sbr r16,1<<iflag		;Set our interrupt flag		1
000044 0000                      	nop				;				1
000045 0000                      	nop				;				1
                                  ;Need 13-19 cycles to here,Min 15 without errors			15
                                 	
000046 9929                      	sbic PinE,webit		;Test !we
000047 c007                      	rjmp isr2end			;Read if 1
000048 b2f3                      	in r15,PinC			;Get  write data
000049 94f0                      	com r15				;TI sends inverted data
00004a 6004                      	sbr r16,1<<wflag		;Set write flag
00004b 3804                      	cpi r16,0x84			;Check If Command
00004c f409                      	brne NotCMD			; "
00004d 9614                      	adiw X,4			;Point to Command registers
                                 NotCMD:	
00004e 92fc                      	st X,r15			;Write data to FDC register
                                 isr2end:
00004f 9300 0106                 	sts flags,r16			;
000051 2d0e                      	mov r16,r14			;
000052 bedf                      	out SREG,r13			;Restore SREG	
000053 9518                      	reti
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; USART RX Complete Interrupt Handler	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 USART_RXC:
000054 930f                      	push r16
000055 b70f                      	in r16,SREG	;Push SREG
000056 930f                      	push r16	; "
000057 93ff                      	push ZH
000058 93ef                      	push ZL
                                 	
                                 ;Move Stat & Char to buffer
000059 9100 012a                 	lds r16,SerCnt
00005b 9503                      	inc r16
00005c 9300 012a                 	sts SerCnt,r16
                                 
00005e e0f1                      	ldi ZH,high(Serbuffer)
00005f e2eb                      	ldi ZL,low(Serbuffer)
000060 9100 0128                 	lds r16,SerWrPtr
000062 0fe0                      	add ZL,r16		;
                                 ;	clr r17
                                 ;	adc ZH,r17
                                 	
000063 9503                      	inc r16
000064 3a00                      	cpi r16,Serbuffsize		;
000065 f409                      	brne jp00
000066 2700                      	clr r16
000067 9300 0128                 jp00:	sts SerWrPtr,r16
                                 
                                 ;	in r16,UCSR0A		;Get status
                                 ;	st Z+,r16		;Put in buffer
000069 b10c                      	in r16,UDR		;Get data (We know data is there because of Recv interrupt)
00006a 8300                      	st Z,r16		;Put in buffer
                                 	
                                 ;Check If AT+#xCRLF is in buffer (x is Char used below)
00006b 300a                      	cpi r16,10	;check if LF
00006c f469                      	brne jp09
                                 	
00006d 9102                      	ld r16,-Z
00006e 300d                      	cpi r16,13	;check if CR
00006f f451                      	brne jp09
                                 
000070 9734                      	sbiw Z,4
000071 9101                      	ld r16,Z+
000072 3401                      	cpi r16,'A'	;
000073 f431                      	brne jp09
                                 
000074 9101                      	ld r16,Z+
000075 3504                      	cpi r16,'T'	;	
000076 f419                      	brne jp09
                                 
000077 9101                      	ld r16,Z+
000078 3203                      	cpi r16,'#'	;
000079 f011                      	breq jp08
00007a 940c 00ca                 jp09:	jmp RXCrtn
                                  
00007c 8100                      jp08:	ld r16,Z	; 
                                 
00007d 93df                      	push YH
00007e 93cf                      	push YL
00007f 93bf                      	push XH
000080 93af                      	push XL
000081 939f                      	push r25
000082 938f                      	push r24
000083 937f                      	push r23
000084 936f                      	push r22
000085 935f                      	push r21
000086 934f                      	push r20
000087 933f                      	push r19
000088 932f                      	push r18
000089 931f                      	push r17
                                 	
00008a 3502                      chkR:	cpi r16,'R'		    ;Send reg 16-31,SREG,Ret PC
00008b f429                      	brne chkS
00008c b7fe                      	in ZH,SPH
00008d b7ed                      	in ZL,SPL
00008e 9631                      	adiw Z,1
00008f e113                      	ldi r17,19
000090 c026                      	rjmp TXLP0
                                 	
000091 3503                      chkS:	cpi r16,'S'		    ;Send all calls on stack
000092 f439                      	brne chkB
000093 b7fe                      	in ZH,SPH
000094 b7ed                      	in ZL,SPL
000095 9671                      	adiw Z,17
000096 ef1f                      	ldi r17,low(RAMEND)
000097 1b1e                      	sub r17,ZL
000098 9631                      	adiw Z,1
000099 c01d                      	rjmp TXLP0
                                 	
00009a 3402                      chkB:	cpi r16,'B'		    ;Send Serial buffer
00009b f421                      	brne chkT
00009c ea10                      	ldi r17,Serbuffsize
00009d e0f1                      	ldi ZH,high(Serbuffer)	    ; Get address to Serial buffer
00009e e2eb                      	ldi ZL,low(Serbuffer)	    ; "
00009f c017                      	rjmp TXLP0
                                 	
0000a0 3504                      chkT:	cpi r16,'T'		    ;Send TIbuffer
0000a1 f421                      	brne chkU
0000a2 2711                      	clr r17
0000a3 e0f1                      	ldi ZH,high(TIbuffer)	    ;Point to TIbuffer
0000a4 eceb                      	ldi ZL,low(TIbuffer)	    ; "
0000a5 c011                      	rjmp TXLP0
                                 	
0000a6 3505                      chkU: 	cpi r16,'U'		    ;Send upper 256 bytes of SDbuffer
0000a7 f421                      	brne chkL
0000a8 2711                      	clr r17
0000a9 e0f2                      	ldi ZH,high(SDbuffer)	    ;Point to SDbuffer
0000aa eceb                      	ldi ZL,low(SDbuffer)	    ; "
0000ab c00b                      	rjmp TXLP0
                                 	
0000ac 340c                      chkL: 	cpi r16,'L'		    ;Send lower 256 bytes of SDbuffer
0000ad f421                      	brne chkV
0000ae 2711                      	clr r17
0000af e0f3                      	ldi ZH,high(SDbuffer+128)   ;Point to lower SDbuffer
0000b0 e4eb                      	ldi ZL,low(SDbuffer+128)    ; "
0000b1 c005                      	rjmp TXLP0
                                 	
0000b2 3506                      chkV: 	cpi r16,'V'	;Send all sram (variables) except buffers
0000b3 f449                      	brne jp13
0000b4 e21b                      	ldi r17,VAR_END-SRAM_START  ;Count between fdcRegisters & buffers
0000b5 e0f1                      	ldi ZH,high(SRAM_START)	    ; Get sram start address
0000b6 e0e0                      	ldi ZL,low(SRAM_START)	    ; "
                                 	
0000b7 9101                      TXLP0:	ld r16,Z+
0000b8 9b5d                      lp08:	sbis UCSR0A,UDRE	;Wait until transmit is ready
0000b9 cffe                      	rjmp lp08
0000ba b90c                      	out UDR,r16		;Send data
0000bb 951a                      	dec R17
0000bc f7d1                      	brne TXLP0
                                 	
0000bd 911f                      jp13:	pop r17
0000be 912f                      	pop r18
0000bf 913f                      	pop r19
0000c0 914f                      	pop r20
0000c1 915f                      	pop r21
0000c2 916f                      	pop r22
0000c3 917f                      	pop r23
0000c4 918f                      	pop r24
0000c5 919f                      	pop r25
0000c6 91af                      	pop XL
0000c7 91bf                      	pop XH
0000c8 91cf                      	pop YL
0000c9 91df                      	pop YH
                                 	
0000ca 91ef                      RXCrtn:	pop ZL
0000cb 91ff                      	pop ZH
0000cc 910f                      	pop r16		;pop SREG
0000cd bf0f                       	out SREG,r16	; "
0000ce 910f                      	pop r16
0000cf 9518                        	reti
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Constants
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Use to access program memory	
                                 ; ldi ZH,high(hello<<1)	;Shift (address*2) because program memory is 16 bits
                                 ; ldi ZL,low(hello<<1)	;When address bit0 is 0 low byte of word is accessed
                                 ; lpm r16,Z+		;When address bit0 is 1 high byte of word is accessed
                                 ;			;Effectively changing to byte access
                                 ;hello:
                                 ;	.db "HELLO",0
0000d0 76eb
0000d1 4590
0000d2 4658
0000d3 5441
0000d4 00ff                      EXFATstr: .db 0xEB,0x76,0x90,"EXFAT",0xFF,0 ;make even bytes
0000d5 00c1
0000d6 0056
0000d7 004f
0000d8 004c
0000d9 0055
0000da 004d
0000db 0045
0000dc ff53                      VOLstr:	.db 0xC1,0,'V',0,'O',0,'L',0,'U',0,'M',0,'E',0,'S',0xFF
0000dd 00c1
0000de 0054
0000df 0049
0000e0 0056
0000e1 004f
0000e2 004c
0000e3 0030
0000e4 0030
0000e5 ff30                      TIVOLstr: .db 0xC1,0,'T',0,'I',0,'V',0,'O',0,'L',0,'0',0,'0',0,'0',0xFF
                                  
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Setup
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 setup:
0000e6 ef0f                      	ldi r16,low(RAMEND)		;Init stack
0000e7 bf0d                      	out spl,r16			;	"
0000e8 e004                      	ldi r16,high(RAMEND)		;	"
0000e9 bf0e                      	out sph,r16			;	"
                                 ;Setup ports
0000ea ef0f                      	ser	r16			;PortA (FF) output mode for TI read
0000eb bb0a                      	out DDRA,r16			; "
0000ec 2700                      	clr	r16			;PortC (00) input mode for TI write
0000ed bb04                      	out DDRC,r16			; "
0000ee eb00                      	ldi	r16,0b10110000		;SCK,MI,MO,CS,0,0,A1,A0
0000ef bb07                      	out DDRB,r16			;O  ,I ,O ,O ,I,I,I ,I
0000f0 9ac6                      	sbi PortB,PB6			;Pullup MISO
0000f1 e00a                      	ldi	r16,0b00001010		;Side,DR3,DR2,DR1,HLD,0,TDX,RXD
0000f2 bb01                      	out DDRD,r16			;I   ,I  ,I  ,I  ,O  ,I,O  ,I
0000f3 e004                      	ldi	r16,0b00000100		;0,0,0,0,0,!Ready,!WE,!INT
0000f4 b906                      	out DDRE,r16			;I,I,I,I,I,O     ,I  ,I
0000f5 983a                      	cbi PortE,rdybit		;Ready to TI
                                 
0000f6 b706                      	in r16,EMCUCR			;Set INT2 falling edge trigger
0000f7 7f0e                      	cbr r16,1<<ISC2		; " ISC2=bit0 same as andi r16,0xFE
0000f8 bf06                      	out EMCUCR,r16			; "
0000f9 b70b                      	in r16,GICR			;Enable INT2
0000fa 6200                      	sbr r16,1<<INT2		; " INT2=bit5 same as ori r16,32
0000fb bf0b                      	out GICR,r16			; "	
                                 ;Set status				;NotReady  track0  busy
0000fc e004                      	ldi r16,0x04			;b7=0      b3=1    b0=0
0000fd 9300 0100                 	sts fdcStatus,r16		;
0000ff 2700                      	clr r16				; 
000100 9300 0101                 	sts fdcTrack,r16		;
000102 9300 0102                 	sts fdcSector,r16		;
000104 9300 0103                 	sts fdcData,r16		;
000106 9300 0104                 	sts fdcCommand,r16		;
000108 9893                      	cbi PortD,3			;data not ready
                                 ;Setup USART				;baud @ 16MHz
000109 e010                      	ldi r17,0			;230.4k=0,3 115.2k=0,8(double 8&16)
00010a e008                      	ldi r16,8			;Disabled doubling
00010b d1e1                      	rcall USARTInit	
00010c b10a                      	in r16,UCSR0B			;Enable RXC interrupt
00010d 6800                      	sbr r16,1<<RXCIE		; "
00010e b90a                      	out UCSR0B,r16			; "	
                                 ;Setup SPI
00010f e100                      	ldi r16,16
000110 2ea0                      	mov r10,r16			;SD error count,So it doesn't run away
000111 d234                      	rcall SPIInit  
000112 d30c                      	rcall MMCInit
                                 ;Setup Drives	
                                 SetupStartStep:  
000113 d23f                      	rcall FindTIVOL		;Find TIVOL000,Save Start and Step
000114 f019                      	breq SetupDSK
000115 e800                      	ldi r16,0x80		;disk error,not ready
000116 9300 0100                 	sts fdcStatus,r16	;
                                 ;Get DSKx addresses from SD sector 1    
                                 SetupDSK:
000118 e001                      	ldi r16,0x01
000119 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
00011b 2700                       	clr r16
00011c 9300 011a                 	sts arg+1,r16
00011e 9300 011b                 	sts arg+2,r16
000120 9300 011c                 	sts arg+3,r16		; (MSB)
000122 d3fb                      	rcall ReadMMC           ; First half 512 sector (uses ZL & ZH)
                                 	
                                 ;XL & XH ok to use before interrupts are enabled    	
000123 ecef                      	ldi ZL,low(SDbuffer+4)	    ;
000124 e0f2                      	ldi ZH,high(SDbuffer+4)	    ;
                                 
000125 9101                      	ld r16,Z+		    ;Get Drive 1 Disk #
000126 930f                      	push r16		    ;		    
000127 9101                      	ld r16,Z+		    ;Get Drive 2 Disk #
000128 930f                      	push r16		    ;
000129 9101                      	ld r16,Z+		    ;Get Drive 3 Disk #
00012a 930f                      	push r16
                                 	
00012b e0cf                      	ldi YL,low(DSK3address)    ;
00012c e0d1                      	ldi YH,high(DSK3address)   ;
                                 	
00012d e023                      	ldi r18,3
00012e 915f                      lp02:	pop r21			    ;Restore disk number (stepping 3 - 1)
00012f d19f                      	rcall Disk2Sector	    ;Convert disk # to sector address
000130 9209                      	st Y+,r0		    ;Save into DSKXaddress
000131 9219                      	st Y+,r1		    ;
000132 9229                      	st Y+,r2		    ;
000133 9239                      	st Y+,r3		    ;
000134 9728                      	sbiw Y,8		    ;Back to start of current drive + start preceding drive
000135 952a                      	dec r18			    ;
000136 f7b9                      	brne lp02		    ;All 3 drives done 
                                 	
                                 ;Set last track for drives
000137 e0e7                      	ldi ZL,low(DSK1address)    ;LSB -- MSB
000138 e0f1                      	ldi ZH,high(DSK1address)   ;
000139 e1c9                      	ldi YL,low(arg)	    ;
00013a e0d1                      	ldi YH,high(arg)	    ;
00013b d45b                      	rcall mov4		    ;
00013c d3e1                      	rcall ReadMMC 		    ;First half 512 sector (uses ZL & ZH)
00013d e207                      	ldi r16,39
00013e 9110 02d5                 	lds r17,SDbuffer+10
000140 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000141 e40f                      	ldi r16,79
000142 9300 0113                 	sts DSK1LastTrk,r16
                                 	
000144 e0eb                      	ldi ZL,low(DSK2address)    ;LSB -- MSB
000145 e0f1                      	ldi ZH,high(DSK2address)   ;
000146 e1c9                      	ldi YL,low(arg)	    ;
000147 e0d1                      	ldi YH,high(arg)	    ;
000148 d44e                      	rcall mov4		    ;
000149 d3d4                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
00014a e207                      	ldi r16,39
00014b 9110 02d5                 	lds r17,SDbuffer+10
00014d fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
00014e e40f                      	ldi r16,79
00014f 9300 0114                 	sts DSK2LastTrk,r16
                                 	
000151 e0ef                      	ldi ZL,low(DSK3address)    ;LSB -- MSB
000152 e0f1                      	ldi ZH,high(DSK3address)   ;
000153 e1c9                      	ldi YL,low(arg)	    ;
000154 e0d1                      	ldi YH,high(arg)	    ;
000155 d441                      	rcall mov4		    ;
000156 d3c7                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
000157 e207                      	ldi r16,39
000158 9110 02d5                 	lds r17,SDbuffer+10
00015a fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
00015b e40f                      	ldi r16,79
00015c 9300 0115                 	sts DSK3LastTrk,r16
                                 	
                                 ;Enable interrupts	
00015e 2700                      	clr r16				;Clear flags
00015f 9300 0106                 	sts flags,r16			;
000161 9300 0129                 	sts SerRdPtr,r16		;Init Serial pointers
000163 9300 0128                 	sts SerWrPtr,r16
000165 9300 012a                 	sts SerCnt,r16
000167 9478                      	sei				;Global enable interrupts
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Main Loop
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000168 2700                      main:	clr r16			    ; Clear busy,No errors	
000169 9300 0100                 jp02:	sts fdcStatus,r16	    ; "	     
00016b 983a                      	cbi PortE,2		    ;Release TI
                                 	
00016c 9100 0106                 lp00:	lds r16,flags		    ;Get flags
00016e ff07                      	sbrs r16,iflag		    ;Has TI has sent data?
00016f cffc                      	rjmp lp00
000170 2711                      	clr r17			    ;Clear flags
000171 9310 0106                 	sts flags,r17		    ; "		    
                                 	
000173 9100 0104                 	lds r16,fdcCommand	    ;
000175 3000                      	cpi r16,0x00		    ;
000176 f3a9                      	breq lp00
                                 	
000177 9a3a                      	sbi PortE,2		    ;Put TI on hold while process command
000178 9310 0104                 	sts fdcCommand,r17	    ;Clear command (r17=0 from above)
                                 ;	ldi r17,0x01		    ;Set Busy bit
                                 ;	sts fdcStatus,r17	    ; "
                                 	
                                 ;	rcall USARTWrite	    ;Send command in r16 (enable for debbuging)
                                 	
                                 ;Our Mount Disk command	
                                 fdcCMD81:			    	
00017a 3801                      	cpi r16,0x81		   
00017b f411                      	brne fdcCMD82
00017c d135                      	rcall ChgDisk
00017d cf9a                      	rjmp SetupDSK		    ;Setup disk addresses and last track
                                 ;Our Send all disk names command		
                                 fdcCMD82:			    
00017e 3802                      	cpi r16,0x82		    
00017f f411                      	brne usartCMD83
000180 d10a                      	rcall SendNames
000181 cfe6                      	rjmp main
                                 ;Read Usart status
                                 usartCMD83:			    
000182 3803                      	cpi r16,0x83		    
000183 f411                      	brne usartCMD84
000184 d17b                      	rcall TIrdUsartStat
000185 cfe2                      	rjmp main
                                 ;Read Usart data
                                 usartCMD84:			    
000186 3804                      	cpi r16,0x84		    
000187 f411                      	brne usartCMD85
000188 d182                      	rcall TIrdUsartData
000189 cfde                      	rjmp main
                                 ;Write Usart data
                                 usartCMD85:			    
00018a 3805                      	cpi r16,0x85		    
00018b f411                      	brne usartCMD86
00018c d197                      	rcall TIwrUsartData
00018d cfda                      	rjmp main
                                 ;Usart Sub Command
                                 usartCMD86:			    
00018e 3806                      	cpi r16,0x86		    
00018f f411                      	brne fdcCMD0A
000190 d199                      	rcall TIwrUsartSub
000191 cfd6                      	rjmp main
                                 ;0A Restore (h=1,V=0,r0r1=10)	
                                 fdcCMD0A:			   
000192 300a                      	cpi r16,0x0A		    ;
000193 f439                      	brne fdcCMD1E
000194 2700                      	clr r16			    ;
000195 9300 0101                 	sts fdcTrack,r16	    ;Set to track 0
000197 9300 0102                 	sts fdcSector,r16	    ;Set to sector 0
000199 6004                      	sbr r16,0x04		    ;Set track 0 in status
00019a cfce                      	rjmp jp02
                                 ;1E Seek h=1 V=1 r1r0=10
                                 fdcCMD1E:			    
00019b 310e                      	cpi r16,0x1E		    ;
00019c f429                      	brne fdcCMD5A
00019d 9100 0103                 	lds r16,fdcData
00019f 9300 0101                 	sts fdcTrack,r16
0001a1 cfc6                      	rjmp main
                                 ;2x Step not used by TI
                                 ;5A Step-in T=1,h=1,V=0,r0r1=10	
                                 fdcCMD5A:			    
0001a2 350a                      	cpi r16,0x5A		    ;
0001a3 f431                      	brne fdcCMD88
0001a4 9100 0101                 	lds r16,fdcTrack
0001a6 9503                      	inc r16
0001a7 9300 0101                 	sts fdcTrack,r16
0001a9 cfbe                      	rjmp main
                                 ;6x Step-out not used by TI
                                 ;88 Read sector m=0 S=1 E=0 C=0		    
                                 fdcCMD88:			    
0001aa 3808                         	cpi r16,0x88		    ;
0001ab f411                      	brne fdcCMDA8
0001ac d042                      	rcall TIreadsec
0001ad cfba                      	rjmp main
                                 ;A8 Write sector m=0 S=1 E=0 C=0 a=0
                                 fdcCMDA8:			    
0001ae 3a08                      	cpi r16,0xA8		    ;
0001af f411                      	brne fdcCMDC0
0001b0 d02b                      	rcall TIwritesec
0001b1 cfb6                      mainRLY: rjmp main
                                 ;C0 Read ID E=0
                                 fdcCMDC0:			    
0001b2 3c00                      	cpi r16,0xC0		    ;
0001b3 f411                      	brne fdcCMDF4
0001b4 d009                      	rcall TIreadID
0001b5 cfb2                      	rjmp main
                                 ;Ex Read track not used by TI
                                 ;F4 Write track (E=1)
                                 fdcCMDF4:			    
0001b6 3f04                          	cpi r16,0xF4		    ;
0001b7 f411                      	brne fdcCMDD0
0001b8 d0ac                      	rcall TIwritetrack
0001b9 cff7                      	rjmp mainRLY
                                 ;D0 Force interrupt
                                 fdcCMDD0:			    
0001ba 3d00                          	cpi r16,0xD0		    ;Sent after software reset (FTCN =)
0001bb f7a9                      	brne mainRLY
0001bc d392                      	rcall delay1ms
0001bd cf5a                      	rjmp SetupDSK		    ;Setup disks in case one was formatted
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadID:
0001be 983a                      	cbi PortE,2		;Release TI
0001bf 9100 0101                 	lds r16,fdcTrack	;Get track
0001c1 9300 0103                 	sts fdcData,r16		;Send to TI
0001c3 d072                      	rcall WaitTIread	; "
0001c4 2700                      	clr r16			;Side 0
0001c5 9987                      	sbic PinD,7		;Get Side
0001c6 9503                      	inc r16			;Side 1
0001c7 9300 0103                 	sts fdcData,r16		;Send to TI
0001c9 d06c                      	rcall WaitTIread	; "
0001ca 9100 0102                 	lds r16,fdcSector	;Get sector
0001cc 9300 0103                 	sts fdcData,r16		;Send to TI
0001ce d067                      	rcall WaitTIread	; "
0001cf 2700                      	clr r16			;Sector lenght code?
0001d0 9300 0103                 	sts fdcData,r16		;Send to TI
0001d2 d063                      	rcall WaitTIread	; "
0001d3 2700                      	clr r16			;CRC byte1
0001d4 9300 0103                 	sts fdcData,r16		;Send to TI
0001d6 d05f                      	rcall WaitTIread	; "
0001d7 2700                      	clr r16			;CRC byte2
0001d8 9300 0103                 	sts fdcData,r16		;Send to TI
0001da d05b                      	rcall WaitTIread	; "
0001db 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritesec:
0001dc e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
0001dd eceb                      	ldi ZL,low(TIbuffer)	; "
0001de e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001df 983a                      	cbi PortE,2		;Release TI
0001e0 d05f                      lp24:	rcall WaitTIwrite	;Wait for data from TI
0001e1 9100 0103                 	lds r16,fdcData	;Get next byte
0001e3 9301                      	st Z+,r16		;Save to buffer
0001e4 952a                      	dec r18
0001e5 f7d1                      	brne lp24
                                 	
0001e6 9a3a                      	sbi PortE,2		;Put TI on hold while process command
0001e7 e001                      	ldi r16,1
0001e8 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
0001e9 2700                      	clr r16
0001ea 9300 0105                 	sts fdcSide,r16
0001ec d014                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001ed d06b                      	rcall TI_SD_wr		;Write to SD
0001ee 9508                      	ret	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadsec:
0001ef e001                      	ldi r16,1
0001f0 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
0001f1 2700                      	clr r16
0001f2 9300 0105                 	sts fdcSide,r16
0001f4 d00c                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001f5 d054                      	rcall TI_SD_rd		;Get sector from SD
0001f6 e0f1                      	ldi ZH,high(TIbuffer)	; Get address to buffer
0001f7 eceb                      	ldi ZL,low(TIbuffer)	; "
0001f8 e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001f9 983a                      	cbi PortE,2		;Release TI
0001fa 9101                      lp13:	ld r16,Z+		;Get next byte
0001fb 9300 0103                 	sts fdcData,r16		;Send to TI
0001fd d038                      	rcall WaitTIread	; "
0001fe 952a                      	dec r18
0001ff f7d1                      	brne lp13
000200 9508                      	ret
                                 ;	
                                 ;Convert TI track&sector to SD sector	
                                 Track2Arg:
000201 9100 0101                 	lds r16,fdcTrack
000203 9110 0105                 	lds r17,fdcSide
000205 ff10                      	sbrs r17,0		;Test bit,Skip if side 1	
000206 c00c                      	rjmp jp10
000207 9110 0113                 	lds r17,DSK1LastTrk	;
000209 9985                      	sbic PinD,5		;
00020a 9110 0114                 	lds r17,DSK2LastTrk	;
00020c 9986                      	sbic PinD,6		;
00020d 9110 0115                 	lds r17,DSK3LastTrk	;
00020f 1b01                      	sub r16,R17		;Reverse track (0=-39 or -79) 
000210 9501                      	neg r16			;Make postive
000211 9513                      	inc r17			;
000212 0f01                      	add r16,r17		;Track + 40 or 80
                                 jp10:	
000213 e019                      	ldi r17,9		;Track*9
000214 9f01                      	mul r16,r17		;Result in r0 r1
000215 2711                      	clr r17			;Add sector offset 0-8		
000216 9100 0102                 	lds r16,fdcSector	; "
000218 0e00                      	add r0,r16		; "
000219 1e11                      	adc r1,r17		; "
                                 	
                                 	;Divide TI sector by 2 to put in upper or lower half of SD sector
00021a 9200 0116                 	sts TIlowbyte,r0 	;save low byte for bit 0 test
00021c 9416                      	lsr r1			;Divide 16 bits by 2
00021d 9407                      	ror r0			; "	"	"
                                 	
                                 	;Add TI sector to DSKx SD start sector address and place in ARG
00021e e0f1                      	ldi ZH,high(DSK1address)   ;
00021f e0e7                      	ldi ZL,low(DSK1address)    ;
000220 9985                      	sbic PinD,5		    ;
000221 9634                      	adiw Z,4		    ;DSK2address
000222 9986                      	sbic PinD,6		    ;
000223 9638                      	adiw Z,8		    ;DSK3address
                                 
000224 9101                      	ld r16,Z+
000225 0d00                      	add r16,r0
000226 9300 0119                 	sts arg,r16
000228 9101                      	ld r16,Z+
000229 1d01                      	adc r16,r1
00022a 9300 011a                 	sts arg+1,r16
00022c 2400                      	clr r0			;carry not affected
00022d 9101                      	ld r16,Z+
00022e 1d00                      	adc r16,r0
00022f 9300 011b                 	sts arg+2,r16
000231 8100                      	ld r16,Z
000232 1d00                      	adc r16,r0
000233 9300 011c                 	sts arg+3,r16
000235 9508                      	ret
                                 ;	
                                 WaitTIread:
000236 9100 0106                 	lds r16,flags		;Get flags
000238 ff07                      	sbrs r16,iflag		;Has TI read data?
000239 cffc                      	rjmp WaitTIread
00023a 2711                      	clr r17			;Clear interrupt flag
00023b 9310 0106                 	sts flags,r17		; "
00023d 3803                      	cpi r16,0x83		;Was it read data register
00023e f7b9                      	brne WaitTIread
00023f 9508                      	ret
                                 WaitTIwrite:
000240 9100 0106                 	lds r16,flags		;Get flags
000242 ff07                      	sbrs r16,iflag		;Has TI written data?
000243 cffc                      	rjmp WaitTIwrite
000244 2711                      	clr r17			;Clear interrupt flag
000245 9310 0106                 	sts flags,r17		; "
000247 3807                      	cpi r16,0x87		;Was it write data register
000248 f7b9                      	brne WaitTIwrite
000249 9508                      	ret
                                 	
                                 TI_SD_rd:
00024a d2d3                      	rcall readmmc		;512 bytes in sdbuffer
00024b eceb                      	ldi ZL,low(SDbuffer)
00024c e0f2                      	ldi ZH,high(SDbuffer)
00024d 9100 0116                 	lds r16,TIlowbyte
00024f fd00                      	sbrc r16,0
000250 95f3                      	inc ZH			;Add 256 to Z
000251 eccb                      	ldi YL,low(TIbuffer)
000252 e0d1                      	ldi YH,high(TIbuffer)
                                 ;Move 256 bytes from source(Z) to destination(Y)
000253 2700                      mov256:	clr r16		
000254 9111                      lp03:	ld r17,Z+ 
000255 9319                      	st Y+,r17
000256 950a                      	dec r16
000257 f7e1                      	brne lp03
000258 9508                      	ret	;and send to TI
                                 TI_SD_wr:
000259 d2c4                      	rcall readmmc	//512 bytes in sdbuffer
00025a eceb                      	ldi ZL,low(TIbuffer)
00025b e0f1                      	ldi ZH,high(TIbuffer)
00025c eccb                      	ldi YL,low(SDbuffer)
00025d e0d2                      	ldi YH,high(SDbuffer)
00025e 9100 0116                 	lds r16,TIlowbyte
000260 fd00                      	sbrc r16,0
000261 95d3                      	inc YH			;Add 256 to Y
000262 dff0                      	rcall mov256
000263 d287                      	rcall writemmc	//512 bytes in sdbuffer
000264 9508                      	ret	
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritetrack:
000265 e049                      	ldi r20,9
                                 lp25:	
000266 983a                      	cbi PortE,2		;Release TI
                                 	
                                 ;Get (FE,Track,Side,Sector,1?,F7)	
                                 lp26:	
000267 dfd8                      	rcall WaitTIwrite	;Wait for data from TI
000268 9100 0103                 	lds r16,fdcData		;Get next byte
00026a 3f0e                      	cpi r16,0xFE
00026b f7d9                      	brne lp26
                                 	
00026c dfd3                      	rcall WaitTIwrite	;Throw away Track,already loaded
                                 
00026d dfd2                      	rcall WaitTIwrite	;Wait for data from TI
00026e 9100 0103                 	lds r16,fdcData	
                                 ;	ror r16			;Move bit0 to bit7
                                 ;	ror r16			; "
000270 9300 0105                 	sts fdcSide,r16		;Save Side
                                 	
000272 dfcd                      	rcall WaitTIwrite	;Wait for data from TI
000273 9100 0103                 	lds r16,fdcData	
000275 9300 0102                 	sts fdcSector,r16	;Save Sector
                                 
                                 ;Get (FB,256 bytes E5,F7)	
                                 lp27:	
000277 dfc8                      	rcall WaitTIwrite	;Wait for data from TI
000278 9100 0103                 	lds r16,fdcData		;Get next byte
00027a 3f0b                      	cpi r16,0xFB
00027b f7d9                      	brne lp27
                                 	
00027c e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
00027d eceb                      	ldi ZL,low(TIbuffer)	; "
00027e e020                      	ldi r18,0x00		;256 bytes per sector
                                 lp28:	
00027f dfc0                      	rcall WaitTIwrite	;Wait for data from TI
000280 9100 0103                 	lds r16,fdcData	;Get next byte
000282 9301                      	st Z+,r16		;Save to buffer
000283 952a                      	dec r18
000284 f7d1                      	brne lp28
                                 	
000285 9a3a                      	sbi PortE,2		;Put TI on hold while process command
000286 df7a                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
000287 dfd1                      	rcall TI_SD_wr		;Write to SD
                                 	
000288 954a                      	dec r20			;All 9 sectors done?
000289 f6e1                      	brne lp25      
00028a 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;All disks names 0-255 sent to TI
                                 ; ENTRY:
                                 ;
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 SendNames:
                                 ;Send disk numbers DSK1-3 
00028b e001                      	ldi r16,0x01
00028c 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
00028e 2700                       	clr r16
00028f 9300 011a                 	sts arg+1,r16
000291 9300 011b                 	sts arg+2,r16
000293 9300 011c                 	sts arg+3,r16		; (MSB)
000295 d288                      	rcall ReadMMC           ; Read sector 1
000296 e0f2                      	ldi ZH,high(SDbuffer+4)	; Point to disk #s in buffer
000297 ecef                      	ldi ZL,low(SDbuffer+4)	; "
                                    
000298 e043                      	ldi r20,3
000299 9101                      lp93:	ld r16,Z+		;Mov char from buffer to fdcData
00029a 9300 0103                 	sts fdcData,r16		;
00029c 983a                      	cbi PortE,2		;Release TI
00029d df98                      	rcall WaitTIread	;Wait for TI to read
00029e 9a3a                      	sbi PortE,2		;Put TI on hold
00029f 954a                      	dec r20
0002a0 f7c1                      	brne lp93
                                 	
                                 ;Send Names
0002a1 2755                      	clr r21			;Start at disk 0
0002a2 d02c                      lp91:	rcall Disk2Sector	;Convert disk# in R21 to sector address
0002a3 d27a                      	rcall ReadMMC           ;Read sector
0002a4 eceb                      	ldi ZL,low(SDbuffer)	;Get address to buffer
0002a5 e0f2                      	ldi ZH,high(SDbuffer)	; "
                                 	
0002a6 e04a                      	ldi r20,10
0002a7 9101                      lp92:	ld r16,Z+		;Mov char from buffer to fdcData
0002a8 9300 0103                 	sts fdcData,r16		;
0002aa 983a                      	cbi PortE,2		;Release TI
0002ab df8a                      	rcall WaitTIread	;Wait for TI to read
0002ac 9a3a                      	sbi PortE,2		;Put TI on hold
0002ad 954a                      	dec r20
0002ae f7c1                      	brne lp92
                                 	
0002af 9553                      	inc r21			;Next disk
0002b0 f789                      	brne lp91		;If roll over then finished
0002b1 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Change disk in drive
                                 ; ENTRY:
                                 ;	From TI	- r20 Drive 1-3 
                                 ;	From TI - r21 Disk 0-255
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r17 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ChgDisk:
                                 ;Get drive number from TI
0002b2 983a                      	cbi PortE,2		;Release TI
0002b3 df8c                      	rcall WaitTIwrite	;Wait for data from TI
0002b4 9140 0103                 	lds r20,fdcData	;Get Drive number
0002b6 7043                      	andi r20,0x03		;
0002b7 954a                      	dec r20			;DSK 1-3 to 0-2
                                 ;Get disk number from TI
0002b8 df87                      	rcall WaitTIwrite	;Wait for data from TI
0002b9 9150 0103                 	lds r21,fdcData	;Get disk number
0002bb 9a3a                      	sbi PortE,2		;Put TI on hold
                                 	
                                 ;Put new disk number in sector 1	
0002bc e001                      	ldi r16,0x01
0002bd 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
0002bf 2700                       	clr r16
0002c0 9300 011a                 	sts arg+1,r16
0002c2 9300 011b                 	sts arg+2,r16
0002c4 9300 011c                 	sts arg+3,r16		; (MSB)
0002c6 d257                      	rcall ReadMMC           ; Read sector 1
0002c7 e0f2                      	ldi ZH,high(SDbuffer)	; Get address to buffer
0002c8 eceb                      	ldi ZL,low(SDbuffer)	; "
                                 ; Drive number r20
                                 ; Disk number r21
0002c9 0fe4                      	add ZL,r20		;Point to drive in sector 1		
0002ca 2700                      	clr r16			; "
0002cb 1ff0                      	adc ZH,r16		; "
0002cc 8354                      	std Z+4,r21		; Save new disk number
0002cd d21d                      	rcall WriteMMC          ; Write sector 1 back to SD
0002ce 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Multiply DISK number and store sector address at DSKx addresses
                                 ; Entry:
                                 ;	r21 = disk number
                                 ;
                                 ; Exit:	    
                                 ;	Disk sector address store in arg also in r0-r3	
                                 ;	Registers used r0-r5 r16 r17 Z
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Disk2Sector:
0002cf 2e55                       	mov r5,r21		    ;Save dsisk number
                                 
0002d0 e0f1                      	ldi ZH,high(StartSector)   ; "
0002d1 e2e4                      	ldi ZL,low(StartSector)    ; "
0002d2 9001                      	ld r0,Z+		    ;initilize to start sector
0002d3 9011                      	ld r1,Z+		    ; "
0002d4 2422                      	clr r2			    ; "
0002d5 2433                      	clr r3			    ; "
0002d6 9101                      	ld r16,Z+		    ;Get step sectors
0002d7 9111                      	ld r17,Z+		    ; "   
                                 
0002d8 2055                      	tst r5			    ; Test for Disk number zero
0002d9 f019                      	breq jp90		    ; skip if zero
0002da d009                      lp90:	rcall Add32_16		    ;Multiply disk number by step
0002db 945a                      	dec r5			    ; "
0002dc f7e9                      	brne lp90		    ; "
                                 	
0002dd e0f1                      jp90:	ldi ZH,high(arg)	    ;Place result in argument
0002de e1e9                      	ldi ZL,low(arg)	    ; "
0002df 9201                       	st Z+,r0
0002e0 9211                      	st Z+,r1	
0002e1 9221                      	st Z+,r2	
0002e2 9231                      	st Z+,r3
0002e3 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Add 16 bits to 32 bits (lsbyte first)
                                 ; Entry		r0,r1,r2,r3 + r16,r17 
                                 ; Exit result	r0,r1,r2,r3
                                 ; r4 cleared,r16,r17 not destroyed	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Add32_16:	
0002e4 2444                      	clr r4
0002e5 0e00                      	add r0,r16  ;add low byte
0002e6 1c14                      	adc r1,r4
0002e7 1c24                      	adc r2,r4
0002e8 1c34                      	adc r3,r4
0002e9 0e11                      	add r1,r17 ;add high byte
0002ea 1c24                      	adc r2,r4
0002eb 1c34                      	adc r3,r4
0002ec 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; USART routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 USARTInit:
0002ed b909                      	out UBRR0L,r16			;Set Baud rate
0002ee bd10                      	out UBRR0H,r17
0002ef e806                      	ldi r16,(1<<URSEL0)|(3<<UCSZ00)	;8N1
0002f0 bd00                      	out UCSR0C,r16
0002f1 e108                      	ldi r16,(1<<RXEN)|(1<<TXEN)	;Enable receive & transmit
0002f2 b90a                      	out UCSR0B,r16
                                 ;	ldi r16,(1<<U2X)		;Double the baud rate
                                 ;	out UCSR0A,r16
0002f3 9508                      	ret
                                 USARTRead:
0002f4 9b5f                      	sbis UCSR0A,RXC			;Wait until data is available
0002f5 cffe                      	rjmp USARTRead
0002f6 b10c                      	in r16,UDR			;Get received data
0002f7 9508                      	ret
                                 USARTWrite:
0002f8 9b5d                      	sbis UCSR0A,UDRE		;Wait until transmit is ready
0002f9 cffe                      	rjmp USARTWrite
0002fa b90c                      	out UDR,r16			;Send data
0002fb 9508                      	ret
                                 USARTFlush:
0002fc 9b5f                      	sbis UCSR0A,RXC
0002fd 9508                      	ret
0002fe b10c                      	in r16,UDR
0002ff cffc                      	rjmp USARTFlush
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; TI access to USART
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIrdUsartStat:
000300 9100 012a                 	lds r16,SerCnt
000302 3000                      	cpi r16,0
000303 f011                      	breq jp16
                                 
000304 ee02                      	ldi r16,226		;Send 226 status If buffer count not 0
000305 c001                      	rjmp jp17		;Else send status from Usart
                                 
000306 b10b                      jp16:	in r16,UCSR0A
000307 9300 0103                 jp17:	sts fdcData,r16		;Send to TI
000309 983a                      	cbi PortE,2		;Release TI
00030a 9508                      	ret
                                 
                                 TIrdUsartData:
00030b 9100 012a                 	lds r16,SerCnt
00030d 3000                      	cpi r16,0
00030e f081                      	breq jp18		;Sent TI char from USART
00030f 950a                      	dec r16
000310 9300 012a                 	sts SerCnt,r16
                                 	
000312 e0f1                      	ldi ZH,high(Serbuffer)
000313 e2eb                      	ldi ZL,low(Serbuffer)
000314 9100 0129                 	lds r16,SerRdPtr	;ptr Status byte
000316 0fe0                      	add ZL,r16		;Point Z to Char byte
                                 ;	clr r17			;
                                 ;	adc ZH,r17
000317 9503                      	inc r16			;ptr next entry
000318 3a00                      	cpi r16,Serbuffsize
000319 f409                      	brne jp14
00031a 2700                      	clr r16
00031b 9300 0129                 jp14:	sts SerRdPtr,r16
00031d 8100                      	ld r16,Z		;Get char from buffer
00031e c001                      	rjmp jp19
                                 	
00031f b10c                      jp18:	in r16,UDR		;Get char from USART
000320 9300 0103                 jp19:	sts fdcData,r16		;Send to TI
000322 983a                      	cbi PortE,2		;Release TI
000323 9508                      	ret 
                                 	 
                                 TIwrUsartData:
000324 983a                      	cbi PortE,2		;Release TI
000325 df1a                      	rcall WaitTIwrite	;Wait for data from TI
000326 9100 0103                 	lds r16,fdcData
000328 dfcf                      	rcall USARTWrite
000329 9508                      	ret
                                     
                                 TIwrUsartSub:
00032a 983a                      	cbi PortE,2		;Release TI
00032b df14                      	rcall WaitTIwrite	;Wait for data from TI
00032c 9100 0103                 	lds r16,fdcData
00032e 9a3a                      	sbi PortE,2		;Hold TI
                                 
00032f 3000                      	cpi r16,0		;Flush Buffer
000330 f449                      	brne jp20
000331 dfca                      	rcall USARTFlush
000332 2700                      	clr r16			;
000333 9300 0129                 	sts SerRdPtr,r16	;Reset pointers
000335 9300 0128                 	sts SerWrPtr,r16
000337 9300 012a                 	sts SerCnt,r16
000339 9508                      	ret
                                 
00033a 3001                      jp20:	cpi r16,1		;Turn on 128 buffer
00033b f421                      	brne jp21		;
00033c b10a                      	in r16,UCSR0B		;Enable RXC interrupt
00033d 6800                      	sbr r16,1<<RXCIE	; "
00033e b90a                      	out UCSR0B,r16		; "
00033f 9508                      	ret			;		
                                 
000340 3002                      jp21:	cpi r16,2		;Turn off 128 buffer
000341 f419                      	brne jp22		;
000342 b10a                      	in r16,UCSR0B		;Disable RXC interrupt
000343 770f                      	cbr r16,1<<RXCIE	; "
000344 b90a                      	out UCSR0B,r16		; "
000345 9508                      jp22:	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; SPI routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SPIInit:
000346 e503                      	ldi r16,(1<<SPE)|(1<<MSTR)|(3<<SPR0)	;En SPI,Master,fosc/128(125k)
000347 b90d                      	out SPCR,r16	;DORD=MSB,CPOL=rising,CPHA=LeadSample/TrailSetup
                                 ;	ldi r16,(1<<SPI2X)			; SPI double speed
                                 ;	out SPSR,r16	
000348 9508                      	ret
                                 SPIRead:
000349 ef0f                      	ser r16			;Transmit ones to receive byte
                                 SPIWrite:
00034a b90f                      	out SPDR,r16		;Send transmit byte
                                 SPIWait:	
00034b 9b77                      	sbis SPSR,SPIF		;Wait Fot Transmission complete
00034c cffe                      	rjmp SPIWait
00034d b10f                      	in	r16,SPDR	; Get received byte
00034e 9508                      	ret
                                 FullThrottle:
00034f 9868                      	cbi SPCR,SPR0
000350 9869                      	cbi SPCR,SPR1
000351 9a70                      	SBI SPSR,SPI2X
000352 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ; Access EXFAT find file TIVOL000
                                 ;	
                                 ;************************************************************************************
                                 ; Process Master Boot Sector
                                 ;************************************************************************************
                                 FindTIVOL:
000353 2700                      	clr r16				;Get MBR sector
000354 9300 0119                 	sts arg,r16			; (LSB) sector 00 00 00 00
000356 9300 011a                 	sts arg+1,r16
000358 9300 011b                 	sts arg+2,r16
00035a 9300 011c                 	sts arg+3,r16			; (MSB)
00035c d1c1                      	rcall ReadMMC           	; First 512 sector (uses ZL & ZH)
                                 		
00035d e9e1                      	ldi ZL,low(SDbuffer+0x1C6)	;Save VBR in Offset
00035e e0f4                      	ldi ZH,high(SDbuffer+0x1C6)	; "
00035f e2c0                      	ldi YL,low(Offset)		; "
000360 e0d1                      	ldi YH,high(Offset)		; "
000361 d235                      	rcall mov4
                                 
                                 ;************************************************************************************
                                 ; Process Volume Boot Sector
                                 ;************************************************************************************
000362 e2e0                      	ldi ZL,low(Offset)		;Put vbr in arg
000363 e0f1                      	ldi ZH,high(Offset)		;
000364 e1c9                      	ldi YL,low(arg)    		; "
000365 e0d1                      	ldi YH,high(arg)   		; "
000366 d230                      	rcall mov4
000367 d1b6                      	rcall ReadMMC           	; Get VBR sector	
                                 	
000368 eceb                      	ldi ZL,low(SDbuffer)		;Point to buffer
000369 e0f2                      	ldi ZH,high(SDbuffer)		;
00036a eac0                      	ldi YL,low(EXFATstr<<1)
00036b e0d1                      	ldi YH,high(EXFATstr<<1)
00036c d217                      	rcall cmpstr
00036d f561                      	brne DiskErrRly			;Partition is not EXFAT
                                 	
00036e e2c3                      	ldi YL,low(SDbuffer+0x58)	;Save HeapOffset+VBR
00036f e0d3                      	ldi YH,high(SDbuffer+0x58)	; "
000370 e2a0                      	ldi XL,low(OffSet)    		; "
000371 e0b1                      	ldi XH,high(Offset)   		; "
000372 d22a                      	rcall AddDword			; Result in Offset
                                 
000373 e2eb                      	ldi ZL,low(SDbuffer+0x60)	;Get RootDirectory cluster
000374 e0f3                      	ldi ZH,high(SDbuffer+0x60)	; "
000375 e1c9                      	ldi YL,low(arg)    		; "
000376 e0d1                      	ldi YH,high(arg)   		; "
000377 d21f                      	rcall mov4
                                 	
000378 9100 0119                 	lds r16,arg			; Start cluster - 2
00037a 950a                      	dec r16				;
00037b 950a                      	dec r16				;
00037c 9300 0119                 	sts arg,r16			;
                                 
00037e e3e8                      	ldi ZL,low(SDbuffer+0x6D)	;Point to SectorsPerClusterShift
00037f e0f3                      	ldi ZH,high(SDbuffer+0x6D)	;
000380 8130                      	ld r19,Z			;
000381 9330 011f                 	sts SectorsPerCluster,r19 	;Save SectorsPerClusterShift
000383 d1e9                      	rcall LslArg			;RootDirectory * SectorsPerClusterShift
                                 
                                 ;************************************************************************************
                                 ; Process Root Directory Sector	(Find VOLUMES folder)
                                 ;************************************************************************************
000384 e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to RootDirectory in arg
000385 e0b1                      	ldi XH,high(arg)		; "
000386 e2c0                      	ldi YL,low(OffSet)    		; "
000387 e0d1                      	ldi YH,high(Offset)   		; "
000388 d214                      	rcall AddDword			; "
000389 d194                      	rcall ReadMMC           	;Get RootDirectory sector
                                 	    
00038a eceb                      	ldi ZL,low(SDbuffer)		;Point to buffer
00038b e0f2                      	ldi ZH,high(SDbuffer)		;
00038c eaca                      	ldi YL,low(VOLstr<<1)
00038d e0d1                      	ldi YH,high(VOLstr<<1)
                                 
00038e 8100                      lp06:	ld r16,Z
00038f 3c01                      	cpi r16,0xC1			;Check for type C1 entry
000390 f411                      	brne jp06
000391 d1f2                      	rcall cmpstr
000392 f041                      	breq jp03
                                 
000393 96b0                      jp06:	adiw ZH:ZL,32			;Next entry
000394 ec0b                      	ldi R16,low(SDbuffer+512)
000395 17e0                      	cp ZL,r16			;Check end of buffer
000396 f7b9                      	brne lp06  
000397 e004                      	ldi R16,high(SDbuffer+512)
000398 17f0                      	cp ZH,r16			;Check end of buffer
000399 f7a1                      	brne lp06  
                                 DiskErrRly:
00039a c05e                      	rjmp DiskErr			;VOLUMES not found
                                 
                                 jp03:	
00039b 97b0                       	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
00039c 9674                       	adiw ZH:ZL,20			;Point to VOLUMES folder cluster dword at 20
00039d e1c9                      	ldi YL,low(arg)    		; "
00039e e0d1                      	ldi YH,high(arg)   		; "
00039f d1f7                      	rcall mov4
                                 	
0003a0 9100 0119                 	lds r16,arg			; Start cluster - 2
0003a2 950a                      	dec r16				;
0003a3 950a                      	dec r16				;
0003a4 9300 0119                 	sts arg,r16			;
                                 
0003a6 9130 011f                 	lds r19,SectorsPerCluster
0003a8 d1c4                      	rcall LslArg			;VOLUMES folder * SectorsPerCluster
                                 
                                 ;************************************************************************************
                                 ; Process VOLUMES Sector	(Find TIVOL000 file sector)
                                 ;************************************************************************************
0003a9 e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to VOLUMES folder in arg
0003aa e0b1                      	ldi XH,high(arg)		; "
0003ab e2c0                      	ldi YL,low(Offset)    		; "
0003ac e0d1                      	ldi YH,high(Offset)   		; "
0003ad d1ef                      	rcall AddDword			; "
0003ae d16f                      	rcall ReadMMC           	;Get VOLUMES folder sector
                                 	
0003af eceb                      	ldi ZL,low(SDbuffer)		;Point to buffer
0003b0 e0f2                      	ldi ZH,high(SDbuffer)		;
0003b1 ebca                      	ldi YL,low(TIVOLstr<<1)
0003b2 e0d1                      	ldi YH,high(TIVOLstr<<1)
                                 	
0003b3 8100                      lp04:	ld r16,Z
0003b4 3c01                      	cpi r16,0xC1			;Check for type C1 entry
0003b5 f411                      	brne jp04
0003b6 d1cd                      	rcall cmpstr
0003b7 f041                      	breq jp05			;TIVOL000 found
                                 
0003b8 96b0                      jp04:	adiw ZH:ZL,32			;Next entry
0003b9 ec0b                      	ldi R16,low(SDbuffer+512)
0003ba 17e0                      	cp ZL,r16			;Check end of buffer
0003bb f7b9                      	brne lp04  
0003bc e004                      	ldi R16,high(SDbuffer+512)
0003bd 17f0                      	cp ZH,r16			;Check end of buffer
0003be f7a1                      	brne lp04  
0003bf c039                      	rjmp DiskErr			;TIVOL000 not found
                                 
0003c0 97b0                      jp05:	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
0003c1 9674                      	adiw ZH:ZL,20			;Point TIVOL000 file cluster dword at 20
0003c2 e1c9                      	ldi YL,low(arg)    		; TIVOL000 file cluster
0003c3 e0d1                      	ldi YH,high(arg)   		; "
0003c4 d1d2                      	rcall mov4
                                 	
0003c5 9100 0119                 	lds r16,arg			; Start cluster - 2
0003c7 950a                      	dec r16				;
0003c8 950a                      	dec r16				;
0003c9 9300 0119                 	sts arg,r16			;
                                 	
0003cb 9130 011f                 	lds r19,SectorsPerCluster
0003cd d19f                      	rcall LslArg			;TIVOL000 file * SectorsPerCluster
                                 
0003ce e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to TIVOL000 file in arg
0003cf e0b1                      	ldi XH,high(arg)		; "
0003d0 e2c0                      	ldi YL,low(OffSet)    		; "
0003d1 e0d1                      	ldi YH,high(OffSet)   		; "
0003d2 d1ca                      	rcall AddDword			;
0003d3 9100 0119                 	lds r16,arg			;Save TIVOL000 start sector
0003d5 9300 0124                 	sts StartSector,r16		; "
0003d7 9100 011a                 	lds r16,arg+1			; "
0003d9 9300 0125                 	sts StartSector+1,r16		; " 
                                 
0003db e1c9                      	ldi YL,low(arg)    		;Z left pointing to file size at 24
0003dc e0d1                      	ldi YH,high(arg)   		;file size is qword but we will never exceed dword
0003dd d1b9                      	rcall mov4
                                 		
0003de 9130 011f                 	lds r19,SectorsPerCluster
0003e0 e009                      	ldi r16,9
0003e1 0f30                      	add r19,r16
0003e2 d1cb                      	rcall LsrArg			;Divide by SectorsPerCluster + 512 bytes per sector
0003e3 f44e                      	brtc jp01			;If t not set then no carry (no remainder)
0003e4 91e0 0119                 	lds ZL,arg
0003e6 91f0 011a                 	lds ZH,arg+1
0003e8 9631                      	adiw ZH:ZL,1
0003e9 93e0 0119                 	sts arg,ZL
0003eb 93f0 011a                 	sts arg+1,ZH
0003ed 9130 011f                 jp01:	lds r19,SectorsPerCluster
0003ef d17d                      	rcall LslArg			;Size in clusters back to size in sectors
                                 
0003f0 9100 0119                 	lds r16,arg			;Save sector step
0003f2 9300 0126                 	sts StepSectors,r16		; "
0003f4 9100 011a                 	lds r16,arg+1			; "
0003f6 9300 0127                 	sts StepSectors+1,r16		; 
                                 	
0003f8 9418                      	sez				;Set Z bit (No error)
                                 DiskErr:				;Return error,Z bit cleared
0003f9 9508                      	ret				;On return will set disk ready status	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;	
                                 ; Low level SD card access
                                 ;	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send command to MMC,Uses cmd resp r16 r17 r18 nz=error
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendMMC:
                                     ;4.8ms delay,PNY 1GB had trouble without delay
0003fa d154                          	rcall delay1ms
0003fb d153                      	rcall delay1ms
0003fc d152                      	rcall delay1ms
0003fd d151                      	rcall delay1ms
0003fe d150                      	rcall delay1ms
                                 		
0003ff ef0f                      	ldi r16,0xFF		;
000400 df49                             	rcall SPIWrite	;
000401 9100 0118                 	lds r16,cmd		; Send the command byte
000403 df46                      	rcall SPIWrite	;
000404 9100 011c                 	lds r16,arg+3		; Send 4 argument bytes starting with MSB
000406 df43                      	rcall SPIWrite	;
000407 9100 011b                 	lds r16,arg+2		;
000409 df40                      	rcall SPIWrite	;
00040a 9100 011a                 	lds r16,arg+1		;
00040c df3d                      	rcall SPIWrite	;
00040d 9100 0119                 	lds r16,arg		;
00040f df3a                      	rcall SPIWrite	;
000410 9100 011d                 	lds r16,crc		; Send the CRC7 byte (always use 95)
000412 df37                             	rcall SPIWrite	;
                                 			
                                 WaitResp:
000413 2722                      	clr r18
                                 lp10:
                                     ;.69ms delay,PNY 1GB had trouble without delay	
000414 d13a                      	rcall delay1ms		
                                 				
000415 df33                      	rcall SPIRead	;
000416 9110 011e                 	lds r17,resp
000418 1701                      	cp r16,r17		; expected response?
000419 f021                      	breq jp11		; YES - return
00041a 952a                      	dec r18			; waiting period is over?
00041b f7c1                             	brne lp10		; NO - keep waiting
00041c d126                      	rcall SendErrorSPI	;
00041d 9498                      	clz			; Clear zero flag for time out
00041e 9508                      jp11:	ret			;
                                 
                                     
                                 ;********************************************************************
                                 ; Init SD/MMC memory card
                                 ;******************************************************************** 
                                 MMCInit:	
00041f 9ac4                      	sbi PortB,CS		    ; disable MMC
000420 e01a                      	ldi r17,10		    ; Send 80 dummy clocks
                                 lp20:
000421 df27                      	rcall SPIRead	    ;
000422 951a                             	dec R17			    ;
000423 f7e9                      	brne lp20		    ;
000424 98c4                              cbi PortB,CS		    ; enable MMC         
                                 SendCMD0:
000425 e400                      	ldi r16,0x40		    ; CMD0 GO_IDLE_STATE
000426 9300 0118                 	sts cmd,r16              
000428 2700                             	clr r16			    ; LSB
000429 9300 0119                 	sts arg,r16                ; 0x00000000
00042b 9300 011a                 	sts arg+1,r16              ;	
00042d 9300 011b                 	sts arg+2,r16              ;	
00042f 9300 011c                 	sts arg+3,r16              ; MSB
000431 e905                      	ldi r16,0x95
000432 9300 011d                        	sts crc,r16
000434 e001                      	ldi r16,1
000435 9300 011e                 	sts resp,r16		    ; expected response cnt 8
000437 dfc2                      	rcall SendMMC		    ;
000438 f761                             	brne SendCMD0		    ; Expected response timed out
                                 SendCMD8:
000439 e408                      	ldi r16,0x48		    ; CMD8 SEND_IF_COND
00043a 9300 0118                 	sts cmd,r16
00043c ea0a                      	ldi r16,0xAA		    ; LSB
00043d 9300 0119                 	sts arg,r16                ; 0x000001AA
00043f e001                      	ldi r16,0x01		    ;
000440 9300 011a                 	sts arg+1,r16              ;
000442 2700                      	clr r16			    ;
000443 9300 011b                 	sts arg+2,r16              ;
000445 9300 011c                 	sts arg+3,r16              ; MSB
000447 e807                      	ldi r16,0x87
000448 9300 011d                 	sts crc,r16
00044a e001                      	ldi r16,1		    ; Response V2=0x01 0x000001AA or V1=0x05
00044b 9300 011e                 	sts resp,r16
00044d dfac                      	rcall SendMMC               ; 
00044e f571                      	brne SendCMD1
00044f def9                      	rcall SPIRead		    ; need to clear 0x000001AA
000450 def8                      	rcall SPIRead		    ;	
000451 def7                              rcall SPIRead		    ;	      	
000452 def6                      	rcall SPIRead		    ;			; 
                                 			
                                 ;ACMD41 (CMD55+CMD41)			
                                 SendCMD55:
000453 e707                      	ldi r16,0x77		    ; CMD55 APP_CMD
000454 9300 0118                 	sts cmd,r16              
000456 2700                             	clr r16			    ; LSB
000457 9300 0119                 	sts arg,r16                ; 0x00000000
000459 9300 011a                 	sts arg+1,r16              ;	
00045b 9300 011b                 	sts arg+2,r16              ;	
00045d 9300 011c                 	sts arg+3,r16              ; MSB
00045f ef0f                      	ldi r16,0xFF
000460 9300 011d                        	sts crc,r16
000462 e001                      	ldi r16,1
000463 9300 011e                 	sts resp,r16		    ; expected response
000465 df94                      	rcall SendMMC		    ;
000466 f761                             	brne SendCMD55		    ;  Expected response timed out	
                                 SendCMD41: 	
000467 e609                      	ldi r16,0x69		    ; CMD41 SD_SEND_OP_COND
000468 9300 0118                 	sts cmd,r16              
00046a 2700                             	clr r16			    ; LSB
00046b 9300 0119                 	sts arg,r16                ; 0x40000000
00046d 9300 011a                 	sts arg+1,r16              ;
00046f 9300 011b                 	sts arg+2,r16              ;
000471 e400                      	ldi r16,0x40
000472 9300 011c                 	sts arg+3,r16              ; MSB
000474 ef0f                      	ldi r16,0xFF
000475 9300 011d                        	sts crc,r16
000477 2700                      	clr r16
000478 9300 011e                 	sts resp,r16		    ; expected response
00047a df7f                      	rcall SendMMC		    ;
00047b f6b9                             	brne SendCMD55		    ;  Expected response timed out
00047c c014                      	rjmp SendCMD58
                                 
                                 SendCMD1:
00047d e401                      	ldi r16,0x41		    ; CMD1 SEND_OP_COND
00047e 9300 0118                 	sts cmd,r16              
000480 2700                             	clr r16			    ; LSB
000481 9300 0119                 	sts arg,r16                ; 0x00000000
000483 9300 011a                 	sts arg+1,r16              ;	
000485 9300 011b                 	sts arg+2,r16              ;	
000487 9300 011c                 	sts arg+3,r16              ; MSB
000489 ef0f                      	ldi r16,0xFF
00048a 9300 011d                        	sts crc,r16
00048c 2700                      	clr r16
00048d 9300 011e                 	sts resp,r16		    ; expected response
00048f df6a                      	rcall SendMMC		    ;
000490 f761                             	brne SendCMD1		    ;  Expected response timed out
                                    			
                                 SendCMD58:
000491 e70a                      	ldi r16,0x7A		    ; CMD58 READ_OCR
000492 9300 0118                 	sts cmd,r16              
000494 2700                             	clr r16			    ; LSB
000495 9300 0119                 	sts arg,r16                ; 0x00000000
000497 9300 011a                 	sts arg+1,r16              ;	
000499 9300 011b                 	sts arg+2,r16              ;	
00049b 9300 011c                 	sts arg+3,r16              ; MSB
00049d ef0f                      	ldi r16,0xFF
00049e 9300 011d                        	sts crc,r16
0004a0 2700                      	clr r16
0004a1 9300 011e                 	sts resp,r16		    ; expected response
0004a3 df56                      	rcall SendMMC		    ;
0004a4 f761                             	brne SendCMD58		    ;  Expected response timed out
                                 
0004a5 e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
0004a6 eceb                      	ldi ZL,low(SDbuffer)	    ; "
0004a7 e034                      	ldi R19,4
                                 lp21:
0004a8 dea0                      	rcall SPIRead		    ; Get MSByte 1 of 4 OCR register
0004a9 9301                      	st Z+,r16		    ; Save OCR to buffer
0004aa 953a                      	dec R19
0004ab f7e1                      	brne lp21
0004ac 9100 02cb                 	lds r16,SDbuffer
0004ae 9300 0117                 	sts ocr,r16		    ; bit6=1 SDHC
                                 
                                 SendCMD9:
0004b0 e409                      	ldi r16,0x49		    ; CMD9 READ_CSD
0004b1 9300 0118                 	sts cmd,r16              
0004b3 2700                             	clr r16			    ;
0004b4 9300 011e                 	sts resp,r16		    ; expected response
0004b6 df43                      	rcall SendMMC		    ;
0004b7 f7c1                      	brne SendCMD9		    ; Expected response timed out
0004b8 ef0e                      	ldi r16,0xFE
0004b9 9300 011e                 	sts resp,r16
0004bb df57                      	rcall WaitResp		    ; Wait for FE Start
0004bc f799                      	brne SendCMD9
0004bd e132                      	ldi r19,18
                                 lp22:	
0004be de8a                      	rcall SPIRead
0004bf 953a                      	dec r19
0004c0 f7e9                      	brne lp22
                                 
                                 SendCMD10:
0004c1 e40a                          	ldi r16,0x4A		    ; CMD10 READ_CID
0004c2 9300 0118                 	sts cmd,r16              
0004c4 2700                             	clr r16			    ;
0004c5 9300 011e                 	sts resp,r16		    ; expected response
0004c7 df32                      	rcall SendMMC		    ;
0004c8 f7c1                      	brne SendCMD10		    ; Expected response timed out
0004c9 ef0e                      	ldi r16,0xFE
0004ca 9300 011e                 	sts resp,r16
0004cc df46                      	rcall WaitResp		    ; Wait for FE Start
0004cd f799                      	brne SendCMD10
0004ce e132                          	ldi r19,18
                                 lp23:	
0004cf de79                      	rcall SPIRead
0004d0 953a                      	dec r19
0004d1 f7e9                      	brne lp23
                                 
0004d2 de7c                      	rcall FullThrottle
                                 			
                                 ; Let fall thru to Set Block			
                                 ;********************************************************************
                                 ; CMD16 SET_BLOCKLEN default 512
                                 ; The only valid block length for write is 512!
                                 ; Read is 1 to 2048
                                 ;********************************************************************
                                 SetBlockMMC: 
0004d3 98c4                      	cbi PortB,CS		    ; enable MMC         
0004d4 e500                      	ldi r16,0x50		    ; CMD16 SET_BLOCKLEN
0004d5 9300 0118                 	sts cmd,r16              
0004d7 2700                             	clr r16			    ; LSB
0004d8 9300 0119                 	sts arg,r16                ; 0x00000200 (512 block)
0004da e002                      	ldi r16,2
0004db 9300 011a                 	sts arg+1,r16              ;
0004dd 2700                      	clr r16
0004de 9300 011b                 	sts arg+2,r16              ;	
0004e0 9300 011c                 	sts arg+3,r16              ; MSB
0004e2 2700                      	clr r16
0004e3 9300 011d                 	sts crc,r16
0004e5 9300 011e                 	sts resp,r16		    ; expected response
0004e7 df12                      	rcall SendMMC		    ;
0004e8 f751                             	brne SetBlockMMC	    ; Expected response timed out
0004e9 9ac4                      	sbi PortB,CS		    ; Disable MMC
0004ea 9508                      	ret 							;
                                 
                                 ;********************************************************************
                                 ; CMD24 WRITE_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ; Exit nz=write error
                                 ;********************************************************************
                                 WriteMMC:			    ;Write 1st 256 bytes of sector
0004eb 98c4                      	cbi PortB,CS		    ; enable MMC   
0004ec d06d                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
0004ed 9100 0117                 	lds r16,ocr
0004ef ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
0004f0 d07b                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 lp40:
0004f1 e508                      	ldi r16,0x58		    ; CMD24 WRITE_BLOCK
0004f2 9300 0118                 	sts cmd,r16 
0004f4 2700                      	clr r16
0004f5 9300 011d                 	sts crc,r16
0004f7 9300 011e                 	sts resp,r16		    ; expected response
0004f9 df00                      	rcall SendMMC		    ;
0004fa f7b1                             	brne lp40		    ; Expected response timed out
                                 	
0004fb de4d                      	rcall SPIRead		    ; write prefix (Read writes FFFF)
0004fc de4c                      	rcall SPIRead
0004fd ef0e                      	ldi r16,0xFE		    ; Send start data token
0004fe de4b                      	rcall SPIWrite
                                 	
0004ff e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
000500 eceb                      	ldi ZL,low(SDbuffer)	    ; "
000501 2733                      	clr R19			    ; Write 256 bytes to SD
                                 ;Write 1st 256 bytes of sector	
                                 lp41:
000502 9101                      	ld r16,Z+
000503 de46                      	rcall SPIWrite		    ; Write data byte
000504 953a                      	dec R19
000505 f7e1                      	brne lp41
                                 ;Write 2nd 256 bytes of sector    		 
                                 lp42:
000506 9101                      	ld r16,Z+
000507 de42                      	rcall SPIWrite		    ; Write data byte
000508 953a                      	dec R19
000509 f7e1                      	brne lp42				
00050a de3e                      	rcall SPIRead		    ; write 2 bytes CRC 0xFF (Read writes FFFF)
00050b de3d                      	rcall SPIRead		    ;  "
                                 	    
00050c de3c                      	rcall SPIRead		    ; was data accepted			
00050d 710f                      	andi r16,0x1F
00050e 3005                      	cpi r16,5
00050f f449                      	brne jp45
000510 ef0f                      	ldi r16,0xFF		    ; wait for 0xFF
000511 9300 011e                 	sts resp,r16
000513 deff                      	rcall WaitResp
000514 f421                      	brne jp45
000515 d04d                      	rcall RestoreArg
000516 9ac4                      	sbi PortB,CS		    ; Disable MMC
000517 9418                      	sez			    ;Set zero fla
000518 9508                             	ret			    ; normal return z-flag set
                                 jp45:
000519 d049                      	rcall RestoreArg
00051a d028                      	rcall SendErrorSPI         
00051b 9ac4                      	sbi PortB,CS		    ; Disable MMC
00051c 9498                      	clz			    ;Clr zero flag
00051d 9508                      	ret			    ; write error return z-flag clear
                                  			
                                 			
                                       		
                                 ;********************************************************************
                                 ; CMD17 READ_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ;********************************************************************
                                 ReadMMC:			    ;Read 1st 256 bytes of sector
00051e 98c4                      	cbi PortB,CS		    ; enable MMC   
00051f d03a                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
000520 9100 0117                 	lds r16,ocr
000522 ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
000523 d048                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 lp50:
000524 e501                      	ldi r16,0x51		    ; CMD17 READ_SINGLE_BLOCK
000525 9300 0118                 	sts cmd,r16 
000527 2700                      	clr r16
000528 9300 011d                 	sts crc,r16
00052a 9300 011e                 	sts resp,r16		    ; expected response
00052c decd                      	rcall SendMMC		    ;
00052d f7b1                             	brne lp50		    ; Expected response timed out
                                 	
00052e ef0e                      	ldi r16,0xFE		    ; Send start data token
00052f 9300 011e                 	sts resp,r16
000531 dee1                      	rcall WaitResp		    ; Wait for FE Start
000532 f789                      	brne lp50
                                 ;Read 1st 256 bytes of sector	
000533 e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
000534 eceb                      	ldi ZL,low(SDbuffer)	    ; "
000535 2733                      	clr R19			    ; Always read 256 the size of buffer
                                 lp51:
000536 de12                      	rcall SPIRead		    ; Get data byte
000537 9301                      	st Z+,r16
000538 953a                      	dec R19
000539 f7e1                      	brne lp51
                                 ;Read 2nd 256 bytes of sector    		 
                                 lp52:
00053a de0e                      	rcall SPIRead		    ; Get data byte
00053b 9301                      	st Z+,r16
00053c 953a                      	dec R19
00053d f7e1                      	brne lp52		
00053e de0a                      	rcall SPIRead		    ; read 2 bytes CRC	
00053f de09                      	rcall SPIRead		    ; and discard	
000540 9ac4                      	sbi PortB,CS		    ; Disable MMC
000541 d021                       	rcall RestoreArg
000542 9508                         	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send error command/response to PC
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendErrorSPI:
000543 ddb4                             	rcall USARTWrite	    ; Send response received
000544 9100 011e                 	lds r16,resp		    
000546 ddb1                      	rcall USARTWrite	    ; Send expected response
000547 9100 0118                 	lds r16,cmd
000549 ddae                      	rcall USARTWrite	    ; Send cmd used
00054a 94aa                      	dec r10
                                 ErrLP:	
00054b f3f9                      	breq ErrLP		    ; Keep from runnig away,Until reset
00054c 9508                      	ret			    ; Fail 2 or 3 times on start,Just return 
                                 	
                                 SendErrorMedia:
00054d 0000                      	nop
00054e 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 delay1ms:		;  15431x.0625us aprox 1ms,not exact(.965ms)
00054f 930f                      	push r16	;   2
000550 931f                      	push r17	;   2
000551 e114                      	ldi r17,20	;   1
000552 2700                      	clr r16		;   1
000553 950a                      dly1:	dec r16		; 768x20=15360          
000554 f7f1                              brne dly1	; 
000555 951a                      	dec r17		; 3x20=60   
000556 f7e1                      	brne dly1
000557 911f                      	pop r17		;   2
000558 910f                      	pop r16		;   2
000559 9508                      	ret		;   1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                  SaveArg:   
00055a 9060 0119                     	lds r6,arg		; Save argument,in case multipled
00055c 9070 011a                   	lds r7,arg+1
00055e 9080 011b                   	lds r8,arg+2
000560 9090 011c                   	lds r9,arg+3
000562 9508                      	ret
                                 RestoreArg:
000563 9290 011c                 	sts arg+3,r9		; Restore argument
000565 9280 011b                 	sts arg+2,r8 
000567 9270 011a                 	sts arg+1,r7  
000569 9260 0119                 	sts arg,r6
00056b 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 Mul512Arg:
00056c e039                      	ldi r19,9		; multiply arg by 512
                                 LslArg:				; shift arg left per r19
                                 lp60:	
00056d 9100 0119                 	lds r16,arg
00056f 0f00                      	lsl r16
000570 9300 0119                 	sts arg,r16
000572 9100 011a                 	lds r16,arg+1
000574 1f00                      	rol r16
000575 9300 011a                 	sts arg+1,r16
000577 9100 011b                 	lds r16,arg+2
000579 1f00                      	rol r16
00057a 9300 011b                 	sts arg+2,r16
00057c 9100 011c                 	lds r16,arg+3
00057e 1f00                      	rol r16
00057f 9300 011c                 	sts arg+3,r16
000581 953a                      	dec r19
000582 f751                      	brne lp60
000583 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000584 93ef                      cmpstr:	push ZL
000585 93ff                      	push ZH
000586 93cf                      	push YL
000587 93df                      	push YH
                                 		
000588 018f                      	movw r17:r16,ZH:ZL  ;LPM only works with Z
000589 01fe                      	movw ZH:ZL,YH:YL
00058a 01e8                      	movw YH:YL,r17:r16
                                   	
00058b 9105                      lp07:	lpm r16,Z+
00058c 3f0f                      	cpi r16,0xFF	;Check end of string
00058d f021                      	breq jp07
00058e 9119                      	ld r17,Y+
00058f 1701                      	cp r16,r17
000590 f409                      	brne jp07	;Not equal,return
000591 cff9                      	rjmp lp07	;Next char
000592 91df                      jp07:	pop YH
000593 91cf                      	pop YL
000594 91ff                      	pop ZH
000595 91ef                      	pop ZL
000596 9508                      	ret		
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000597 e004                      mov4:	ldi r16,4		    ;
000598 9111                      lp01:	ld r17,Z+ 
000599 9319                      	st Y+,r17
00059a 950a                      	dec r16
00059b f7e1                      	brne lp01
00059c 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Add Dword pointed to by X & Y Result pointed to by X
                                 AddDword:
00059d 910c                      	ld r16,X
00059e 9119                      	ld r17,Y+
00059f 0f01                      	add r16,r17
0005a0 930d                      	st X+,r16
                                 
0005a1 910c                      	ld r16,X
0005a2 9119                      	ld r17,Y+
0005a3 1f01                      	adc r16,r17
0005a4 930d                      	st X+,r16
                                 
0005a5 910c                      	ld r16,X
0005a6 9119                      	ld r17,Y+
0005a7 1f01                      	adc r16,r17
0005a8 930d                      	st X+,r16
                                 
0005a9 910c                      	ld r16,X
0005aa 9119                      	ld r17,Y+
0005ab 1f01                      	adc r16,r17
0005ac 930d                      	st X+,r16
0005ad 9508                      	ret
                                 
                                 ; shift arg right per r19
0005ae 94e8                      LsrArg:	clt			
0005af 9100 011c                 lp61:	lds r16,arg+3
0005b1 9506                      	lsr r16
0005b2 9300 011c                 	sts arg+3,r16
0005b4 9100 011b                 	lds r16,arg+2
0005b6 9507                      	ror r16
0005b7 9300 011b                 	sts arg+2,r16
0005b9 9100 011a                 	lds r16,arg+1
0005bb 9507                      	ror r16
0005bc 9300 011a                 	sts arg+1,r16
0005be 9100 0119                 	lds r16,arg
0005c0 9507                      	ror r16
0005c1 9300 0119                 	sts arg,r16
0005c3 f408                      	brcc jp61
0005c4 9468                      	set		;Set t bit if carry
0005c5 953a                      jp61:	dec r19
0005c6 f741                      	brne lp61
0005c7 9508                      	ret
                                 	


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega162" register use summary:
x  :  11 y  :  12 z  :  46 r0 :  11 r1 :   8 r2 :   5 r3 :   5 r4 :   6 
r5 :   3 r6 :   2 r7 :   2 r8 :   2 r9 :   2 r10:   2 r11:   0 r12:   0 
r13:   2 r14:   2 r15:   7 r16: 482 r17:  64 r18:  12 r19:  24 r20:  12 
r21:   8 r22:   2 r23:   2 r24:   2 r25:   2 r26:   8 r27:   8 r28:  25 
r29:  26 r30:  55 r31:  53 
Registers used: 33 out of 35 (94.3%)

"ATmega162" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  14 add   :  11 adiw  :  11 and   :   0 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  11 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  84 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  20 cbr   :   2 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  53 cls   :   0 
clt   :   1 clv   :   0 clz   :   2 com   :   1 cp    :   6 cpc   :   0 
cpi   :  43 cpse  :   0 dec   :  33 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  19 inc   :   9 jmp   :   4 
ld    :  38 ldd   :   0 ldi   : 191 lds   :  71 lpm   :   1 lsl   :   1 
lsr   :   2 mov   :   4 movw  :   3 mul   :   1 muls  :   0 mulsu :   0 
neg   :   1 nop   :   3 or    :   0 ori   :   0 out   :  23 pop   :  24 
push  :  26 rcall : 145 ret   :  42 reti  :   2 rjmp  :  36 rol   :   3 
ror   :   4 sbc   :   0 sbci  :   0 sbi   :  14 sbic  :   6 sbis  :   7 
sbiw  :   4 sbr   :   6 sbrc  :   5 sbrs  :   6 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   2 ses   :   0 set   :   1 sev   :   0 
sez   :   2 sleep :   0 spm   :   0 st    :  21 std   :   1 sts   : 152 
sub   :   2 subi  :   0 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 56 out of 113 (49.6%)

"ATmega162" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b90   2816     44   2860   16384  17.5%
[.dseg] 0x000100 0x0004cb      0    971    971    1024  94.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
