
AVRASM ver. 2.2.8  C:\Users\denni\Documents\Microchip Studio\7.0\TI_SD_Disk_Atmega162\TI_SD_Disk_Atmega162\main.asm Sat Jul 24 10:59:57 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m162def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m162def.inc'
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega162.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m162def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega162
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega162
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M162DEF_INC_
                                 #define _M162DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega162
                                 #pragma AVRPART ADMIN PART_NAME ATmega162
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x94
                                 .equ	SIGNATURE_002	= 0x04
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	UBRR1H	= 0x3c
                                 .equ	UCSR1C	= 0x3c
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	EMCUCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	TCCR2	= 0x27
                                 .equ	ASSR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	TCNT2	= 0x23
                                 .equ	OCR2	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRR0H	= 0x20
                                 .equ	UCSR0C	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	PORTE	= 0x07
                                 .equ	DDRE	= 0x06
                                 .equ	PINE	= 0x05
                                 .equ	OSCCAL	= 0x04
                                 .equ	OCDR	= 0x04
                                 .equ	UDR1	= 0x03
                                 .equ	UCSR1A	= 0x02
                                 .equ	UCSR1B	= 0x01
                                 .equ	UBRR1L	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 3	; Force Output Compare for Channel A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select1 bit 0
                                 .equ	CS11	= 1	; Clock Select1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Pulse Width Modulator Select Bit 1
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Forde Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE2	= 2	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 4	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 2	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 4	; Output Compare Flag 2
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 3B
                                 .equ	OCF3A	= 4	; Output Compare Flag 3A
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	WGM31	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	FOC3B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC3A	= 3	; Force Output Compare for Channel A
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select3 bit 0
                                 .equ	CS31	= 1	; Clock Select3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	WGM33	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR	= UDR0	; For compatibility
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	USR	= UCSR0A	; For compatibility
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	U2X	= U2X0	; For compatibility
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	DOR	= DOR0	; For compatibility
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	FE	= FE0	; For compatibility
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	UDRE	= UDRE0	; For compatibility
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	TXC	= TXC0	; For compatibility
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 .equ	RXC	= RXC0	; For compatibility
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	UCR	= UCSR0B	; For compatibility
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	TXB8	= TXB80	; For compatibility
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	RXB8	= RXB80	; For compatibility
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	TXEN	= TXEN0	; For compatibility
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	RXEN	= RXEN0	; For compatibility
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	UDRIE	= UDRIE0	; For compatibility
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	TXCIE	= TXCIE0	; For compatibility
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 .equ	RXCIE	= RXCIE0	; For compatibility
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UBRRHI	= UCSR0C	; For compatibility
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 .equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 ;.equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= UBRR0L	; For compatibility
                                 .equ	UBRR	= UBRR0L	; For compatibility
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART1 I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART1 I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART1 I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART1 I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART1 I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART1 I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART1 I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART1 I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	CHR91	= UCSZ12	; For compatibility
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 .equ	URSEL1	= 7	; Register Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Highg Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ;.equ	UBRR1	= UBRR1L	; For compatibility
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 1
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SM	= SM1	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRW	= SRW10	; For compatibility
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	SM2	= 5	; Sleep Mode Select Bit 2
                                 .equ	JDT	= 7	; JTAG Interface Disable
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 .equ	ISC2	= 0	; Interrupt Sense Control 2
                                 .equ	SRW11	= 1	; Wait State Select Bit 1 for Upper Sector
                                 .equ	SRW00	= 2	; Wait State Select Bit 0 for Lower Sector
                                 .equ	SRW01	= 3	; Wait State Select Bit 1 for Lower Sector
                                 .equ	SRL0	= 4	; Wait State Sector Limit Bit 0
                                 .equ	SRL1	= 5	; Wait State Sector Limit Bit 1
                                 .equ	SRL2	= 6	; Wait State Sector Limit Bit 2
                                 .equ	SM0	= 7	; Sleep mode Select Bit 0
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 
                                 ; CLKPR - Clock prescale register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR310	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSR310	; For compatibility
                                 .equ	PSR0	= PSR310	; For compatibility
                                 .equ	PSR1	= PSR310	; For compatibility
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	XMM0	= 3	; External Memory High Mask Bit 0
                                 .equ	XMM1	= 4	; External Memory High Mask Bit 1
                                 .equ	XMM2	= 5	; External Memory High Mask Bit 2
                                 .equ	XMBK	= 6	; External Memory Bus Keeper Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter 0 Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter 0 Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Timer/Counter 0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0	= 0	; Timer/Counter0 Output Compare Match Interrupt register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0	= 0	; Output Compare Flag 0
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 ;.equ	ISC2	= 0	; Interrupt Sense Control 2
                                 
                                 ; GICR - General Interrupt Control Register
                                 .equ	EIMSK	= GICR	; For compatibility
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PCIE0	= 3	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 4	; Pin Change Interrupt Enable 1
                                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	PCIF0	= 3	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 4	; Pin Change Interrupt Flag 1
                                 .equ	INTF2	= 5	; External Interrupt Flag 2
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 1	; Brown out detector trigger level
                                 .equ	BODLEVEL1	= 2	; Brown out detector trigger level
                                 .equ	BODLEVEL2	= 3	; Brown out detector trigger level
                                 .equ	M161C	= 4	; ATMega 161 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x04ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 16384
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1c00
                                 .equ	NRWW_STOP_ADDR	= 0x1fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1bff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x1f80
                                 .equ	SECONDBOOTSTART	= 0x1f00
                                 .equ	THIRDBOOTSTART	= 0x1e00
                                 .equ	FOURTHBOOTSTART	= 0x1c00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	PCI0addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	ICP3addr	= 0x000c	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x000e	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0010	; Timer/Counter3 Compare Match B
                                 .equ	OVF3addr	= 0x0012	; Timer/Counter3 Overflow
                                 .equ	OC2addr	= 0x0014	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0016	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0018	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x001a	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001c	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001e	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x0020	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0022	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0024	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0026	; USART0, Rx Complete
                                 .equ	URXC1addr	= 0x0028	; USART1, Rx Complete
                                 .equ	UDRE0addr	= 0x002a	; USART0 Data register Empty
                                 .equ	UDRE1addr	= 0x002c	; USART1, Data register Empty
                                 .equ	UTXC0addr	= 0x002e	; USART0, Tx Complete
                                 .equ	UTXC1addr	= 0x0030	; USART1, Tx Complete
                                 .equ	ERDYaddr	= 0x0032	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0034	; Analog Comparator
                                 .equ	SPMRaddr	= 0x0036	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 56	; size in words
                                 
                                 #endif  /* _M162DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 ;    TI SD Disk.asm
                                 ;
                                 ; Created: 1/1/2019 3:45:02 PM
                                 ; Author : Dennis Hatton
                                 ;
                                 ; Fuses FF D9 FF
                                 ; 16mhz ext crystal
                                 ;
                                 ;   Atmega8515 Converted to Atmega162		
                                 ;    PortA	PortB	    Portc	PortD	    PortE			
                                 ;    0<Data0	0<A0	    0>Data0	0<RXD	    0<!INT2			
                                 ;    1<Data1	1<A1	    1>Data1	1>TXD	    1<!WE		
                                 ;    2<Data2	2<	    2>Data2	2<	    2>!ready			
                                 ;    3<Data3	3<	    3>Data3	3>HLD			
                                 ;    4<Data4	4>CS	    4>Data4	4<Drive1
                                 ;    5<Data5	5>MOSI	    5>Data5	5<Drive2    
                                 ;    6<Data6	6<MISO	    6>Data6	6<Drive3
                                 ;    7<Data7	7>SCK	    7>Data7	7<Side   
                                 ;
                                 ; IN PINx
                                 ; OUT PORTx
                                 ; OUT PINx turns on pullup						
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
                                 
                                 			
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Equates
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PortE bits
                                 			.equ intbit = PE0
                                 			.equ webit = PE1
                                 			.equ rdybit = PE2
                                 			
                                 ; Dedicated registers			
                                 ; INT2:	XL XH r13 r14			
                                 ; SD error count: r10			
                                 ; Save arg: r6-r9
                                 ;			
                                 		
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.DSEG
                                 fdcRegisters:
000100                           fdcStatus:	.byte 1			;TI 5FF0 Read Status
000101                           fdcTrack:	.byte 1			;TI 5FF2/5FFA Rd/Wr Track Register
000102                           fdcSector:	.byte 1			;TI 5FF4/5FFC Rd/Wr Sector Register
000103                           fdcData:	.byte 1			;TI 5FF6/5FFE Rd/Wr Data Register
000104                           fdcCommand:	.byte 1			;TI 5FF8 Write Command Register
000105                           fdcSide:	.byte 1			;	
                                 
000106                           flags:		.byte 1			;flags + address
                                 			.equ iflag = 7	;1 int occured
                                 			.equ wflag = 2	;1 write occured
                                 
000107                           DSK1address:	.byte	4	;LSB -- MSB			
00010b                           DSK2address:	.byte	4	;LSB -- MSB
00010f                           DSK3address:	.byte	4	;LSB -- MSB
000113                           DSK1LastTrk:	.byte	1
000114                           DSK2LastTrk:	.byte	1
000115                           DSK3LastTrk:	.byte	1
000116                           TIlowbyte:	.byte	1
                                 	
                                 	
                                 ;SD variables
                                 		.equ CS = PB4
000117                           ocr:		.byte	1
                                 		.equ ccs = 6	;bit 6
000118                           cmd:		.byte	1
000119                           arg:		.byte	4	;LSB -- MSB		
00011d                           crc:		.byte	1
00011e                           resp:		.byte	1
                                 
                                 SectorsPerCluster:		;in Powers of 2 (Number of left shifts to use)
00011f                           		.byte	1
000120                           Offset:		.byte	4	;LSB -- MSB	
000124                           StartSector:	.byte	2
000126                           StepSectors:	.byte	2
                                 	
000128                           SerRecvWrPtr:	.byte	1
000129                           SerRecvRdPtr:	.byte	1
00012a                           SerBufCnt:	.byte	1
                                 	
                                 ;Use buffer to calc end of fdcRegisters variables to send to USART intr
00012b                           Serbuffer:	.byte	128
0001ab                           TIbuffer:	.byte	256
0002ab                           SDbuffer:	.byte	512
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Interrupts vector tables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 	.CSEG		;8515 use rjmp 162 use jmp
                                 	.org $000
000000 940c 00df                 	jmp setup	;Reset Handler
                                 	.org URXC0addr	;8515 URXCaddr,162 URXC0addr
000026 940c 0054                 	jmp USART_RXC	;USART RX Complete Handler  
                                 	.org INT2addr
000006 940c 0038                 	jmp EXT_INT2	;IRQ2 Handler
                                 	
                                 
                                 ;Interrupt Service Routines
                                 	.org INT_VECTORS_SIZE		;End of Int vector table
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; IRQ2 Interrupt Handler
                                 ; XH XL r13 r14 r15 not saved
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; cycle = 62.5ns
                                 EXT_INT2:
000038 b6df                          	in r13,SREG			;Save SREG			1
000039 2ee0                      	mov r14,r16			;				1
00003a b306                      	in r16,PinB			;Get FDC address		1
00003b 7003                      	andi r16,0x03			;				1
00003c 24ff                      	clr r15				;				1								
00003d e0b1                      	ldi XH,high(fdcRegisters)	;Point X to FDC_Registers base	1
00003e e0a0                      	ldi XL,low(fdcRegisters)	; "				1
00003f 0fa0                      	add XL,r16			;add FDC address offset		1
000040 1dbf                      	adc XH,r15			; "				1
000041 90fc                      	ld r15,X			;Get data in FDC register	2
000042 bafb                      	out PortA,r15			;Send it to TI			1
000043 6800                      	sbr r16,1<<iflag		;Set our interrupt flag		1
000044 0000                      	nop				;				1
000045 0000                      	nop				;				1
                                  ;Need 13-19 cycles to here,Min 15 without errors			15
                                 	
000046 9929                      	sbic PinE,webit		;Test !we
000047 c007                      	rjmp isr2end			;Read if 1
000048 b2f3                      	in r15,PinC			;Get  write data
000049 94f0                      	com r15				;TI sends inverted data
00004a 6004                      	sbr r16,1<<wflag		;Set write flag
00004b 3804                      	cpi r16,0x84			;Check If Command
00004c f409                      	brne NotCMD			; "
00004d 9614                      	adiw X,4			;Point to Command registers
                                 NotCMD:	
00004e 92fc                      	st X,r15			;Write data to FDC register
                                 isr2end:
00004f 9300 0106                 	sts flags,r16			;
000051 2d0e                      	mov r16,r14			;
000052 bedf                      	out SREG,r13			;Restore SREG	
000053 9518                      	reti
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; USART RX Complete Interrupt Handler	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 USART_RXC:
000054 930f                      	push r16
000055 b70f                      	in r16,SREG	;Push SREG
000056 930f                      	push r16	; "
000057 931f                      	push r17
000058 93ff                      	push ZH
000059 93ef                      	push ZL
                                 	
                                 ;Move Stat & Char to buffer
00005a 9100 012a                 	lds r16,SerBufCnt
00005c 9503                      	inc r16
00005d 9300 012a                 	sts SerBufCnt,r16
                                 
00005f e0f1                      	ldi ZH,high(Serbuffer)
000060 e2eb                      	ldi ZL,low(Serbuffer)
000061 9100 0128                 	lds r16,SerRecvWrPtr
000063 0fe0                      	add ZL,r16
000064 2711                      	clr r17
000065 1ff1                      	adc ZH,r17
                                 	
000066 9503                      	inc r16
000067 9503                      	inc r16
000068 3800                      	cpi r16,128
000069 f409                      	brne jp00
00006a 2700                      	clr r16
00006b 9300 0128                 jp00:	sts SerRecvWrPtr,r16
                                 
00006d b10b                      	in r16,UCSR0A		;Get status
00006e 9301                      	st Z+,r16		;Put in buffer
00006f b10c                      	in r16,UDR		;Get data (We know data is there because of Recv interrupt)
000070 8300                      	st Z,r16		;Put in buffer
                                 	
                                 ;Check If AT+#xCRLF is in buffer (x is Char used below)
000071 300a                      	cpi r16,10	;check if LF
000072 f479                      	brne jp09
                                 	
000073 9732                      	sbiw Z,2
000074 8100                      	ld r16,Z
000075 300d                      	cpi r16,13	;check if CR
000076 f459                      	brne jp09
                                 
000077 9738                      	sbiw Z,8
000078 8100                      	ld r16,Z
000079 3401                      	cpi r16,'A'	;
00007a f439                      	brne jp09
                                 
00007b 9632                      	adiw Z,2
00007c 8100                      	ld r16,Z
00007d 3504                      	cpi r16,'T'	;
00007e f419                      	brne jp09
                                 
00007f 9632                      	adiw Z,2
000080 8100                      	ld r16,Z
000081 3203                      	cpi r16,'#'	;
000082 f5f9                      jp09:	brne RXCIntRtn
                                 	
000083 9632                      	adiw Z,2	;Save char at end of AT#x
000084 8100                      	ld r16,Z	; "
                                 
000085 93df                      	push YH
000086 93cf                      	push YL
000087 93bf                      	push XH
000088 93af                      	push XL
000089 939f                      	push r25
00008a 938f                      	push r24
00008b 937f                      	push r23
00008c 936f                      	push r22
00008d 935f                      	push r21
00008e 934f                      	push r20
00008f 933f                      	push r19
000090 932f                      	push r18
                                 chkR:	
000091 3502                      	cpi r16,'R'		    ;Send reg 16-31,SREG,Ret PC
000092 f429                      	brne chkS
000093 b7fe                      	in ZH,SPH
000094 b7ed                      	in ZL,SPL
000095 9631                      	adiw Z,1
000096 e113                      	ldi r17,19
000097 c01a                      	rjmp TXLP0
                                 chkS:	
000098 3503                      	cpi r16,'S'		    ;Send all calls on stack
000099 f439                      	brne chkU
00009a b7fe                      	in ZH,SPH
00009b b7ed                      	in ZL,SPL
00009c 9671                      	adiw Z,17
00009d ef1f                      	ldi r17,low(RAMEND)
00009e 1b1e                      	sub r17,ZL
00009f 9631                      	adiw Z,1
0000a0 c011                      	rjmp TXLP0
                                 chkU:
0000a1 3505                       	cpi r16,'U'		    ;Send Serial buffer
0000a2 f421                      	brne chkT
0000a3 e810                      	ldi r17,128
0000a4 e0f1                      	ldi ZH,high(Serbuffer)	    ; Get address to Serial buffer
0000a5 e2eb                      	ldi ZL,low(Serbuffer)	    ; "
0000a6 c00b                      	rjmp TXLP0	
                                 chkT:
0000a7 3504                       	cpi r16,'T'		    ;Send TIbuffer
0000a8 f421                      	brne chkV
0000a9 2711                      	clr r17
0000aa e0f1                      	ldi ZH,high(TIbuffer)	    ; Get address to TIbuffer
0000ab eaeb                      	ldi ZL,low(TIbuffer)	    ; "
0000ac c005                      	rjmp TXLP0
                                 chkV:
0000ad 3506                       	cpi r16,'V'	;Send all sram (variables) except buffers
0000ae f439                      	brne jp13
0000af e21b                      	ldi r17,Serbuffer-fdcRegisters ;Count between fdcRegisters & buffers
0000b0 e0f1                      	ldi ZH,high(fdcRegisters)  ; Get sram start address
0000b1 e0e0                      	ldi ZL,low(fdcRegisters)   ; "
                                 TXLP0:	
0000b2 9101                      	ld r16,Z+
0000b3 d23b                      	rcall USARTWrite	    ; Send data byte
0000b4 951a                      	dec R17
0000b5 f7e1                      	brne TXLP0
                                 	
                                 jp13:
0000b6 912f                      	pop r18
0000b7 913f                      	pop r19
0000b8 914f                      	pop r20
0000b9 915f                      	pop r21
0000ba 916f                      	pop r22
0000bb 917f                      	pop r23
0000bc 918f                      	pop r24
0000bd 919f                      	pop r25
0000be 91af                      	pop XL
0000bf 91bf                      	pop XH
0000c0 91cf                      	pop YL
0000c1 91df                      	pop YH
                                 	
                                 RXCIntRtn:	
0000c2 91ef                      	pop ZL
0000c3 91ff                      	pop ZH
0000c4 911f                      	pop r17
0000c5 910f                      	pop r16		;pop SREG
0000c6 bf0f                       	out SREG,r16	; "
0000c7 910f                      	pop r16
0000c8 9518                        	reti	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Constants
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Use to access program memory	
                                 ; ldi ZH,high(hello<<1)	;Shift (address*2) because program memory is 16 bits
                                 ; ldi ZL,low(hello<<1)	;When address bit0 is 0 low byte of word is accessed
                                 ; lpm r16,Z+		;When address bit0 is 1 high byte of word is accessed
                                 ;			;Effectively changing to byte access
                                 ;hello:
                                 ;	.db "HELLO",0
0000c9 76eb
0000ca 4590
0000cb 4658
0000cc 5441
0000cd 00ff                      EXFATstr: .db 0xEB,0x76,0x90,"EXFAT",0xFF,0 ;make even bytes
0000ce 00c1
0000cf 0056
0000d0 004f
0000d1 004c
0000d2 0055
0000d3 004d
0000d4 0045
0000d5 ff53                      VOLstr:	.db 0xC1,0,'V',0,'O',0,'L',0,'U',0,'M',0,'E',0,'S',0xFF
0000d6 00c1
0000d7 0054
0000d8 0049
0000d9 0056
0000da 004f
0000db 004c
0000dc 0030
0000dd 0030
0000de ff30                      TIVOLstr: .db 0xC1,0,'T',0,'I',0,'V',0,'O',0,'L',0,'0',0,'0',0,'0',0xFF
                                  
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Setup
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 setup:
0000df ef0f                      	ldi r16,low(RAMEND)		;Init stack
0000e0 bf0d                      	out spl,r16			;	"
0000e1 e004                      	ldi r16,high(RAMEND)		;	"
0000e2 bf0e                      	out sph,r16			;	"
                                 ;Setup ports
0000e3 ef0f                      	ser	r16			;PortA (FF) output mode for TI read
0000e4 bb0a                      	out DDRA,r16			; "
0000e5 2700                      	clr	r16			;PortC (00) input mode for TI write
0000e6 bb04                      	out DDRC,r16			; "
0000e7 eb00                      	ldi	r16,0b10110000		;SCK,MI,MO,CS,0,0,A1,A0
0000e8 bb07                      	out DDRB,r16			;O  ,I ,O ,O ,I,I,I ,I
0000e9 9ac6                      	sbi PortB,PB6			;Pullup MISO
0000ea e00a                      	ldi	r16,0b00001010		;Side,DR3,DR2,DR1,HLD,0,TDX,RXD
0000eb bb01                      	out DDRD,r16			;I   ,I  ,I  ,I  ,O  ,I,O  ,I
0000ec e004                      	ldi	r16,0b00000100		;0,0,0,0,0,!Ready,!WE,!INT
0000ed b906                      	out DDRE,r16			;I,I,I,I,I,O     ,I  ,I
0000ee 983a                      	cbi PortE,rdybit		;Ready to TI
                                 
0000ef b706                      	in r16,EMCUCR			;Set INT2 falling edge trigger
0000f0 7f0e                      	cbr r16,1<<ISC2		; " ISC2=bit0 same as andi r16,0xFE
0000f1 bf06                      	out EMCUCR,r16			; "
0000f2 b70b                      	in r16,GICR			;Enable INT2
0000f3 6200                      	sbr r16,1<<INT2		; " INT2=bit5 same as ori r16,32
0000f4 bf0b                      	out GICR,r16			; "	
                                 ;Set status				;NotReady  track0  busy
0000f5 e004                      	ldi r16,0x04			;b7=0      b3=1    b0=0
0000f6 9300 0100                 	sts fdcStatus,r16		;
0000f8 2700                      	clr r16				; 
0000f9 9300 0101                 	sts fdcTrack,r16		;
0000fb 9300 0102                 	sts fdcSector,r16		;
0000fd 9300 0103                 	sts fdcData,r16		;
0000ff 9300 0104                 	sts fdcCommand,r16		;
000101 9893                      	cbi PortD,3			;data not ready
                                 ;Setup USART				;baud @ 16MHz (Using double baud rate)
000102 e010                      	ldi r17,0			;230.4k=0,8 115.2k=0,16
000103 e100                      	ldi r16,16			;
000104 d1dd                      	rcall USARTInit	
000105 b10a                      	in r16,UCSR0B			;Enable RXC interrupt
000106 6800                      	sbr r16,1<<RXCIE		; "
000107 b90a                      	out UCSR0B,r16			; "	
                                 ;Setup SPI
000108 e100                      	ldi r16,16
000109 2ea0                      	mov r10,r16			;SD error count,So it doesn't run away
00010a d220                      	rcall SPIInit  
00010b d2f8                      	rcall MMCInit
                                 ;Setup Drives	
                                 SetupStartStep:  
00010c d22b                      	rcall FindTIVOL		;Find TIVOL000,Save Start and Step
00010d f019                      	breq SetupDSK
00010e e800                      	ldi r16,0x80		;disk error,not ready
00010f 9300 0100                 	sts fdcStatus,r16	;
                                 ;Get DSKx addresses from SD sector 1    
                                 SetupDSK:
000111 e001                      	ldi r16,0x01
000112 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
000114 2700                       	clr r16
000115 9300 011a                 	sts arg+1,r16
000117 9300 011b                 	sts arg+2,r16
000119 9300 011c                 	sts arg+3,r16		; (MSB)
00011b d3e7                      	rcall ReadMMC           ; First half 512 sector (uses ZL & ZH)
                                 	
                                 ;XL & XH ok to use before interrupts are enabled    	
00011c eaef                      	ldi ZL,low(SDbuffer+4)	    ;
00011d e0f2                      	ldi ZH,high(SDbuffer+4)	    ;
                                 
00011e 9101                      	ld r16,Z+		    ;Get Drive 1 Disk #
00011f 930f                      	push r16		    ;		    
000120 9101                      	ld r16,Z+		    ;Get Drive 2 Disk #
000121 930f                      	push r16		    ;
000122 9101                      	ld r16,Z+		    ;Get Drive 3 Disk #
000123 930f                      	push r16
                                 	
000124 e0cf                      	ldi YL,low(DSK3address)    ;
000125 e0d1                      	ldi YH,high(DSK3address)   ;
                                 	
000126 e023                      	ldi r18,3
000127 915f                      LP02:	pop r21			    ;Restore disk number (stepping 3 - 1)
000128 d19b                      	rcall Disk2Sector	    ;Convert disk # to sector address
000129 9209                      	st Y+,r0		    ;Save into DSKXaddress
00012a 9219                      	st Y+,r1		    ;
00012b 9229                      	st Y+,r2		    ;
00012c 9239                      	st Y+,r3		    ;
00012d 9728                      	sbiw Y,8		    ;Back to start of current drive + start preceding drive
00012e 952a                      	dec r18			    ;
00012f f7b9                      	brne LP02		    ;All 3 drives done 
                                 	
                                 ;Set last track for drives
000130 e0e7                      	ldi ZL,low(DSK1address)    ;LSB -- MSB
000131 e0f1                      	ldi ZH,high(DSK1address)   ;
000132 e1c9                      	ldi YL,low(arg)	    ;
000133 e0d1                      	ldi YH,high(arg)	    ;
000134 d447                      	rcall mov4		    ;
000135 d3cd                      	rcall ReadMMC 		    ;First half 512 sector (uses ZL & ZH)
000136 e207                      	ldi r16,39
000137 9110 02b5                 	lds r17,SDbuffer+10
000139 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
00013a e40f                      	ldi r16,79
00013b 9300 0113                 	sts DSK1LastTrk,r16
                                 	
00013d e0eb                      	ldi ZL,low(DSK2address)    ;LSB -- MSB
00013e e0f1                      	ldi ZH,high(DSK2address)   ;
00013f e1c9                      	ldi YL,low(arg)	    ;
000140 e0d1                      	ldi YH,high(arg)	    ;
000141 d43a                      	rcall mov4		    ;
000142 d3c0                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
000143 e207                      	ldi r16,39
000144 9110 02b5                 	lds r17,SDbuffer+10
000146 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000147 e40f                      	ldi r16,79
000148 9300 0114                 	sts DSK2LastTrk,r16
                                 	
00014a e0ef                      	ldi ZL,low(DSK3address)    ;LSB -- MSB
00014b e0f1                      	ldi ZH,high(DSK3address)   ;
00014c e1c9                      	ldi YL,low(arg)	    ;
00014d e0d1                      	ldi YH,high(arg)	    ;
00014e d42d                      	rcall mov4		    ;
00014f d3b3                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
000150 e207                      	ldi r16,39
000151 9110 02b5                 	lds r17,SDbuffer+10
000153 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000154 e40f                      	ldi r16,79
000155 9300 0115                 	sts DSK3LastTrk,r16
                                 	
                                 ;Enable interrupts	
000157 2700                      	clr r16				;Clear flags
000158 9300 0106                 	sts flags,r16			;
00015a 9300 0129                 	sts SerRecvRdPtr,r16		;Init Serial pointers
00015c 9300 0128                 	sts SerRecvWrPtr,r16
00015e 9300 012a                 	sts SerBufCnt,r16
000160 9478                      	sei				;Global enable interrupts
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Main Loop
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000161 2700                      main:	clr r16			    ; Clear busy,No errors	
000162 9300 0100                 JP02:	sts fdcStatus,r16	    ; "	     
000164 983a                      	cbi PortE,2		    ;Release TI
                                 	
000165 9100 0106                 LP00:	lds r16,flags		    ;Get flags
000167 ff07                      	sbrs r16,iflag		    ;Has TI has sent data?
000168 cffc                      	rjmp LP00
000169 2711                      	clr r17			    ;Clear flags
00016a 9310 0106                 	sts flags,r17		    ; "		    
                                 	
00016c 9100 0104                 	lds r16,fdcCommand	    ;
00016e 3000                      	cpi r16,0x00		    ;
00016f f3a9                      	breq LP00
                                 	
000170 9a3a                      	sbi PortE,2		    ;Put TI on hold while process command
000171 9310 0104                 	sts fdcCommand,r17	    ;Clear command (r17=0 from above)
                                 ;	ldi r17,0x01		    ;Set Busy bit
                                 ;	sts fdcStatus,r17	    ; "
                                 	
                                 ;	rcall USARTWrite	    ;Send command in r16 (enable for debbuging)
                                 	
                                 ;Our Mount Disk command	
                                 fdcCMD81:			    	
000173 3801                      	cpi r16,0x81		   
000174 f411                      	brne fdcCMD82
000175 d131                      	rcall ChgDisk
000176 cf9a                      	rjmp SetupDSK		    ;Setup disk addresses and last track
                                 ;Our Send all disk names command		
                                 fdcCMD82:			    
000177 3802                      	cpi r16,0x82		    
000178 f411                      	brne usartCMD83
000179 d106                      	rcall SendNames
00017a cfe6                      	rjmp main
                                 ;Read Usart status
                                 usartCMD83:			    
00017b 3803                      	cpi r16,0x83		    
00017c f411                      	brne usartCMD84
00017d d179                      	rcall TIrdUsartStat
00017e cfe2                      	rjmp main
                                 ;Read Usart data
                                 usartCMD84:			    
00017f 3804                      	cpi r16,0x84		    
000180 f411                      	brne usartCMD85
000181 d188                      	rcall TIrdUsartData
000182 cfde                      	rjmp main
                                 ;Write Usart data
                                 usartCMD85:			    
000183 3805                      	cpi r16,0x85		    
000184 f411                      	brne fdcCMD0A
000185 d19f                      	rcall TIwrUsartData
000186 cfda                      	rjmp main
                                 ;0A Restore (h=1,V=0,r0r1=10)	
                                 fdcCMD0A:			   
000187 300a                      	cpi r16,0x0A		    ;
000188 f439                      	brne fdcCMD1E
000189 2700                      	clr r16			    ;
00018a 9300 0101                 	sts fdcTrack,r16	    ;Set to track 0
00018c 9300 0102                 	sts fdcSector,r16	    ;Set to sector 0
00018e 6004                      	sbr r16,0x04		    ;Set track 0 in status
00018f cfd2                      	rjmp JP02
                                 ;1E Seek h=1 V=1 r1r0=10
                                 fdcCMD1E:			    
000190 310e                      	cpi r16,0x1E		    ;
000191 f429                      	brne fdcCMD5A
000192 9100 0103                 	lds r16,fdcData
000194 9300 0101                 	sts fdcTrack,r16
000196 cfca                      	rjmp main
                                 ;2x Step not used by TI
                                 ;5A Step-in T=1,h=1,V=0,r0r1=10	
                                 fdcCMD5A:			    
000197 350a                      	cpi r16,0x5A		    ;
000198 f431                      	brne fdcCMD88
000199 9100 0101                 	lds r16,fdcTrack
00019b 9503                      	inc r16
00019c 9300 0101                 	sts fdcTrack,r16
00019e cfc2                      	rjmp main
                                 ;6x Step-out not used by TI
                                 ;88 Read sector m=0 S=1 E=0 C=0		    
                                 fdcCMD88:			    
00019f 3808                         	cpi r16,0x88		    ;
0001a0 f411                      	brne fdcCMDA8
0001a1 d042                      	rcall TIreadsec
0001a2 cfbe                      	rjmp main
                                 ;A8 Write sector m=0 S=1 E=0 C=0 a=0
                                 fdcCMDA8:			    
0001a3 3a08                      	cpi r16,0xA8		    ;
0001a4 f411                      	brne fdcCMDC0
0001a5 d02b                      	rcall TIwritesec
0001a6 cfba                      mainRLY: rjmp main
                                 ;C0 Read ID E=0
                                 fdcCMDC0:			    
0001a7 3c00                      	cpi r16,0xC0		    ;
0001a8 f411                      	brne fdcCMDF4
0001a9 d009                      	rcall TIreadID
0001aa cfb6                      	rjmp main
                                 ;Ex Read track not used by TI
                                 ;F4 Write track (E=1)
                                 fdcCMDF4:			    
0001ab 3f04                          	cpi r16,0xF4		    ;
0001ac f411                      	brne fdcCMDD0
0001ad d0ac                      	rcall TIwritetrack
0001ae cff7                      	rjmp mainRLY
                                 ;D0 Force interrupt
                                 fdcCMDD0:			    
0001af 3d00                          	cpi r16,0xD0		    ;Sent after software reset (FTCN =)
0001b0 f7a9                      	brne mainRLY
0001b1 d382                      	rcall delay1ms
0001b2 cf5e                      	rjmp SetupDSK		    ;Setup disks in case one was formatted
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadID:
0001b3 983a                      	cbi PortE,2		;Release TI
0001b4 9100 0101                 	lds r16,fdcTrack	;Get track
0001b6 9300 0103                 	sts fdcData,r16		;Send to TI
0001b8 d072                      	rcall WaitTIread	; "
0001b9 2700                      	clr r16			;Side 0
0001ba 9987                      	sbic PinD,7		;Get Side
0001bb 9503                      	inc r16			;Side 1
0001bc 9300 0103                 	sts fdcData,r16		;Send to TI
0001be d06c                      	rcall WaitTIread	; "
0001bf 9100 0102                 	lds r16,fdcSector	;Get sector
0001c1 9300 0103                 	sts fdcData,r16		;Send to TI
0001c3 d067                      	rcall WaitTIread	; "
0001c4 2700                      	clr r16			;Sector lenght code?
0001c5 9300 0103                 	sts fdcData,r16		;Send to TI
0001c7 d063                      	rcall WaitTIread	; "
0001c8 2700                      	clr r16			;CRC byte1
0001c9 9300 0103                 	sts fdcData,r16		;Send to TI
0001cb d05f                      	rcall WaitTIread	; "
0001cc 2700                      	clr r16			;CRC byte2
0001cd 9300 0103                 	sts fdcData,r16		;Send to TI
0001cf d05b                      	rcall WaitTIread	; "
0001d0 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritesec:
0001d1 e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
0001d2 eaeb                      	ldi ZL,low(TIbuffer)	; "
0001d3 e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001d4 983a                      	cbi PortE,2		;Release TI
0001d5 d05f                      lp24:	rcall WaitTIwrite	;Wait for data from TI
0001d6 9100 0103                 	lds r16,fdcData	;Get next byte
0001d8 9301                      	st Z+,r16		;Save to buffer
0001d9 952a                      	dec r18
0001da f7d1                      	brne LP24
                                 	
0001db 9a3a                      	sbi PortE,2		;Put TI on hold while process command
0001dc e001                      	ldi r16,1
0001dd 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
0001de 2700                      	clr r16
0001df 9300 0105                 	sts fdcSide,r16
0001e1 d014                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001e2 d06b                      	rcall TI_SD_wr		;Write to SD
0001e3 9508                      	ret	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadsec:
0001e4 e001                      	ldi r16,1
0001e5 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
0001e6 2700                      	clr r16
0001e7 9300 0105                 	sts fdcSide,r16
0001e9 d00c                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001ea d054                      	rcall TI_SD_rd		;Get sector from SD
0001eb e0f1                      	ldi ZH,high(TIbuffer)	; Get address to buffer
0001ec eaeb                      	ldi ZL,low(TIbuffer)	; "
0001ed e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001ee 983a                      	cbi PortE,2		;Release TI
0001ef 9101                      lp13:	ld r16,Z+		;Get next byte
0001f0 9300 0103                 	sts fdcData,r16		;Send to TI
0001f2 d038                      	rcall WaitTIread	; "
0001f3 952a                      	dec r18
0001f4 f7d1                      	brne LP13
0001f5 9508                      	ret
                                 ;	
                                 ;Convert TI track&sector to SD sector	
                                 Track2Arg:
0001f6 9100 0101                 	lds r16,fdcTrack
0001f8 9110 0105                 	lds r17,fdcSide
0001fa ff10                      	sbrs r17,0		;Test bit,Skip if side 1	
0001fb c00c                      	rjmp j00
0001fc 9110 0113                 	lds r17,DSK1LastTrk	;
0001fe 9985                      	sbic PinD,5		;
0001ff 9110 0114                 	lds r17,DSK2LastTrk	;
000201 9986                      	sbic PinD,6		;
000202 9110 0115                 	lds r17,DSK3LastTrk	;
000204 1b01                      	sub r16,R17		;Reverse track (0=-39 or -79) 
000205 9501                      	neg r16			;Make postive
000206 9513                      	inc r17			;
000207 0f01                      	add r16,r17		;Track + 40 or 80
                                 j00:	
000208 e019                      	ldi r17,9		;Track*9
000209 9f01                      	mul r16,r17		;Result in r0 r1
00020a 2711                      	clr r17			;Add sector offset 0-8		
00020b 9100 0102                 	lds r16,fdcSector	; "
00020d 0e00                      	add r0,r16		; "
00020e 1e11                      	adc r1,r17		; "
                                 	
                                 	;Divide TI sector by 2 to put in upper or lower half of SD sector
00020f 9200 0116                 	sts TIlowbyte,r0 	;save low byte for bit 0 test
000211 9416                      	lsr r1			;Divide 16 bits by 2
000212 9407                      	ror r0			; "	"	"
                                 	
                                 	;Add TI sector to DSKx SD start sector address and place in ARG
000213 e0f1                      	ldi ZH,high(DSK1address)   ;
000214 e0e7                      	ldi ZL,low(DSK1address)    ;
000215 9985                      	sbic PinD,5		    ;
000216 9634                      	adiw Z,4		    ;DSK2address
000217 9986                      	sbic PinD,6		    ;
000218 9638                      	adiw Z,8		    ;DSK3address
                                 
000219 9101                      	ld r16,Z+
00021a 0d00                      	add r16,r0
00021b 9300 0119                 	sts arg,r16
00021d 9101                      	ld r16,Z+
00021e 1d01                      	adc r16,r1
00021f 9300 011a                 	sts arg+1,r16
000221 2400                      	clr r0			;carry not affected
000222 9101                      	ld r16,Z+
000223 1d00                      	adc r16,r0
000224 9300 011b                 	sts arg+2,r16
000226 8100                      	ld r16,Z
000227 1d00                      	adc r16,r0
000228 9300 011c                 	sts arg+3,r16
00022a 9508                      	ret
                                 ;	
                                 WaitTIread:
00022b 9100 0106                 	lds r16,flags		;Get flags
00022d ff07                      	sbrs r16,iflag		;Has TI read data?
00022e cffc                      	rjmp WaitTIread
00022f 2711                      	clr r17			;Clear interrupt flag
000230 9310 0106                 	sts flags,r17		; "
000232 3803                      	cpi r16,0x83		;Was it read data register
000233 f7b9                      	brne WaitTIread
000234 9508                      	ret
                                 WaitTIwrite:
000235 9100 0106                 	lds r16,flags		;Get flags
000237 ff07                      	sbrs r16,iflag		;Has TI written data?
000238 cffc                      	rjmp WaitTIwrite
000239 2711                      	clr r17			;Clear interrupt flag
00023a 9310 0106                 	sts flags,r17		; "
00023c 3807                      	cpi r16,0x87		;Was it write data register
00023d f7b9                      	brne WaitTIwrite
00023e 9508                      	ret
                                 	
                                 TI_SD_rd:
00023f d2c3                      	rcall readmmc		;512 bytes in sdbuffer
000240 eaeb                      	ldi ZL,low(SDbuffer)
000241 e0f2                      	ldi ZH,high(SDbuffer)
000242 9100 0116                 	lds r16,TIlowbyte
000244 fd00                      	sbrc r16,0
000245 95f3                      	inc ZH			;Add 256 to Z
000246 eacb                      	ldi YL,low(TIbuffer)
000247 e0d1                      	ldi YH,high(TIbuffer)
                                 ;Move 256 bytes from source(Z) to destination(Y)
000248 2700                      mov256:	clr r16		
000249 9111                      LP03:	ld r17,Z+ 
00024a 9319                      	st Y+,r17
00024b 950a                      	dec r16
00024c f7e1                      	brne LP03
00024d 9508                      	ret	;and send to TI
                                 TI_SD_wr:
00024e d2b4                      	rcall readmmc	//512 bytes in sdbuffer
00024f eaeb                      	ldi ZL,low(TIbuffer)
000250 e0f1                      	ldi ZH,high(TIbuffer)
000251 eacb                      	ldi YL,low(SDbuffer)
000252 e0d2                      	ldi YH,high(SDbuffer)
000253 9100 0116                 	lds r16,TIlowbyte
000255 fd00                      	sbrc r16,0
000256 95d3                      	inc YH			;Add 256 to Y
000257 dff0                      	rcall mov256
000258 d277                      	rcall writemmc	//512 bytes in sdbuffer
000259 9508                      	ret	
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritetrack:
00025a e049                      	ldi r20,9
                                 LP25:	
00025b 983a                      	cbi PortE,2		;Release TI
                                 	
                                 ;Get (FE,Track,Side,Sector,1?,F7)	
                                 LP26:	
00025c dfd8                      	rcall WaitTIwrite	;Wait for data from TI
00025d 9100 0103                 	lds r16,fdcData		;Get next byte
00025f 3f0e                      	cpi r16,0xFE
000260 f7d9                      	brne LP26
                                 	
000261 dfd3                      	rcall WaitTIwrite	;Throw away Track,already loaded
                                 
000262 dfd2                      	rcall WaitTIwrite	;Wait for data from TI
000263 9100 0103                 	lds r16,fdcData	
                                 ;	ror r16			;Move bit0 to bit7
                                 ;	ror r16			; "
000265 9300 0105                 	sts fdcSide,r16		;Save Side
                                 	
000267 dfcd                      	rcall WaitTIwrite	;Wait for data from TI
000268 9100 0103                 	lds r16,fdcData	
00026a 9300 0102                 	sts fdcSector,r16	;Save Sector
                                 
                                 ;Get (FB,256 bytes E5,F7)	
                                 LP27:	
00026c dfc8                      	rcall WaitTIwrite	;Wait for data from TI
00026d 9100 0103                 	lds r16,fdcData		;Get next byte
00026f 3f0b                      	cpi r16,0xFB
000270 f7d9                      	brne LP27
                                 	
000271 e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
000272 eaeb                      	ldi ZL,low(TIbuffer)	; "
000273 e020                      	ldi r18,0x00		;256 bytes per sector
                                 lp28:	
000274 dfc0                      	rcall WaitTIwrite	;Wait for data from TI
000275 9100 0103                 	lds r16,fdcData	;Get next byte
000277 9301                      	st Z+,r16		;Save to buffer
000278 952a                      	dec r18
000279 f7d1                      	brne LP28
                                 	
00027a 9a3a                      	sbi PortE,2		;Put TI on hold while process command
00027b df7a                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
00027c dfd1                      	rcall TI_SD_wr		;Write to SD
                                 	
00027d 954a                      	dec r20			;All 9 sectors done?
00027e f6e1                      	brne LP25      
00027f 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;All disks names 0-255 sent to TI
                                 ; ENTRY:
                                 ;
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 SendNames:
                                 ;Send disk numbers DSK1-3 
000280 e001                      	ldi r16,0x01
000281 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
000283 2700                       	clr r16
000284 9300 011a                 	sts arg+1,r16
000286 9300 011b                 	sts arg+2,r16
000288 9300 011c                 	sts arg+3,r16		; (MSB)
00028a d278                      	rcall ReadMMC           ; Read sector 1
00028b e0f2                      	ldi ZH,high(SDbuffer+4)	; Point to disk #s in buffer
00028c eaef                      	ldi ZL,low(SDbuffer+4)	; "
                                    
00028d e043                      	ldi r20,3
00028e 9101                      lp93:	ld r16,Z+		;Mov char from buffer to fdcData
00028f 9300 0103                 	sts fdcData,r16		;
000291 983a                      	cbi PortE,2		;Release TI
000292 df98                      	rcall WaitTIread	;Wait for TI to read
000293 9a3a                      	sbi PortE,2		;Put TI on hold
000294 954a                      	dec r20
000295 f7c1                      	brne lp93
                                 	
                                 ;Send Names
000296 2755                      	clr r21			;Start at disk 0
000297 d02c                      lp91:	rcall Disk2Sector	;Convert disk# in R21 to sector address
000298 d26a                      	rcall ReadMMC           ;Read sector
000299 eaeb                      	ldi ZL,low(SDbuffer)	;Get address to buffer
00029a e0f2                      	ldi ZH,high(SDbuffer)	; "
                                 	
00029b e04a                      	ldi r20,10
00029c 9101                      lp92:	ld r16,Z+		;Mov char from buffer to fdcData
00029d 9300 0103                 	sts fdcData,r16		;
00029f 983a                      	cbi PortE,2		;Release TI
0002a0 df8a                      	rcall WaitTIread	;Wait for TI to read
0002a1 9a3a                      	sbi PortE,2		;Put TI on hold
0002a2 954a                      	dec r20
0002a3 f7c1                      	brne lp92
                                 	
0002a4 9553                      	inc r21			;Next disk
0002a5 f789                      	brne LP91		;If roll over then finished
0002a6 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Change disk in drive
                                 ; ENTRY:
                                 ;	From TI	- r20 Drive 1-3 
                                 ;	From TI - r21 Disk 0-255
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r17 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ChgDisk:
                                 ;Get drive number from TI
0002a7 983a                      	cbi PortE,2		;Release TI
0002a8 df8c                      	rcall WaitTIwrite	;Wait for data from TI
0002a9 9140 0103                 	lds r20,fdcData	;Get Drive number
0002ab 7043                      	andi r20,0x03		;
0002ac 954a                      	dec r20			;DSK 1-3 to 0-2
                                 ;Get disk number from TI
0002ad df87                      	rcall WaitTIwrite	;Wait for data from TI
0002ae 9150 0103                 	lds r21,fdcData	;Get disk number
0002b0 9a3a                      	sbi PortE,2		;Put TI on hold
                                 	
                                 ;Put new disk number in sector 1	
0002b1 e001                      	ldi r16,0x01
0002b2 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
0002b4 2700                       	clr r16
0002b5 9300 011a                 	sts arg+1,r16
0002b7 9300 011b                 	sts arg+2,r16
0002b9 9300 011c                 	sts arg+3,r16		; (MSB)
0002bb d247                      	rcall ReadMMC           ; Read sector 1
0002bc e0f2                      	ldi ZH,high(SDbuffer)	; Get address to buffer
0002bd eaeb                      	ldi ZL,low(SDbuffer)	; "
                                 ; Drive number r20
                                 ; Disk number r21
0002be 0fe4                      	add ZL,r20		;Point to drive in sector 1		
0002bf 2700                      	clr r16			; "
0002c0 1ff0                      	adc ZH,r16		; "
0002c1 8354                      	std Z+4,r21		; Save new disk number
0002c2 d20d                      	rcall WriteMMC          ; Write sector 1 back to SD
0002c3 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Multiply DISK number and store sector address at DSKx addresses
                                 ; Entry:
                                 ;	r21 = disk number
                                 ;
                                 ; Exit:	    
                                 ;	Disk sector address store in arg also in r0-r3	
                                 ;	Registers used r0-r5 r16 r17 Z
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Disk2Sector:
0002c4 2e55                       	mov r5,r21		    ;Save dsisk number
                                 
0002c5 e0f1                      	ldi ZH,high(StartSector)   ; "
0002c6 e2e4                      	ldi ZL,low(StartSector)    ; "
0002c7 9001                      	ld r0,Z+		    ;initilize to start sector
0002c8 9011                      	ld r1,Z+		    ; "
0002c9 2422                      	clr r2			    ; "
0002ca 2433                      	clr r3			    ; "
0002cb 9101                      	ld r16,Z+		    ;Get step sectors
0002cc 9111                      	ld r17,Z+		    ; "   
                                 
0002cd 2055                      	tst r5			    ; Test for Disk number zero
0002ce f019                      	breq jp90		    ; skip if zero
0002cf d009                      lp90:	rcall Add32_16		    ;Multiply disk number by step
0002d0 945a                      	dec r5			    ; "
0002d1 f7e9                      	brne LP90		    ; "
                                 	
0002d2 e0f1                      jp90:	ldi ZH,high(arg)	    ;Place result in argument
0002d3 e1e9                      	ldi ZL,low(arg)	    ; "
0002d4 9201                       	st Z+,r0
0002d5 9211                      	st Z+,r1	
0002d6 9221                      	st Z+,r2	
0002d7 9231                      	st Z+,r3
0002d8 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Add 16 bits to 32 bits (lsbyte first)
                                 ; Entry		r0,r1,r2,r3 + r16,r17 
                                 ; Exit result	r0,r1,r2,r3
                                 ; r4 cleared,r16,r17 not destroyed	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Add32_16:	
0002d9 2444                      	clr r4
0002da 0e00                      	add r0,r16  ;add low byte
0002db 1c14                      	adc r1,r4
0002dc 1c24                      	adc r2,r4
0002dd 1c34                      	adc r3,r4
0002de 0e11                      	add r1,r17 ;add high byte
0002df 1c24                      	adc r2,r4
0002e0 1c34                      	adc r3,r4
0002e1 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; USART routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 USARTInit:
0002e2 b909                      	out UBRR0L,r16			  ;Set Baud rate
0002e3 bd10                      	out UBRR0H,r17
0002e4 e806                      	ldi r16,(1<<URSEL0)|(3<<UCSZ00)	  ;8N1
0002e5 bd00                      	out UCSR0C,r16
0002e6 e108                      	ldi r16,(1<<RXEN)|(1<<TXEN)	  ;Enable receive & transmit
0002e7 b90a                      	out UCSR0B,r16
0002e8 e002                      	ldi r16,(1<<U2X)		    ;Double the baud rate
0002e9 b90b                      	out UCSR0A,r16
0002ea 9508                      	ret
                                 USARTRead:
0002eb 9b5f                      	sbis	UCSR0A,RXC		  ;Wait until data is available
0002ec cffe                      	rjmp USARTRead
0002ed b10c                      	in r16,UDR			  ;Get received data
0002ee 9508                      	ret
                                 USARTWrite:
0002ef 9b5d                      	sbis	UCSR0A,UDRE		   ;Wait until transmit is ready
0002f0 cffe                      	rjmp USARTWrite
0002f1 b90c                      	out UDR,r16			   ;Send data
0002f2 9508                      	ret
                                 USARTFlush:
0002f3 9b5f                      	sbis UCSR0A,RXC
0002f4 9508                      	ret
0002f5 b10c                      	in r16,UDR
0002f6 cffc                      	rjmp USARTFlush
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; TI access to USART
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIrdUsartStat:
0002f7 9100 012a                 	lds r16,SerBufCnt
0002f9 3000                      	cpi r16,0
0002fa f049                      	breq jp16
                                 
0002fb e0f1                      	ldi ZH,high(Serbuffer)
0002fc e2eb                      	ldi ZL,low(Serbuffer)
0002fd 9100 0129                 	lds r16,SerRecvRdPtr
0002ff 0fe0                      	add ZL,r16
000300 2700                      	clr r16
000301 1ff0                      	adc ZH,r16
                                 
000302 8100                      	ld r16,Z
000303 c001                      	rjmp jp17
                                 
000304 b10b                      jp16:	in r16,UCSR0A
000305 9300 0103                 jp17:	sts fdcData,r16		;Send to TI
000307 983a                      	cbi PortE,2		;Release TI
000308 df22                      	rcall WaitTIread	; "
000309 9508                      	ret
                                 
                                 TIrdUsartData:
00030a 9100 012a                 	lds r16,SerBufCnt
00030c 3000                      	cpi r16,0
00030d f091                      	breq jp19		;Sent TI 0 nothing in buffer	
00030e 950a                      	dec r16
00030f 9300 012a                 	sts SerBufCnt,r16
                                 	
000311 e0f1                      	ldi ZH,high(Serbuffer)
000312 e2eb                      	ldi ZL,low(Serbuffer)
000313 9100 0129                 	lds r16,SerRecvRdPtr	;ptr Status byte
000315 9503                      	inc r16			;ptr Char byte
000316 0fe0                      	add ZL,r16		;Point Z to Char byte
000317 2711                      	clr r17
000318 1ff1                      	adc ZH,r17
000319 9503                      	inc r16			;ptr next entry
00031a 3800                      	cpi r16,128
00031b f409                      	brne jp14
00031c 2700                      	clr r16
00031d 9300 0129                 jp14:	sts SerRecvRdPtr,r16
                                 
00031f 8100                      	ld r16,Z		;Get char from buffer
000320 9300 0103                 jp19:	sts fdcData,r16		;Send to TI
000322 983a                      	cbi PortE,2		;Release TI
000323 df07                      	rcall WaitTIread	; "
000324 9508                      	ret 
                                 	 
                                 TIwrUsartData:
000325 983a                      	cbi PortE,2		;Release TI
000326 df0e                      	rcall WaitTIwrite	;Wait for data from TI
000327 9100 0103                 	lds r16,fdcData
000329 dfc5                      	rcall USARTWrite
00032a 9508                      	ret
                                     
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; SPI routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SPIInit:
00032b e503                      	ldi r16,(1<<SPE)|(1<<MSTR)|(3<<SPR0)	;En SPI,Master,fosc/128(125k)
00032c b90d                      	out SPCR,r16	;DORD=MSB,CPOL=rising,CPHA=LeadSample/TrailSetup
                                 ;	ldi r16,(1<<SPI2X)			; SPI double speed
                                 ;	out SPSR,r16	
00032d 9508                      	ret
                                 SPIRead:
00032e ef0f                      	ser r16			;Transmit ones to receive byte
                                 SPIWrite:
00032f b90f                      	out SPDR,r16		;Send transmit byte
                                 SPIWait:	
000330 9b77                      	sbis SPSR,SPIF		;Wait Fot Transmission complete
000331 cffe                      	rjmp SPIWait
000332 b10f                      	in	r16,SPDR	; Get received byte
000333 9508                      	ret
                                 FullThrottle:
000334 9868                      	cbi SPCR,SPR0
000335 9869                      	cbi SPCR,SPR1
000336 9a70                      	SBI SPSR,SPI2X
000337 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ; Access EXFAT find file TIVOL000
                                 ;	
                                 ;************************************************************************************
                                 ; Process Master Boot Sector
                                 ;************************************************************************************
                                 FindTIVOL:
000338 2700                      	clr r16				;Get MBR sector
000339 9300 0119                 	sts arg,r16			; (LSB) sector 00 00 00 00
00033b 9300 011a                 	sts arg+1,r16
00033d 9300 011b                 	sts arg+2,r16
00033f 9300 011c                 	sts arg+3,r16			; (MSB)
000341 d1c1                      	rcall ReadMMC           	; First 512 sector (uses ZL & ZH)
                                 		
000342 e7e1                      	ldi ZL,low(SDbuffer+0x1C6)	;Save VBR in Offset
000343 e0f4                      	ldi ZH,high(SDbuffer+0x1C6)	; "
000344 e2c0                      	ldi YL,low(Offset)		; "
000345 e0d1                      	ldi YH,high(Offset)		; "
000346 d235                      	rcall mov4
                                 
                                 ;************************************************************************************
                                 ; Process Volume Boot Sector
                                 ;************************************************************************************
000347 e2e0                      	ldi ZL,low(Offset)		;Put vbr in arg
000348 e0f1                      	ldi ZH,high(Offset)		;
000349 e1c9                      	ldi YL,low(arg)    		; "
00034a e0d1                      	ldi YH,high(arg)   		; "
00034b d230                      	rcall mov4
00034c d1b6                      	rcall ReadMMC           	; Get VBR sector	
                                 	
00034d eaeb                      	ldi ZL,low(SDbuffer)		;Point to buffer
00034e e0f2                      	ldi ZH,high(SDbuffer)		;
00034f e9c2                      	ldi YL,low(EXFATstr<<1)
000350 e0d1                      	ldi YH,high(EXFATstr<<1)
000351 d217                      	rcall cmpstr
000352 f561                      	brne DiskErrRly			;Partition is not EXFAT
                                 	
000353 e0c3                      	ldi YL,low(SDbuffer+0x58)	;Save HeapOffset+VBR
000354 e0d3                      	ldi YH,high(SDbuffer+0x58)	; "
000355 e2a0                      	ldi XL,low(OffSet)    		; "
000356 e0b1                      	ldi XH,high(Offset)   		; "
000357 d22a                      	rcall AddDword			; Result in Offset
                                 
000358 e0eb                      	ldi ZL,low(SDbuffer+0x60)	;Get RootDirectory cluster
000359 e0f3                      	ldi ZH,high(SDbuffer+0x60)	; "
00035a e1c9                      	ldi YL,low(arg)    		; "
00035b e0d1                      	ldi YH,high(arg)   		; "
00035c d21f                      	rcall mov4
                                 	
00035d 9100 0119                 	lds r16,arg			; Start cluster - 2
00035f 950a                      	dec r16				;
000360 950a                      	dec r16				;
000361 9300 0119                 	sts arg,r16			;
                                 
000363 e1e8                      	ldi ZL,low(SDbuffer+0x6D)	;Point to SectorsPerClusterShift
000364 e0f3                      	ldi ZH,high(SDbuffer+0x6D)	;
000365 8130                      	ld r19,Z			;
000366 9330 011f                 	sts SectorsPerCluster,r19 	;Save SectorsPerClusterShift
000368 d1e9                      	rcall LslArg			;RootDirectory * SectorsPerClusterShift
                                 
                                 ;************************************************************************************
                                 ; Process Root Directory Sector	(Find VOLUMES folder)
                                 ;************************************************************************************
000369 e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to RootDirectory in arg
00036a e0b1                      	ldi XH,high(arg)		; "
00036b e2c0                      	ldi YL,low(OffSet)    		; "
00036c e0d1                      	ldi YH,high(Offset)   		; "
00036d d214                      	rcall AddDword			; "
00036e d194                      	rcall ReadMMC           	;Get RootDirectory sector
                                 	    
00036f eaeb                      	ldi ZL,low(SDbuffer)		;Point to buffer
000370 e0f2                      	ldi ZH,high(SDbuffer)		;
000371 e9cc                      	ldi YL,low(VOLstr<<1)
000372 e0d1                      	ldi YH,high(VOLstr<<1)
                                 
000373 8100                      LP06:	ld r16,Z
000374 3c01                      	cpi r16,0xC1			;Check for type C1 entry
000375 f411                      	brne JP06
000376 d1f2                      	rcall cmpstr
000377 f041                      	breq JP03
                                 
000378 96b0                      JP06:	adiw ZH:ZL,32			;Next entry
000379 ea0b                      	ldi R16,low(SDbuffer+512)
00037a 17e0                      	cp ZL,r16			;Check end of buffer
00037b f7b9                      	brne LP06  
00037c e004                      	ldi R16,high(SDbuffer+512)
00037d 17f0                      	cp ZH,r16			;Check end of buffer
00037e f7a1                      	brne LP06  
                                 DiskErrRly:
00037f c05e                      	rjmp DiskErr			;VOLUMES not found
                                 
                                 JP03:	
000380 97b0                       	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
000381 9674                       	adiw ZH:ZL,20			;Point to VOLUMES folder cluster dword at 20
000382 e1c9                      	ldi YL,low(arg)    		; "
000383 e0d1                      	ldi YH,high(arg)   		; "
000384 d1f7                      	rcall mov4
                                 	
000385 9100 0119                 	lds r16,arg			; Start cluster - 2
000387 950a                      	dec r16				;
000388 950a                      	dec r16				;
000389 9300 0119                 	sts arg,r16			;
                                 
00038b 9130 011f                 	lds r19,SectorsPerCluster
00038d d1c4                      	rcall LslArg			;VOLUMES folder * SectorsPerCluster
                                 
                                 ;************************************************************************************
                                 ; Process VOLUMES Sector	(Find TIVOL000 file sector)
                                 ;************************************************************************************
00038e e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to VOLUMES folder in arg
00038f e0b1                      	ldi XH,high(arg)		; "
000390 e2c0                      	ldi YL,low(Offset)    		; "
000391 e0d1                      	ldi YH,high(Offset)   		; "
000392 d1ef                      	rcall AddDword			; "
000393 d16f                      	rcall ReadMMC           	;Get VOLUMES folder sector
                                 	
000394 eaeb                      	ldi ZL,low(SDbuffer)		;Point to buffer
000395 e0f2                      	ldi ZH,high(SDbuffer)		;
000396 eacc                      	ldi YL,low(TIVOLstr<<1)
000397 e0d1                      	ldi YH,high(TIVOLstr<<1)
                                 	
000398 8100                      LP04:	ld r16,Z
000399 3c01                      	cpi r16,0xC1			;Check for type C1 entry
00039a f411                      	brne JP04
00039b d1cd                      	rcall cmpstr
00039c f041                      	breq JP05			;TIVOL000 found
                                 
00039d 96b0                      JP04:	adiw ZH:ZL,32			;Next entry
00039e ea0b                      	ldi R16,low(SDbuffer+512)
00039f 17e0                      	cp ZL,r16			;Check end of buffer
0003a0 f7b9                      	brne LP04  
0003a1 e004                      	ldi R16,high(SDbuffer+512)
0003a2 17f0                      	cp ZH,r16			;Check end of buffer
0003a3 f7a1                      	brne LP04  
0003a4 c039                      	rjmp DiskErr			;TIVOL000 not found
                                 
0003a5 97b0                      JP05:	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
0003a6 9674                      	adiw ZH:ZL,20			;Point TIVOL000 file cluster dword at 20
0003a7 e1c9                      	ldi YL,low(arg)    		; TIVOL000 file cluster
0003a8 e0d1                      	ldi YH,high(arg)   		; "
0003a9 d1d2                      	rcall mov4
                                 	
0003aa 9100 0119                 	lds r16,arg			; Start cluster - 2
0003ac 950a                      	dec r16				;
0003ad 950a                      	dec r16				;
0003ae 9300 0119                 	sts arg,r16			;
                                 	
0003b0 9130 011f                 	lds r19,SectorsPerCluster
0003b2 d19f                      	rcall LslArg			;TIVOL000 file * SectorsPerCluster
                                 
0003b3 e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to TIVOL000 file in arg
0003b4 e0b1                      	ldi XH,high(arg)		; "
0003b5 e2c0                      	ldi YL,low(OffSet)    		; "
0003b6 e0d1                      	ldi YH,high(OffSet)   		; "
0003b7 d1ca                      	rcall AddDword			;
0003b8 9100 0119                 	lds r16,arg			;Save TIVOL000 start sector
0003ba 9300 0124                 	sts StartSector,r16		; "
0003bc 9100 011a                 	lds r16,arg+1			; "
0003be 9300 0125                 	sts StartSector+1,r16		; " 
                                 
0003c0 e1c9                      	ldi YL,low(arg)    		;Z left pointing to file size at 24
0003c1 e0d1                      	ldi YH,high(arg)   		;file size is qword but we will never exceed dword
0003c2 d1b9                      	rcall mov4
                                 		
0003c3 9130 011f                 	lds r19,SectorsPerCluster
0003c5 e009                      	ldi r16,9
0003c6 0f30                      	add r19,r16
0003c7 d1cb                      	rcall LsrArg			;Divide by SectorsPerCluster + 512 bytes per sector
0003c8 f44e                      	brtc JP01			;If t not set then no carry (no remainder)
0003c9 91e0 0119                 	lds ZL,arg
0003cb 91f0 011a                 	lds ZH,arg+1
0003cd 9631                      	adiw ZH:ZL,1
0003ce 93e0 0119                 	sts arg,ZL
0003d0 93f0 011a                 	sts arg+1,ZH
0003d2 9130 011f                 JP01:	lds r19,SectorsPerCluster
0003d4 d17d                      	rcall LslArg			;Size in clusters back to size in sectors
                                 
0003d5 9100 0119                 	lds r16,arg			;Save sector step
0003d7 9300 0126                 	sts StepSectors,r16		; "
0003d9 9100 011a                 	lds r16,arg+1			; "
0003db 9300 0127                 	sts StepSectors+1,r16		; 
                                 	
0003dd 9418                      	sez				;Set Z bit (No error)
                                 DiskErr:				;Return error,Z bit cleared
0003de 9508                      	ret				;On return will set disk ready status	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;	
                                 ; Low level SD card access
                                 ;	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send command to MMC,Uses cmd resp r16 r17 r18 nz=error
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendMMC:
                                     ;4.8ms delay,PNY 1GB had trouble without delay
0003df d154                          	rcall delay1ms
0003e0 d153                      	rcall delay1ms
0003e1 d152                      	rcall delay1ms
0003e2 d151                      	rcall delay1ms
0003e3 d150                      	rcall delay1ms
                                 		
0003e4 ef0f                      	ldi r16,0xFF		;
0003e5 df49                             	rcall SPIWrite	;
0003e6 9100 0118                 	lds r16,cmd		; Send the command byte
0003e8 df46                      	rcall SPIWrite	;
0003e9 9100 011c                 	lds r16,arg+3		; Send 4 argument bytes starting with MSB
0003eb df43                      	rcall SPIWrite	;
0003ec 9100 011b                 	lds r16,arg+2		;
0003ee df40                      	rcall SPIWrite	;
0003ef 9100 011a                 	lds r16,arg+1		;
0003f1 df3d                      	rcall SPIWrite	;
0003f2 9100 0119                 	lds r16,arg		;
0003f4 df3a                      	rcall SPIWrite	;
0003f5 9100 011d                 	lds r16,crc		; Send the CRC7 byte (always use 95)
0003f7 df37                             	rcall SPIWrite	;
                                 			
                                 WaitResp:
0003f8 2722                      	clr r18
                                 LP10:
                                     ;.69ms delay,PNY 1GB had trouble without delay	
0003f9 d13a                      	rcall delay1ms		
                                 				
0003fa df33                      	rcall SPIRead	;
0003fb 9110 011e                 	lds r17,resp
0003fd 1701                      	cp r16,r17		; expected response?
0003fe f021                      	breq JP11		; YES - return
0003ff 952a                      	dec r18			; waiting period is over?
000400 f7c1                             	brne LP10		; NO - keep waiting
000401 d126                      	rcall SendErrorSPI	;
000402 9498                      	clz			; Clear zero flag for time out
000403 9508                      JP11:	ret			;
                                 
                                     
                                 ;********************************************************************
                                 ; Init SD/MMC memory card
                                 ;******************************************************************** 
                                 MMCInit:	
000404 9ac4                      	sbi PortB,CS		    ; disable MMC
000405 e01a                      	ldi r17,10		    ; Send 80 dummy clocks
                                 LP20:
000406 df27                      	rcall SPIRead	    ;
000407 951a                             	dec R17			    ;
000408 f7e9                      	brne LP20		    ;
000409 98c4                              cbi PortB,CS		    ; enable MMC         
                                 SendCMD0:
00040a e400                      	ldi r16,0x40		    ; CMD0 GO_IDLE_STATE
00040b 9300 0118                 	sts cmd,r16              
00040d 2700                             	clr r16			    ; LSB
00040e 9300 0119                 	sts arg,r16                ; 0x00000000
000410 9300 011a                 	sts arg+1,r16              ;	
000412 9300 011b                 	sts arg+2,r16              ;	
000414 9300 011c                 	sts arg+3,r16              ; MSB
000416 e905                      	ldi r16,0x95
000417 9300 011d                        	sts crc,r16
000419 e001                      	ldi r16,1
00041a 9300 011e                 	sts resp,r16		    ; expected response cnt 8
00041c dfc2                      	rcall SendMMC		    ;
00041d f761                             	brne SendCMD0		    ; Expected response timed out
                                 SendCMD8:
00041e e408                      	ldi r16,0x48		    ; CMD8 SEND_IF_COND
00041f 9300 0118                 	sts cmd,r16
000421 ea0a                      	ldi r16,0xAA		    ; LSB
000422 9300 0119                 	sts arg,r16                ; 0x000001AA
000424 e001                      	ldi r16,0x01		    ;
000425 9300 011a                 	sts arg+1,r16              ;
000427 2700                      	clr r16			    ;
000428 9300 011b                 	sts arg+2,r16              ;
00042a 9300 011c                 	sts arg+3,r16              ; MSB
00042c e807                      	ldi r16,0x87
00042d 9300 011d                 	sts crc,r16
00042f e001                      	ldi r16,1		    ; Response V2=0x01 0x000001AA or V1=0x05
000430 9300 011e                 	sts resp,r16
000432 dfac                      	rcall SendMMC               ; 
000433 f571                      	brne SendCMD1
000434 def9                      	rcall SPIRead		    ; need to clear 0x000001AA
000435 def8                      	rcall SPIRead		    ;	
000436 def7                              rcall SPIRead		    ;	      	
000437 def6                      	rcall SPIRead		    ;			; 
                                 			
                                 ;ACMD41 (CMD55+CMD41)			
                                 SendCMD55:
000438 e707                      	ldi r16,0x77		    ; CMD55 APP_CMD
000439 9300 0118                 	sts cmd,r16              
00043b 2700                             	clr r16			    ; LSB
00043c 9300 0119                 	sts arg,r16                ; 0x00000000
00043e 9300 011a                 	sts arg+1,r16              ;	
000440 9300 011b                 	sts arg+2,r16              ;	
000442 9300 011c                 	sts arg+3,r16              ; MSB
000444 ef0f                      	ldi r16,0xFF
000445 9300 011d                        	sts crc,r16
000447 e001                      	ldi r16,1
000448 9300 011e                 	sts resp,r16		    ; expected response
00044a df94                      	rcall SendMMC		    ;
00044b f761                             	brne SendCMD55		    ;  Expected response timed out	
                                 SendCMD41: 	
00044c e609                      	ldi r16,0x69		    ; CMD41 SD_SEND_OP_COND
00044d 9300 0118                 	sts cmd,r16              
00044f 2700                             	clr r16			    ; LSB
000450 9300 0119                 	sts arg,r16                ; 0x40000000
000452 9300 011a                 	sts arg+1,r16              ;
000454 9300 011b                 	sts arg+2,r16              ;
000456 e400                      	ldi r16,0x40
000457 9300 011c                 	sts arg+3,r16              ; MSB
000459 ef0f                      	ldi r16,0xFF
00045a 9300 011d                        	sts crc,r16
00045c 2700                      	clr r16
00045d 9300 011e                 	sts resp,r16		    ; expected response
00045f df7f                      	rcall SendMMC		    ;
000460 f6b9                             	brne SendCMD55		    ;  Expected response timed out
000461 c014                      	rjmp SendCMD58
                                 
                                 SendCMD1:
000462 e401                      	ldi r16,0x41		    ; CMD1 SEND_OP_COND
000463 9300 0118                 	sts cmd,r16              
000465 2700                             	clr r16			    ; LSB
000466 9300 0119                 	sts arg,r16                ; 0x00000000
000468 9300 011a                 	sts arg+1,r16              ;	
00046a 9300 011b                 	sts arg+2,r16              ;	
00046c 9300 011c                 	sts arg+3,r16              ; MSB
00046e ef0f                      	ldi r16,0xFF
00046f 9300 011d                        	sts crc,r16
000471 2700                      	clr r16
000472 9300 011e                 	sts resp,r16		    ; expected response
000474 df6a                      	rcall SendMMC		    ;
000475 f761                             	brne SendCMD1		    ;  Expected response timed out
                                    			
                                 SendCMD58:
000476 e70a                      	ldi r16,0x7A		    ; CMD58 READ_OCR
000477 9300 0118                 	sts cmd,r16              
000479 2700                             	clr r16			    ; LSB
00047a 9300 0119                 	sts arg,r16                ; 0x00000000
00047c 9300 011a                 	sts arg+1,r16              ;	
00047e 9300 011b                 	sts arg+2,r16              ;	
000480 9300 011c                 	sts arg+3,r16              ; MSB
000482 ef0f                      	ldi r16,0xFF
000483 9300 011d                        	sts crc,r16
000485 2700                      	clr r16
000486 9300 011e                 	sts resp,r16		    ; expected response
000488 df56                      	rcall SendMMC		    ;
000489 f761                             	brne SendCMD58		    ;  Expected response timed out
                                 
00048a e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
00048b eaeb                      	ldi ZL,low(SDbuffer)	    ; "
00048c e034                      	ldi R19,4
                                 LP21:
00048d dea0                      	rcall SPIRead		    ; Get MSByte 1 of 4 OCR register
00048e 9301                      	st Z+,r16		    ; Save OCR to buffer
00048f 953a                      	dec R19
000490 f7e1                      	brne LP21
000491 9100 02ab                 	lds r16,SDbuffer
000493 9300 0117                 	sts ocr,r16		    ; bit6=1 SDHC
                                 
                                 SendCMD9:
000495 e409                      	ldi r16,0x49		    ; CMD9 READ_CSD
000496 9300 0118                 	sts cmd,r16              
000498 2700                             	clr r16			    ;
000499 9300 011e                 	sts resp,r16		    ; expected response
00049b df43                      	rcall SendMMC		    ;
00049c f7c1                      	brne SendCMD9		    ; Expected response timed out
00049d ef0e                      	ldi r16,0xFE
00049e 9300 011e                 	sts resp,r16
0004a0 df57                      	rcall WaitResp		    ; Wait for FE Start
0004a1 f799                      	brne SendCMD9
0004a2 e132                      	ldi r19,18
                                 LP22:	
0004a3 de8a                      	rcall SPIRead
0004a4 953a                      	dec r19
0004a5 f7e9                      	brne LP22
                                 
                                 SendCMD10:
0004a6 e40a                          	ldi r16,0x4A		    ; CMD10 READ_CID
0004a7 9300 0118                 	sts cmd,r16              
0004a9 2700                             	clr r16			    ;
0004aa 9300 011e                 	sts resp,r16		    ; expected response
0004ac df32                      	rcall SendMMC		    ;
0004ad f7c1                      	brne SendCMD10		    ; Expected response timed out
0004ae ef0e                      	ldi r16,0xFE
0004af 9300 011e                 	sts resp,r16
0004b1 df46                      	rcall WaitResp		    ; Wait for FE Start
0004b2 f799                      	brne SendCMD10
0004b3 e132                          	ldi r19,18
                                 LP23:	
0004b4 de79                      	rcall SPIRead
0004b5 953a                      	dec r19
0004b6 f7e9                      	brne LP23
                                 
0004b7 de7c                      	rcall FullThrottle
                                 			
                                 ; Let fall thru to Set Block			
                                 ;********************************************************************
                                 ; CMD16 SET_BLOCKLEN default 512
                                 ; The only valid block length for write is 512!
                                 ; Read is 1 to 2048
                                 ;********************************************************************
                                 SetBlockMMC: 
0004b8 98c4                      	cbi PortB,CS		    ; enable MMC         
0004b9 e500                      	ldi r16,0x50		    ; CMD16 SET_BLOCKLEN
0004ba 9300 0118                 	sts cmd,r16              
0004bc 2700                             	clr r16			    ; LSB
0004bd 9300 0119                 	sts arg,r16                ; 0x00000200 (512 block)
0004bf e002                      	ldi r16,2
0004c0 9300 011a                 	sts arg+1,r16              ;
0004c2 2700                      	clr r16
0004c3 9300 011b                 	sts arg+2,r16              ;	
0004c5 9300 011c                 	sts arg+3,r16              ; MSB
0004c7 2700                      	clr r16
0004c8 9300 011d                 	sts crc,r16
0004ca 9300 011e                 	sts resp,r16		    ; expected response
0004cc df12                      	rcall SendMMC		    ;
0004cd f751                             	brne SetBlockMMC	    ; Expected response timed out
0004ce 9ac4                      	sbi PortB,CS		    ; Disable MMC
0004cf 9508                      	ret 							;
                                 
                                 ;********************************************************************
                                 ; CMD24 WRITE_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ; Exit nz=write error
                                 ;********************************************************************
                                 WriteMMC:			    ;Write 1st 256 bytes of sector
0004d0 98c4                      	cbi PortB,CS		    ; enable MMC   
0004d1 d06d                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
0004d2 9100 0117                 	lds r16,ocr
0004d4 ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
0004d5 d07b                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 LP40:
0004d6 e508                      	ldi r16,0x58		    ; CMD24 WRITE_BLOCK
0004d7 9300 0118                 	sts cmd,r16 
0004d9 2700                      	clr r16
0004da 9300 011d                 	sts crc,r16
0004dc 9300 011e                 	sts resp,r16		    ; expected response
0004de df00                      	rcall SendMMC		    ;
0004df f7b1                             	brne LP40		    ; Expected response timed out
                                 	
0004e0 de4d                      	rcall SPIRead		    ; write prefix (Read writes FFFF)
0004e1 de4c                      	rcall SPIRead
0004e2 ef0e                      	ldi r16,0xFE		    ; Send start data token
0004e3 de4b                      	rcall SPIWrite
                                 	
0004e4 e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
0004e5 eaeb                      	ldi ZL,low(SDbuffer)	    ; "
0004e6 2733                      	clr R19			    ; Write 256 bytes to SD
                                 ;Write 1st 256 bytes of sector	
                                 LP41:
0004e7 9101                      	ld r16,Z+
0004e8 de46                      	rcall SPIWrite		    ; Write data byte
0004e9 953a                      	dec R19
0004ea f7e1                      	brne LP41
                                 ;Write 2nd 256 bytes of sector    		 
                                 LP42:
0004eb 9101                      	ld r16,Z+
0004ec de42                      	rcall SPIWrite		    ; Write data byte
0004ed 953a                      	dec R19
0004ee f7e1                      	brne LP42				
0004ef de3e                      	rcall SPIRead		    ; write 2 bytes CRC 0xFF (Read writes FFFF)
0004f0 de3d                      	rcall SPIRead		    ;  "
                                 	    
0004f1 de3c                      	rcall SPIRead		    ; was data accepted			
0004f2 710f                      	andi r16,0x1F
0004f3 3005                      	cpi r16,5
0004f4 f449                      	brne JP45
0004f5 ef0f                      	ldi r16,0xFF		    ; wait for 0xFF
0004f6 9300 011e                 	sts resp,r16
0004f8 deff                      	rcall WaitResp
0004f9 f421                      	brne JP45
0004fa d04d                      	rcall RestoreArg
0004fb 9ac4                      	sbi PortB,CS		    ; Disable MMC
0004fc 9418                      	sez			    ;Set zero fla
0004fd 9508                             	ret			    ; normal return z-flag set
                                 JP45:
0004fe d049                      	rcall RestoreArg
0004ff d028                      	rcall SendErrorSPI         
000500 9ac4                      	sbi PortB,CS		    ; Disable MMC
000501 9498                      	clz			    ;Clr zero flag
000502 9508                      	ret			    ; write error return z-flag clear
                                  			
                                 			
                                       		
                                 ;********************************************************************
                                 ; CMD17 READ_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ;********************************************************************
                                 ReadMMC:			    ;Read 1st 256 bytes of sector
000503 98c4                      	cbi PortB,CS		    ; enable MMC   
000504 d03a                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
000505 9100 0117                 	lds r16,ocr
000507 ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
000508 d048                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 LP50:
000509 e501                      	ldi r16,0x51		    ; CMD17 READ_SINGLE_BLOCK
00050a 9300 0118                 	sts cmd,r16 
00050c 2700                      	clr r16
00050d 9300 011d                 	sts crc,r16
00050f 9300 011e                 	sts resp,r16		    ; expected response
000511 decd                      	rcall SendMMC		    ;
000512 f7b1                             	brne LP50		    ; Expected response timed out
                                 	
000513 ef0e                      	ldi r16,0xFE		    ; Send start data token
000514 9300 011e                 	sts resp,r16
000516 dee1                      	rcall WaitResp		    ; Wait for FE Start
000517 f789                      	brne LP50
                                 ;Read 1st 256 bytes of sector	
000518 e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
000519 eaeb                      	ldi ZL,low(SDbuffer)	    ; "
00051a 2733                      	clr R19			    ; Always read 256 the size of buffer
                                 LP51:
00051b de12                      	rcall SPIRead		    ; Get data byte
00051c 9301                      	st Z+,r16
00051d 953a                      	dec R19
00051e f7e1                      	brne LP51
                                 ;Read 2nd 256 bytes of sector    		 
                                 LP52:
00051f de0e                      	rcall SPIRead		    ; Get data byte
000520 9301                      	st Z+,r16
000521 953a                      	dec R19
000522 f7e1                      	brne LP52		
000523 de0a                      	rcall SPIRead		    ; read 2 bytes CRC	
000524 de09                      	rcall SPIRead		    ; and discard	
000525 9ac4                      	sbi PortB,CS		    ; Disable MMC
000526 d021                       	rcall RestoreArg
000527 9508                         	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send error command/response to PC
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendErrorSPI:
000528 ddc6                             	rcall USARTWrite	    ; Send response received
000529 9100 011e                 	lds r16,resp		    
00052b ddc3                      	rcall USARTWrite	    ; Send expected response
00052c 9100 0118                 	lds r16,cmd
00052e ddc0                      	rcall USARTWrite	    ; Send cmd used
00052f 94aa                      	dec r10
                                 ErrLP:	
000530 f3f9                      	breq ErrLP		    ; Keep from runnig away,Until reset
000531 9508                      	ret			    ; Fail 2 or 3 times on start,Just return 
                                 	
                                 SendErrorMedia:
000532 0000                      	nop
000533 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 delay1ms:		;  15431x.0625us aprox 1ms,not exact(.965ms)
000534 930f                      	push r16	;   2
000535 931f                      	push r17	;   2
000536 e114                      	ldi r17,20	;   1
000537 2700                      	clr r16		;   1
000538 950a                      dly1:	dec r16		; 768x20=15360          
000539 f7f1                              brne dly1	; 
00053a 951a                      	dec r17		; 3x20=60   
00053b f7e1                      	brne dly1
00053c 911f                      	pop r17		;   2
00053d 910f                      	pop r16		;   2
00053e 9508                      	ret		;   1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                  SaveArg:   
00053f 9060 0119                     	lds r6,arg		; Save argument,in case multipled
000541 9070 011a                   	lds r7,arg+1
000543 9080 011b                   	lds r8,arg+2
000545 9090 011c                   	lds r9,arg+3
000547 9508                      	ret
                                 RestoreArg:
000548 9290 011c                 	sts arg+3,r9		; Restore argument
00054a 9280 011b                 	sts arg+2,r8 
00054c 9270 011a                 	sts arg+1,r7  
00054e 9260 0119                 	sts arg,r6
000550 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 Mul512Arg:
000551 e039                      	ldi r19,9		; multiply arg by 512
                                 LslArg:				; shift arg left per r19
                                 LP60:	
000552 9100 0119                 	lds r16,arg
000554 0f00                      	lsl r16
000555 9300 0119                 	sts arg,r16
000557 9100 011a                 	lds r16,arg+1
000559 1f00                      	rol r16
00055a 9300 011a                 	sts arg+1,r16
00055c 9100 011b                 	lds r16,arg+2
00055e 1f00                      	rol r16
00055f 9300 011b                 	sts arg+2,r16
000561 9100 011c                 	lds r16,arg+3
000563 1f00                      	rol r16
000564 9300 011c                 	sts arg+3,r16
000566 953a                      	dec r19
000567 f751                      	brne LP60
000568 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000569 93ef                      cmpstr:	push ZL
00056a 93ff                      	push ZH
00056b 93cf                      	push YL
00056c 93df                      	push YH
                                 		
00056d 018f                      	movw r17:r16,ZH:ZL  ;LPM only works with Z
00056e 01fe                      	movw ZH:ZL,YH:YL
00056f 01e8                      	movw YH:YL,r17:r16
                                   	
000570 9105                      LP07:	lpm r16,Z+
000571 3f0f                      	cpi r16,0xFF	;Check end of string
000572 f021                      	breq JP07
000573 9119                      	ld r17,Y+
000574 1701                      	cp r16,r17
000575 f409                      	brne JP07	;Not equal,return
000576 cff9                      	rjmp LP07	;Next char
000577 91df                      JP07:	pop YH
000578 91cf                      	pop YL
000579 91ff                      	pop ZH
00057a 91ef                      	pop ZL
00057b 9508                      	ret		
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00057c e004                      mov4:	ldi r16,4		    ;
00057d 9111                      LP01:	ld r17,Z+ 
00057e 9319                      	st Y+,r17
00057f 950a                      	dec r16
000580 f7e1                      	brne LP01
000581 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Add Dword pointed to by X & Y Result pointed to by X
                                 AddDword:
000582 910c                      	ld r16,X
000583 9119                      	ld r17,Y+
000584 0f01                      	add r16,r17
000585 930d                      	st X+,r16
                                 
000586 910c                      	ld r16,X
000587 9119                      	ld r17,Y+
000588 1f01                      	adc r16,r17
000589 930d                      	st X+,r16
                                 
00058a 910c                      	ld r16,X
00058b 9119                      	ld r17,Y+
00058c 1f01                      	adc r16,r17
00058d 930d                      	st X+,r16
                                 
00058e 910c                      	ld r16,X
00058f 9119                      	ld r17,Y+
000590 1f01                      	adc r16,r17
000591 930d                      	st X+,r16
000592 9508                      	ret
                                 
                                 ; shift arg right per r19
000593 94e8                      LsrArg:	clt			
000594 9100 011c                 LP61:	lds r16,arg+3
000596 9506                      	lsr r16
000597 9300 011c                 	sts arg+3,r16
000599 9100 011b                 	lds r16,arg+2
00059b 9507                      	ror r16
00059c 9300 011b                 	sts arg+2,r16
00059e 9100 011a                 	lds r16,arg+1
0005a0 9507                      	ror r16
0005a1 9300 011a                 	sts arg+1,r16
0005a3 9100 0119                 	lds r16,arg
0005a5 9507                      	ror r16
0005a6 9300 0119                 	sts arg,r16
0005a8 f408                      	brcc JP61
0005a9 9468                      	set		;Set t bit if carry
0005aa 953a                      JP61:	dec r19
0005ab f741                      	brne LP61
0005ac 9508                      	ret
                                 	


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega162" register use summary:
x  :  11 y  :  12 z  :  52 r0 :  11 r1 :   8 r2 :   5 r3 :   5 r4 :   6 
r5 :   3 r6 :   2 r7 :   2 r8 :   2 r9 :   2 r10:   2 r11:   0 r12:   0 
r13:   2 r14:   2 r15:   7 r16: 473 r17:  66 r18:  12 r19:  24 r20:  12 
r21:   8 r22:   2 r23:   2 r24:   2 r25:   2 r26:   8 r27:   8 r28:  25 
r29:  26 r30:  55 r31:  55 
Registers used: 33 out of 35 (94.3%)

"ATmega162" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  17 add   :  12 adiw  :  14 and   :   0 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  10 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  79 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :  19 cbr   :   1 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  53 cls   :   0 
clt   :   1 clv   :   0 clz   :   2 com   :   1 cp    :   6 cpc   :   0 
cpi   :  37 cpse  :   0 dec   :  33 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  17 inc   :  11 jmp   :   3 
ld    :  39 ldd   :   0 ldi   : 189 lds   :  71 lpm   :   1 lsl   :   1 
lsr   :   2 mov   :   4 movw  :   3 mul   :   1 muls  :   0 mulsu :   0 
neg   :   1 nop   :   3 or    :   0 ori   :   0 out   :  21 pop   :  24 
push  :  26 rcall : 145 ret   :  39 reti  :   2 rjmp  :  31 rol   :   3 
ror   :   4 sbc   :   0 sbci  :   0 sbi   :  13 sbic  :   6 sbis  :   6 
sbiw  :   5 sbr   :   5 sbrc  :   5 sbrs  :   6 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   2 ses   :   0 set   :   1 sev   :   0 
sez   :   2 sleep :   0 spm   :   0 st    :  22 std   :   1 sts   : 149 
sub   :   2 subi  :   0 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 56 out of 113 (49.6%)

"ATmega162" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b5a   2762     44   2806   16384  17.1%
[.dseg] 0x000100 0x0004ab      0    939    939    1024  91.7%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
