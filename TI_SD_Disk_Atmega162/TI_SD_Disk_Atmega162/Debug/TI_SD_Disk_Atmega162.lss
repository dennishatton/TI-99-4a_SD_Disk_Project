
AVRASM ver. 2.2.8  C:\Users\denni\Documents\Microchip Studio\7.0\TI_SD_Disk_Atmega162\TI_SD_Disk_Atmega162\main.asm Sun Sep 12 20:19:23 2021

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m162def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m162def.inc'
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega162.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m162def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega162
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega162
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M162DEF_INC_
                                 #define _M162DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega162
                                 #pragma AVRPART ADMIN PART_NAME ATmega162
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x94
                                 .equ	SIGNATURE_002	= 0x04
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	UBRR1H	= 0x3c
                                 .equ	UCSR1C	= 0x3c
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	EMCUCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	TCCR2	= 0x27
                                 .equ	ASSR	= 0x26
                                 .equ	ICR1L	= 0x24
                                 .equ	ICR1H	= 0x25
                                 .equ	TCNT2	= 0x23
                                 .equ	OCR2	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRR0H	= 0x20
                                 .equ	UCSR0C	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	PORTE	= 0x07
                                 .equ	DDRE	= 0x06
                                 .equ	PINE	= 0x05
                                 .equ	OSCCAL	= 0x04
                                 .equ	OCDR	= 0x04
                                 .equ	UDR1	= 0x03
                                 .equ	UCSR1A	= 0x02
                                 .equ	UCSR1B	= 0x01
                                 .equ	UBRR1L	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TICIE1	= 3	; Timer/Counter1 Input Capture Interrupt Enable
                                 .equ	OCIE1B	= 5	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 6	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TOIE1	= 7	; Timer/Counter1 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	ICF1	= 3	; Input Capture Flag 1
                                 .equ	OCF1B	= 5	; Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Output Compare Flag 1A
                                 .equ	TOV1	= 7	; Timer/Counter1 Overflow Flag
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC1A	= 3	; Force Output Compare for Channel A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select1 bit 0
                                 .equ	CS11	= 1	; Clock Select1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Pulse Width Modulator Select Bit 1
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Pulse Width Modulator Select Bit 0
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Forde Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE2	= 2	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 4	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 2	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 4	; Output Compare Flag 2
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 3B
                                 .equ	OCF3A	= 4	; Output Compare Flag 3A
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Pulse Width Modulator Select Bit 0
                                 .equ	WGM31	= 1	; Pulse Width Modulator Select Bit 1
                                 .equ	FOC3B	= 2	; Force Output Compare for Channel B
                                 .equ	FOC3A	= 3	; Force Output Compare for Channel A
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select3 bit 0
                                 .equ	CS31	= 1	; Clock Select3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Pulse Width Modulator Select Bit 2
                                 .equ	WGM33	= 4	; Pulse Width Modulator Select Bit 3
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR	= UDR0	; For compatibility
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	USR	= UCSR0A	; For compatibility
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	U2X	= U2X0	; For compatibility
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	DOR	= DOR0	; For compatibility
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	FE	= FE0	; For compatibility
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	UDRE	= UDRE0	; For compatibility
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	TXC	= TXC0	; For compatibility
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 .equ	RXC	= RXC0	; For compatibility
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	UCR	= UCSR0B	; For compatibility
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	TXB8	= TXB80	; For compatibility
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	RXB8	= RXB80	; For compatibility
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	TXEN	= TXEN0	; For compatibility
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	RXEN	= RXEN0	; For compatibility
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	UDRIE	= UDRIE0	; For compatibility
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	TXCIE	= TXCIE0	; For compatibility
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 .equ	RXCIE	= RXCIE0	; For compatibility
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UBRRHI	= UCSR0C	; For compatibility
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 .equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 ;.equ	URSEL0	= 7	; Register Select
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= UBRR0L	; For compatibility
                                 .equ	UBRR	= UBRR0L	; For compatibility
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART1 I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART1 I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART1 I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART1 I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART1 I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART1 I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART1 I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART1 I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	CHR91	= UCSZ12	; For compatibility
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 .equ	URSEL1	= 7	; Register Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Highg Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ;.equ	UBRR1	= UBRR1L	; For compatibility
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 bit 1
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 bit 1
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SM	= SM1	; For compatibility
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRW	= SRW10	; For compatibility
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	SM2	= 5	; Sleep Mode Select Bit 2
                                 .equ	JDT	= 7	; JTAG Interface Disable
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 .equ	ISC2	= 0	; Interrupt Sense Control 2
                                 .equ	SRW11	= 1	; Wait State Select Bit 1 for Upper Sector
                                 .equ	SRW00	= 2	; Wait State Select Bit 0 for Lower Sector
                                 .equ	SRW01	= 3	; Wait State Select Bit 1 for Lower Sector
                                 .equ	SRL0	= 4	; Wait State Sector Limit Bit 0
                                 .equ	SRL1	= 5	; Wait State Sector Limit Bit 1
                                 .equ	SRL2	= 6	; Wait State Sector Limit Bit 2
                                 .equ	SM0	= 7	; Sleep mode Select Bit 0
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 
                                 ; CLKPR - Clock prescale register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR310	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSR310	; For compatibility
                                 .equ	PSR0	= PSR310	; For compatibility
                                 .equ	PSR1	= PSR310	; For compatibility
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	XMM0	= 3	; External Memory High Mask Bit 0
                                 .equ	XMM1	= 4	; External Memory High Mask Bit 1
                                 .equ	XMM2	= 5	; External Memory High Mask Bit 2
                                 .equ	XMBK	= 6	; External Memory Bus Keeper Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter 0 Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter 0 Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Timer/Counter 0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	OCIE0	= 0	; Timer/Counter0 Output Compare Match Interrupt register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	OCF0	= 0	; Output Compare Flag 0
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 ; EMCUCR - Extended MCU Control Register
                                 ;.equ	ISC2	= 0	; Interrupt Sense Control 2
                                 
                                 ; GICR - General Interrupt Control Register
                                 .equ	EIMSK	= GICR	; For compatibility
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PCIE0	= 3	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 4	; Pin Change Interrupt Enable 1
                                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	PCIF0	= 3	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 4	; Pin Change Interrupt Flag 1
                                 .equ	INTF2	= 5	; External Interrupt Flag 2
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 1	; Brown out detector trigger level
                                 .equ	BODLEVEL1	= 2	; Brown out detector trigger level
                                 .equ	BODLEVEL2	= 3	; Brown out detector trigger level
                                 .equ	M161C	= 4	; ATMega 161 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x04ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 16384
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1c00
                                 .equ	NRWW_STOP_ADDR	= 0x1fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1bff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x1f80
                                 .equ	SECONDBOOTSTART	= 0x1f00
                                 .equ	THIRDBOOTSTART	= 0x1e00
                                 .equ	FOURTHBOOTSTART	= 0x1c00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	PCI0addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	ICP3addr	= 0x000c	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x000e	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0010	; Timer/Counter3 Compare Match B
                                 .equ	OVF3addr	= 0x0012	; Timer/Counter3 Overflow
                                 .equ	OC2addr	= 0x0014	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0016	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0018	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x001a	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001c	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001e	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x0020	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0022	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0024	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0026	; USART0, Rx Complete
                                 .equ	URXC1addr	= 0x0028	; USART1, Rx Complete
                                 .equ	UDRE0addr	= 0x002a	; USART0 Data register Empty
                                 .equ	UDRE1addr	= 0x002c	; USART1, Data register Empty
                                 .equ	UTXC0addr	= 0x002e	; USART0, Tx Complete
                                 .equ	UTXC1addr	= 0x0030	; USART1, Tx Complete
                                 .equ	ERDYaddr	= 0x0032	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0034	; Analog Comparator
                                 .equ	SPMRaddr	= 0x0036	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 56	; size in words
                                 
                                 #endif  /* _M162DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 ;    TI SD Disk.asm
                                 ;
                                 ; Created: 1/1/2019 3:45:02 PM
                                 ; Author : Dennis Hatton
                                 ;
                                 ; Fuses FF D9 FF
                                 ; 16mhz ext crystal
                                 ;
                                 ;   Atmega8515 Converted to Atmega162		
                                 ;    PortA	PortB	    Portc	PortD	    PortE			
                                 ;    0<Data0	0<A0	    0>Data0	0<RXD	    0<!INT2			
                                 ;    1<Data1	1<A1	    1>Data1	1>TXD	    1<!WE		
                                 ;    2<Data2	2<	    2>Data2	2<	    2>!ready			
                                 ;    3<Data3	3<	    3>Data3	3>HLD			
                                 ;    4<Data4	4>CS	    4>Data4	4<Drive1
                                 ;    5<Data5	5>MOSI	    5>Data5	5<Drive2    
                                 ;    6<Data6	6<MISO	    6>Data6	6<Drive3
                                 ;    7<Data7	7>SCK	    7>Data7	7<Side   
                                 ;
                                 ; IN PINx
                                 ; OUT PORTx
                                 ; OUT PINx turns on pullup						
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
                                 
                                 			
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Equates
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PortE bits
                                 			.equ intbit = PE0
                                 			.equ webit = PE1
                                 			.equ rdybit = PE2
                                 			
                                 ; Dedicated registers			
                                 ; INT2:	XL XH r13 r14 r15			
                                 ; SD error count: r10			
                                 ; Save arg: r6-r9
                                 ;			
                                 		
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.DSEG
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ;FDC variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 fdcRegisters:
000100                           fdcStatus:	.byte 1			;TI 5FF0 Read Status
000101                           fdcTrack:	.byte 1			;TI 5FF2/5FFA Rd/Wr Track Register
000102                           fdcSector:	.byte 1			;TI 5FF4/5FFC Rd/Wr Sector Register
000103                           fdcData:	.byte 1			;TI 5FF6/5FFE Rd/Wr Data Register
000104                           fdcCommand:	.byte 1			;TI 5FF8 Write Command Register
000105                           fdcSide:	.byte 1			;	
                                 
000106                           flags:		.byte 1			;flags + address
                                 			.equ iflag = 7	;1 int occured
                                 			.equ wflag = 2	;1 write occured
                                 
000107                           DSK1address:	.byte	4	;LSB -- MSB			
00010b                           DSK2address:	.byte	4	;LSB -- MSB
00010f                           DSK3address:	.byte	4	;LSB -- MSB
000113                           DSK1LastTrk:	.byte	1
000114                           DSK2LastTrk:	.byte	1
000115                           DSK3LastTrk:	.byte	1
000116                           TIlowbyte:	.byte	1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ;SD variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 		.equ CS = PB4
000117                           ocr:		.byte	1
                                 		.equ ccs = 6	;bit 6
000118                           cmd:		.byte	1
000119                           arg:		.byte	4	;LSB -- MSB		
00011d                           crc:		.byte	1
00011e                           resp:		.byte	1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Disk variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 SectorsPerCluster:		;in Powers of 2 (Number of left shifts to use)
00011f                           		.byte	1
000120                           Offset:		.byte	4	;LSB -- MSB	
000124                           StartSector:	.byte	2
000126                           StepSectors:	.byte	2
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Serial interrupt variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
000128                           SerWrPtr:	.byte	1
000129                           SerRdPtr:	.byte	1
00012a                           SerCnt:		.byte	1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; XMODEM variables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 	.equ SOH = 1
                                 	.equ EOT = 4
                                 	.equ CAN = 24
                                 	.equ NAK = 21
                                 	.equ ACK = 6
                                 	.equ CR = 13
00012b                           PAKNUM:	.byte 2		;16 bit packet# (LSByte - MSByte)
00012d                           CHKSUM:	.byte 1
00012e                           CRCFLG:	.byte 1
00012f                           TELFLG:	.byte 1
                                 ;CRC r1:r0		;also uses r2
                                 	
                                 VAR_END:	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Buffers
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 		.equ Serbuffsize = 160
000130                           Serbuffer:	.byte	Serbuffsize
0001d0                           TIbuffer:	.byte	256
0002d0                           SDbuffer:	.byte	512
                                 	
                                 ;Stack area	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Interrupts vector tables
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
                                 	.CSEG		;8515 use rjmp 162 use jmp
                                 	.org $000
000000 940c 00e6                 	jmp setup	;Reset Handler
                                 	.org URXC0addr	;8515 URXCaddr,162 URXC0addr
000026 940c 0054                 	jmp USART_RXC	;USART RX Complete Handler  
                                 	.org INT2addr
000006 940c 0038                 	jmp EXT_INT2	;IRQ2 Handler
                                 	
                                 
                                 ;Interrupt Service Routines
                                 	.org INT_VECTORS_SIZE		;End of Int vector table
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; IRQ2 Interrupt Handler
                                 ; XH XL r13 r14 r15 not saved
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; cycle = 62.5ns
                                 EXT_INT2:
000038 b6df                          	in r13,SREG			;Save SREG			1
000039 2ee0                      	mov r14,r16			;				1
00003a b306                      	in r16,PinB			;Get FDC address		1
00003b 7003                      	andi r16,0x03			;				1
00003c 24ff                      	clr r15				;				1								
00003d e0b1                      	ldi XH,high(fdcRegisters)	;Point X to FDC_Registers base	1
00003e e0a0                      	ldi XL,low(fdcRegisters)	; "				1
00003f 0fa0                      	add XL,r16			;add FDC address offset		1
000040 1dbf                      	adc XH,r15			; "				1
000041 90fc                      	ld r15,X			;Get data in FDC register	2
000042 bafb                      	out PortA,r15			;Send it to TI			1
000043 6800                      	sbr r16,1<<iflag		;Set our interrupt flag		1
000044 0000                      	nop				;				1
000045 0000                      	nop				;				1
                                  ;Need 13-19 cycles to here,Min 15 without errors			15
                                 	
000046 9929                      	sbic PinE,webit		;Test !we
000047 c007                      	rjmp isr2end			;Read if 1
000048 b2f3                      	in r15,PinC			;Get  write data
000049 94f0                      	com r15				;TI sends inverted data
00004a 6004                      	sbr r16,1<<wflag		;Set write flag
00004b 3804                      	cpi r16,0x84			;Check If Command
00004c f409                      	brne NotCMD			; "
00004d 9614                      	adiw X,4			;Point to Command registers
                                 NotCMD:	
00004e 92fc                      	st X,r15			;Write data to FDC register
                                 isr2end:
00004f 9300 0106                 	sts flags,r16			;
000051 2d0e                      	mov r16,r14			;
000052 bedf                      	out SREG,r13			;Restore SREG	
000053 9518                      	reti
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; USART RX Complete Interrupt Handler	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 USART_RXC:
000054 930f                      	push r16
000055 b70f                      	in r16,SREG	;Push SREG
000056 930f                      	push r16	; "
000057 93ff                      	push ZH
000058 93ef                      	push ZL
                                 	
                                 ;Move Stat & Char to buffer
000059 9100 012a                 	lds r16,SerCnt
00005b 9503                      	inc r16
00005c 9300 012a                 	sts SerCnt,r16
                                 
00005e e0f1                      	ldi ZH,high(Serbuffer)
00005f e3e0                      	ldi ZL,low(Serbuffer)
000060 9100 0128                 	lds r16,SerWrPtr
000062 0fe0                      	add ZL,r16		;
                                 ;	clr r17
                                 ;	adc ZH,r17
                                 	
000063 9503                      	inc r16
000064 3a00                      	cpi r16,Serbuffsize		;
000065 f409                      	brne jp00
000066 2700                      	clr r16
000067 9300 0128                 jp00:	sts SerWrPtr,r16
                                 
                                 ;	in r16,UCSR0A		;Get status
                                 ;	st Z+,r16		;Put in buffer
000069 b10c                      	in r16,UDR		;Get data (We know data is there because of Recv interrupt)
00006a 8300                      	st Z,r16		;Put in buffer
                                 	
                                 ;Check If AT+#xCRLF is in buffer (x is Char used below)
00006b 300a                      	cpi r16,10	;check if LF
00006c f469                      	brne jp09
                                 	
00006d 9102                      	ld r16,-Z
00006e 300d                      	cpi r16,13	;check if CR
00006f f451                      	brne jp09
                                 
000070 9734                      	sbiw Z,4
000071 9101                      	ld r16,Z+
000072 3401                      	cpi r16,'A'	;
000073 f431                      	brne jp09
                                 
000074 9101                      	ld r16,Z+
000075 3504                      	cpi r16,'T'	;	
000076 f419                      	brne jp09
                                 
000077 9101                      	ld r16,Z+
000078 3203                      	cpi r16,'#'	;
000079 f011                      	breq jp08
00007a 940c 00ca                 jp09:	jmp RXCrtn
                                  
00007c 8100                      jp08:	ld r16,Z	; 
                                 
00007d 93df                      	push YH
00007e 93cf                      	push YL
00007f 93bf                      	push XH
000080 93af                      	push XL
000081 939f                      	push r25
000082 938f                      	push r24
000083 937f                      	push r23
000084 936f                      	push r22
000085 935f                      	push r21
000086 934f                      	push r20
000087 933f                      	push r19
000088 932f                      	push r18
000089 931f                      	push r17
                                 	
00008a 3502                      chkR:	cpi r16,'R'		    ;Send reg 16-31,SREG,Ret PC
00008b f429                      	brne chkS
00008c b7fe                      	in ZH,SPH
00008d b7ed                      	in ZL,SPL
00008e 9631                      	adiw Z,1
00008f e113                      	ldi r17,19
000090 c026                      	rjmp TXLP0
                                 	
000091 3503                      chkS:	cpi r16,'S'		    ;Send all calls on stack
000092 f439                      	brne chkB
000093 b7fe                      	in ZH,SPH
000094 b7ed                      	in ZL,SPL
000095 9671                      	adiw Z,17
000096 ef1f                      	ldi r17,low(RAMEND)
000097 1b1e                      	sub r17,ZL
000098 9631                      	adiw Z,1
000099 c01d                      	rjmp TXLP0
                                 	
00009a 3402                      chkB:	cpi r16,'B'		    ;Send Serial buffer
00009b f421                      	brne chkT
00009c ea10                      	ldi r17,Serbuffsize
00009d e0f1                      	ldi ZH,high(Serbuffer)	    ; Get address to Serial buffer
00009e e3e0                      	ldi ZL,low(Serbuffer)	    ; "
00009f c017                      	rjmp TXLP0
                                 	
0000a0 3504                      chkT:	cpi r16,'T'		    ;Send TIbuffer
0000a1 f421                      	brne chkU
0000a2 2711                      	clr r17
0000a3 e0f1                      	ldi ZH,high(TIbuffer)	    ;Point to TIbuffer
0000a4 ede0                      	ldi ZL,low(TIbuffer)	    ; "
0000a5 c011                      	rjmp TXLP0
                                 	
0000a6 3505                      chkU: 	cpi r16,'U'		    ;Send upper 256 bytes of SDbuffer
0000a7 f421                      	brne chkL
0000a8 2711                      	clr r17
0000a9 e0f2                      	ldi ZH,high(SDbuffer)	    ;Point to SDbuffer
0000aa ede0                      	ldi ZL,low(SDbuffer)	    ; "
0000ab c00b                      	rjmp TXLP0
                                 	
0000ac 340c                      chkL: 	cpi r16,'L'		    ;Send lower 256 bytes of SDbuffer
0000ad f421                      	brne chkV
0000ae 2711                      	clr r17
0000af e0f3                      	ldi ZH,high(SDbuffer+128)   ;Point to lower SDbuffer
0000b0 e5e0                      	ldi ZL,low(SDbuffer+128)    ; "
0000b1 c005                      	rjmp TXLP0
                                 	
0000b2 3506                      chkV: 	cpi r16,'V'	;Send all sram (variables) except buffers
0000b3 f449                      	brne jp13
0000b4 e310                      	ldi r17,VAR_END-SRAM_START  ;Count between fdcRegisters & buffers
0000b5 e0f1                      	ldi ZH,high(SRAM_START)	    ; Get sram start address
0000b6 e0e0                      	ldi ZL,low(SRAM_START)	    ; "
                                 	
0000b7 9101                      TXLP0:	ld r16,Z+
0000b8 9b5d                      lp08:	sbis UCSR0A,UDRE	;Wait until transmit is ready
0000b9 cffe                      	rjmp lp08
0000ba b90c                      	out UDR,r16		;Send data
0000bb 951a                      	dec R17
0000bc f7d1                      	brne TXLP0
                                 	
0000bd 911f                      jp13:	pop r17
0000be 912f                      	pop r18
0000bf 913f                      	pop r19
0000c0 914f                      	pop r20
0000c1 915f                      	pop r21
0000c2 916f                      	pop r22
0000c3 917f                      	pop r23
0000c4 918f                      	pop r24
0000c5 919f                      	pop r25
0000c6 91af                      	pop XL
0000c7 91bf                      	pop XH
0000c8 91cf                      	pop YL
0000c9 91df                      	pop YH
                                 	
0000ca 91ef                      RXCrtn:	pop ZL
0000cb 91ff                      	pop ZH
0000cc 910f                      	pop r16		;pop SREG
0000cd bf0f                       	out SREG,r16	; "
0000ce 910f                      	pop r16
0000cf 9518                        	reti
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Constants
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Use to access program memory	
                                 ; ldi ZH,high(hello<<1)	;Shift (address*2) because program memory is 16 bits
                                 ; ldi ZL,low(hello<<1)	;When address bit0 is 0 low byte of word is accessed
                                 ; lpm r16,Z+		;When address bit0 is 1 high byte of word is accessed
                                 ;			;Effectively changing to byte access
                                 ;hello:
                                 ;	.db "HELLO",0
0000d0 76eb
0000d1 4590
0000d2 4658
0000d3 5441
0000d4 00ff                      EXFATstr: .db 0xEB,0x76,0x90,"EXFAT",0xFF,0 ;make even bytes
0000d5 00c1
0000d6 0056
0000d7 004f
0000d8 004c
0000d9 0055
0000da 004d
0000db 0045
0000dc ff53                      VOLstr:	.db 0xC1,0,'V',0,'O',0,'L',0,'U',0,'M',0,'E',0,'S',0xFF
0000dd 00c1
0000de 0054
0000df 0049
0000e0 0056
0000e1 004f
0000e2 004c
0000e3 0030
0000e4 0030
0000e5 ff30                      TIVOLstr: .db 0xC1,0,'T',0,'I',0,'V',0,'O',0,'L',0,'0',0,'0',0,'0',0xFF
                                  
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Setup
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 setup:
0000e6 ef0f                      	ldi r16,low(RAMEND)		;Init stack
0000e7 bf0d                      	out spl,r16			;	"
0000e8 e004                      	ldi r16,high(RAMEND)		;	"
0000e9 bf0e                      	out sph,r16			;	"
                                 ;Setup ports
0000ea ef0f                      	ser	r16			;PortA (FF) output mode for TI read
0000eb bb0a                      	out DDRA,r16			; "
0000ec 2700                      	clr	r16			;PortC (00) input mode for TI write
0000ed bb04                      	out DDRC,r16			; "
0000ee eb00                      	ldi	r16,0b10110000		;SCK,MI,MO,CS,0,0,A1,A0
0000ef bb07                      	out DDRB,r16			;O  ,I ,O ,O ,I,I,I ,I
0000f0 9ac6                      	sbi PortB,PB6			;Pullup MISO
0000f1 e00a                      	ldi	r16,0b00001010		;Side,DR3,DR2,DR1,HLD,0,TDX,RXD
0000f2 bb01                      	out DDRD,r16			;I   ,I  ,I  ,I  ,O  ,I,O  ,I
0000f3 e004                      	ldi	r16,0b00000100		;0,0,0,0,0,!Ready,!WE,!INT
0000f4 b906                      	out DDRE,r16			;I,I,I,I,I,O     ,I  ,I
                                 	
0000f5 e800                      	ldi r16,0x80			;Set TI to read status NotReady 
0000f6 bb0b                      	out PortA,r16			;Until Int2 enabled	
0000f7 983a                      	cbi PortE,rdybit		;Enable TI hardwire
                                 
0000f8 b706                      	in r16,EMCUCR			;Set INT2 falling edge trigger
0000f9 7f0e                      	cbr r16,1<<ISC2		; " ISC2=bit0 same as andi r16,0xFE
0000fa bf06                      	out EMCUCR,r16			; "
0000fb b70b                      	in r16,GICR			;Enable INT2
0000fc 6200                      	sbr r16,1<<INT2		; " INT2=bit5 same as ori r16,32
0000fd bf0b                      	out GICR,r16			; "	
                                 ;Set status				;NotReady  track0  busy
0000fe e004                      	ldi r16,0x04			;b7=0      b2=1    b0=0
0000ff 9300 0100                 	sts fdcStatus,r16		;
000101 2700                      	clr r16				; 
000102 9300 0101                 	sts fdcTrack,r16		;
000104 9300 0102                 	sts fdcSector,r16		;
000106 9300 0103                 	sts fdcData,r16		;
000108 9300 0104                 	sts fdcCommand,r16		;
00010a 9893                      	cbi PortD,3			;data not ready
                                 ;Setup USART				;baud @ 16MHz
00010b e010                      	ldi r17,0			;230.4k=0,3 115.2k=0,8(double 8&16)
00010c e008                      	ldi r16,8			;Disabled doubling
00010d d1e5                      	rcall USARTInit	
00010e b10a                      	in r16,UCSR0B			;Enable RXC interrupt
00010f 6800                      	sbr r16,1<<RXCIE		; "
000110 b90a                      	out UCSR0B,r16			; "	
                                 ;Setup SPI
000111 e100                      	ldi r16,16
000112 2ea0                      	mov r10,r16			;SD error count,So it doesn't run away
000113 d23e                      	rcall SPIInit  
000114 d316                      	rcall MMCInit
                                 ;Setup Drives	
                                 SetupStartStep:  
000115 d249                      	rcall FindTIVOL		;Find TIVOL000,Save Start and Step
000116 f019                      	breq SetupDSK
000117 e800                      	ldi r16,0x80		;disk error,not ready
000118 9300 0100                 	sts fdcStatus,r16	;
                                 ;Get DSKx addresses from SD sector 1    
                                 SetupDSK:
00011a e001                      	ldi r16,0x01
00011b 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
00011d 2700                       	clr r16
00011e 9300 011a                 	sts arg+1,r16
000120 9300 011b                 	sts arg+2,r16
000122 9300 011c                 	sts arg+3,r16		; (MSB)
000124 d405                      	rcall ReadMMC           ; First half 512 sector (uses ZL & ZH)
                                 	
                                 ;XL & XH ok to use before interrupts are enabled    	
000125 ede4                      	ldi ZL,low(SDbuffer+4)	    ;
000126 e0f2                      	ldi ZH,high(SDbuffer+4)	    ;
                                 
000127 9101                      	ld r16,Z+		    ;Get Drive 1 Disk #
000128 930f                      	push r16		    ;		    
000129 9101                      	ld r16,Z+		    ;Get Drive 2 Disk #
00012a 930f                      	push r16		    ;
00012b 9101                      	ld r16,Z+		    ;Get Drive 3 Disk #
00012c 930f                      	push r16
                                 	
00012d e0cf                      	ldi YL,low(DSK3address)    ;
00012e e0d1                      	ldi YH,high(DSK3address)   ;
                                 	
00012f e023                      	ldi r18,3
000130 915f                      lp02:	pop r21			    ;Restore disk number (stepping 3 - 1)
000131 d1a3                      	rcall Disk2Sector	    ;Convert disk # to sector address
000132 9209                      	st Y+,r0		    ;Save into DSKXaddress
000133 9219                      	st Y+,r1		    ;
000134 9229                      	st Y+,r2		    ;
000135 9239                      	st Y+,r3		    ;
000136 9728                      	sbiw Y,8		    ;Back to start of current drive + start preceding drive
000137 952a                      	dec r18			    ;
000138 f7b9                      	brne lp02		    ;All 3 drives done 
                                 	
                                 ;Set last track for drives
000139 e0e7                      	ldi ZL,low(DSK1address)    ;LSB -- MSB
00013a e0f1                      	ldi ZH,high(DSK1address)   ;
00013b e1c9                      	ldi YL,low(arg)	    ;
00013c e0d1                      	ldi YH,high(arg)	    ;
00013d d468                      	rcall mov4		    ;
00013e d3eb                      	rcall ReadMMC 		    ;First half 512 sector (uses ZL & ZH)
00013f e207                      	ldi r16,39
000140 9110 02da                 	lds r17,SDbuffer+10
000142 fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000143 e40f                      	ldi r16,79
000144 9300 0113                 	sts DSK1LastTrk,r16
                                 	
000146 e0eb                      	ldi ZL,low(DSK2address)    ;LSB -- MSB
000147 e0f1                      	ldi ZH,high(DSK2address)   ;
000148 e1c9                      	ldi YL,low(arg)	    ;
000149 e0d1                      	ldi YH,high(arg)	    ;
00014a d45b                      	rcall mov4		    ;
00014b d3de                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
00014c e207                      	ldi r16,39
00014d 9110 02da                 	lds r17,SDbuffer+10
00014f fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
000150 e40f                      	ldi r16,79
000151 9300 0114                 	sts DSK2LastTrk,r16
                                 	
000153 e0ef                      	ldi ZL,low(DSK3address)    ;LSB -- MSB
000154 e0f1                      	ldi ZH,high(DSK3address)   ;
000155 e1c9                      	ldi YL,low(arg)	    ;
000156 e0d1                      	ldi YH,high(arg)	    ;
000157 d44e                      	rcall mov4		    ;
000158 d3d1                      	rcall ReadMMC		    ;First half 512 sector (uses ZL & ZH)
000159 e207                      	ldi r16,39
00015a 9110 02da                 	lds r17,SDbuffer+10
00015c fd12                      	sbrc r17,2		    ;Check bit 2 for value 4 in 5 A0	
00015d e40f                      	ldi r16,79
00015e 9300 0115                 	sts DSK3LastTrk,r16
                                 	
                                 ;Enable interrupts	
000160 2700                      	clr r16				;Clear flags
000161 9300 0106                 	sts flags,r16			;
000163 9300 0129                 	sts SerRdPtr,r16		;Init Serial pointers
000165 9300 0128                 	sts SerWrPtr,r16
000167 9300 012a                 	sts SerCnt,r16
000169 9478                      	sei				;Global enable interrupts
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Main Loop
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00016a 2700                      main:	clr r16			    ; Clear busy,No errors	
00016b 9300 0100                 jp02:	sts fdcStatus,r16	    ; "	     
00016d 983a                      	cbi PortE,2		    ;Release TI
                                 	
00016e 9100 0106                 lp00:	lds r16,flags		    ;Get flags
000170 ff07                      	sbrs r16,iflag		    ;Has TI has sent data?
000171 cffc                      	rjmp lp00
000172 2711                      	clr r17			    ;Clear flags
000173 9310 0106                 	sts flags,r17		    ; "		    
                                 	
000175 9100 0104                 	lds r16,fdcCommand	    ;
000177 3000                      	cpi r16,0x00		    ;
000178 f3a9                      	breq lp00
                                 	
000179 9a3a                      	sbi PortE,2		    ;Put TI on hold while process command
00017a 9310 0104                 	sts fdcCommand,r17	    ;Clear command (r17=0 from above)
                                 ;	ldi r17,0x01		    ;Set Busy bit
                                 ;	sts fdcStatus,r17	    ; "
                                 	
                                 ;	rcall USARTWrite	    ;Send command in r16 (enable for debbuging)
                                 	
                                 ;Our Mount Disk command	
                                 fdcCMD81:			    	
00017c 3801                      	cpi r16,0x81		   
00017d f411                      	brne fdcCMD82
00017e d139                      	rcall ChgDisk
00017f cf9a                      	rjmp SetupDSK		    ;Setup disk addresses and last track
                                 ;Our Send all disk names command		
                                 fdcCMD82:			    
000180 3802                      	cpi r16,0x82		    
000181 f411                      	brne usartCMD83
000182 d10e                      	rcall SendNames
000183 cfe6                      	rjmp main
                                 ;Read Usart status
                                 usartCMD83:			    
000184 3803                      	cpi r16,0x83		    
000185 f411                      	brne usartCMD84
000186 d17f                      	rcall TIrdUsartStat
000187 cfe2                      	rjmp main
                                 ;Read Usart data
                                 usartCMD84:			    
000188 3804                      	cpi r16,0x84		    
000189 f411                      	brne usartCMD85
00018a d189                      	rcall TIrdUsartData
00018b cfde                      	rjmp main
                                 ;Write Usart data
                                 usartCMD85:			    
00018c 3805                      	cpi r16,0x85		    
00018d f411                      	brne usartCMD86
00018e d1a1                      	rcall TIwrUsartData
00018f cfda                      	rjmp main
                                 ;Usart Sub Command
                                 usartCMD86:			    
000190 3806                      	cpi r16,0x86		    
000191 f411                      	brne xmdCMD87
000192 d1a3                      	rcall TIwrUsartSub
000193 cfd6                      	rjmp main
                                 ;Xmodem Volume Transfer
                                 xmdCMD87:			    
000194 3807                      	cpi r16,0x87		    
000195 f411                      	brne fdcCMD0A
000196 d440                      	rcall XMODEM
000197 cfd2                      	rjmp main	
                                 ;0A Restore (h=1,V=0,r0r1=10)	
                                 fdcCMD0A:			   
000198 300a                      	cpi r16,0x0A		    ;
000199 f439                      	brne fdcCMD1E
00019a 2700                      	clr r16			    ;
00019b 9300 0101                 	sts fdcTrack,r16	    ;Set to track 0
00019d 9300 0102                 	sts fdcSector,r16	    ;Set to sector 0
00019f 6004                      	sbr r16,0x04		    ;Set track 0 in status
0001a0 cfca                      	rjmp jp02
                                 ;1E Seek h=1 V=1 r1r0=10
                                 fdcCMD1E:			    
0001a1 310e                      	cpi r16,0x1E		    ;
0001a2 f429                      	brne fdcCMD5A
0001a3 9100 0103                 	lds r16,fdcData
0001a5 9300 0101                 	sts fdcTrack,r16
0001a7 cfc2                      	rjmp main
                                 ;2x Step not used by TI
                                 ;5A Step-in T=1,h=1,V=0,r0r1=10	
                                 fdcCMD5A:			    
0001a8 350a                      	cpi r16,0x5A		    ;
0001a9 f431                      	brne fdcCMD88
0001aa 9100 0101                 	lds r16,fdcTrack
0001ac 9503                      	inc r16
0001ad 9300 0101                 	sts fdcTrack,r16
0001af cfba                      	rjmp main
                                 ;6x Step-out not used by TI
                                 ;88 Read sector m=0 S=1 E=0 C=0		    
                                 fdcCMD88:			    
0001b0 3808                         	cpi r16,0x88		    ;
0001b1 f411                      	brne fdcCMDA8
0001b2 d042                      	rcall TIreadsec
0001b3 cfb6                      	rjmp main
                                 ;A8 Write sector m=0 S=1 E=0 C=0 a=0
                                 fdcCMDA8:			    
0001b4 3a08                      	cpi r16,0xA8		    ;
0001b5 f411                      	brne fdcCMDC0
0001b6 d02b                      	rcall TIwritesec
0001b7 cfb2                      mainRLY: rjmp main
                                 ;C0 Read ID E=0
                                 fdcCMDC0:			    
0001b8 3c00                      	cpi r16,0xC0		    ;
0001b9 f411                      	brne fdcCMDF4
0001ba d009                      	rcall TIreadID
0001bb cfae                      	rjmp main
                                 ;Ex Read track not used by TI
                                 ;F4 Write track (E=1)
                                 fdcCMDF4:			    
0001bc 3f04                          	cpi r16,0xF4		    ;
0001bd f411                      	brne fdcCMDD0
0001be d0ac                      	rcall TIwritetrack
0001bf cff7                      	rjmp mainRLY
                                 ;D0 Force interrupt
                                 fdcCMDD0:			    
0001c0 3d00                          	cpi r16,0xD0		    ;Sent after software reset (FTCN =)
0001c1 f7a9                      	brne mainRLY
0001c2 d39b                      	rcall delay1ms
0001c3 cf56                      	rjmp SetupDSK		    ;Setup disks in case one was formatted
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadID:
0001c4 983a                      	cbi PortE,2		;Release TI
0001c5 9100 0101                 	lds r16,fdcTrack	;Get track
0001c7 9300 0103                 	sts fdcData,r16		;Send to TI
0001c9 d072                      	rcall WaitTIread	; "
0001ca 2700                      	clr r16			;Side 0
0001cb 9987                      	sbic PinD,7		;Get Side
0001cc 9503                      	inc r16			;Side 1
0001cd 9300 0103                 	sts fdcData,r16		;Send to TI
0001cf d06c                      	rcall WaitTIread	; "
0001d0 9100 0102                 	lds r16,fdcSector	;Get sector
0001d2 9300 0103                 	sts fdcData,r16		;Send to TI
0001d4 d067                      	rcall WaitTIread	; "
0001d5 2700                      	clr r16			;Sector lenght code?
0001d6 9300 0103                 	sts fdcData,r16		;Send to TI
0001d8 d063                      	rcall WaitTIread	; "
0001d9 2700                      	clr r16			;CRC byte1
0001da 9300 0103                 	sts fdcData,r16		;Send to TI
0001dc d05f                      	rcall WaitTIread	; "
0001dd 2700                      	clr r16			;CRC byte2
0001de 9300 0103                 	sts fdcData,r16		;Send to TI
0001e0 d05b                      	rcall WaitTIread	; "
0001e1 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritesec:
0001e2 e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
0001e3 ede0                      	ldi ZL,low(TIbuffer)	; "
0001e4 e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001e5 983a                      	cbi PortE,2		;Release TI
0001e6 d05f                      lp24:	rcall WaitTIwrite	;Wait for data from TI
0001e7 9100 0103                 	lds r16,fdcData	;Get next byte
0001e9 9301                      	st Z+,r16		;Save to buffer
0001ea 952a                      	dec r18
0001eb f7d1                      	brne lp24
                                 	
0001ec 9a3a                      	sbi PortE,2		;Put TI on hold while process command
0001ed e001                      	ldi r16,1
0001ee 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
0001ef 2700                      	clr r16
0001f0 9300 0105                 	sts fdcSide,r16
0001f2 d014                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001f3 d06b                      	rcall TI_SD_wr		;Write to SD
0001f4 9508                      	ret	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIreadsec:
0001f5 e001                      	ldi r16,1
0001f6 9b87                      	sbis PinD,7		;Test pin,Skip if side 1
0001f7 2700                      	clr r16
0001f8 9300 0105                 	sts fdcSide,r16
0001fa d00c                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
0001fb d054                      	rcall TI_SD_rd		;Get sector from SD
0001fc e0f1                      	ldi ZH,high(TIbuffer)	; Get address to buffer
0001fd ede0                      	ldi ZL,low(TIbuffer)	; "
0001fe e020                      	ldi r18,0x00		;256 bytes per sector
                                 	
0001ff 983a                      	cbi PortE,2		;Release TI
000200 9101                      lp13:	ld r16,Z+		;Get next byte
000201 9300 0103                 	sts fdcData,r16		;Send to TI
000203 d038                      	rcall WaitTIread	; "
000204 952a                      	dec r18
000205 f7d1                      	brne lp13
000206 9508                      	ret
                                 ;	
                                 ;Convert TI track&sector to SD sector	
                                 Track2Arg:
000207 9100 0101                 	lds r16,fdcTrack
000209 9110 0105                 	lds r17,fdcSide
00020b ff10                      	sbrs r17,0		;Test bit,Skip if side 1	
00020c c00c                      	rjmp jp10
00020d 9110 0113                 	lds r17,DSK1LastTrk	;
00020f 9985                      	sbic PinD,5		;
000210 9110 0114                 	lds r17,DSK2LastTrk	;
000212 9986                      	sbic PinD,6		;
000213 9110 0115                 	lds r17,DSK3LastTrk	;
000215 1b01                      	sub r16,R17		;Reverse track (0=-39 or -79) 
000216 9501                      	neg r16			;Make postive
000217 9513                      	inc r17			;
000218 0f01                      	add r16,r17		;Track + 40 or 80
                                 jp10:	
000219 e019                      	ldi r17,9		;Track*9
00021a 9f01                      	mul r16,r17		;Result in r0 r1
00021b 2711                      	clr r17			;Add sector offset 0-8		
00021c 9100 0102                 	lds r16,fdcSector	; "
00021e 0e00                      	add r0,r16		; "
00021f 1e11                      	adc r1,r17		; "
                                 	
                                 	;Divide TI sector by 2 to put in upper or lower half of SD sector
000220 9200 0116                 	sts TIlowbyte,r0 	;save low byte for bit 0 test
000222 9416                      	lsr r1			;Divide 16 bits by 2
000223 9407                      	ror r0			; "	"	"
                                 	
                                 	;Add TI sector to DSKx SD start sector address and place in ARG
000224 e0f1                      	ldi ZH,high(DSK1address)   ;
000225 e0e7                      	ldi ZL,low(DSK1address)    ;
000226 9985                      	sbic PinD,5		    ;
000227 9634                      	adiw Z,4		    ;DSK2address
000228 9986                      	sbic PinD,6		    ;
000229 9638                      	adiw Z,8		    ;DSK3address
                                 
00022a 9101                      	ld r16,Z+
00022b 0d00                      	add r16,r0
00022c 9300 0119                 	sts arg,r16
00022e 9101                      	ld r16,Z+
00022f 1d01                      	adc r16,r1
000230 9300 011a                 	sts arg+1,r16
000232 2400                      	clr r0			;carry not affected
000233 9101                      	ld r16,Z+
000234 1d00                      	adc r16,r0
000235 9300 011b                 	sts arg+2,r16
000237 8100                      	ld r16,Z
000238 1d00                      	adc r16,r0
000239 9300 011c                 	sts arg+3,r16
00023b 9508                      	ret
                                 ;	
                                 WaitTIread:
00023c 9100 0106                 	lds r16,flags		;Get flags
00023e ff07                      	sbrs r16,iflag		;Has TI read data?
00023f cffc                      	rjmp WaitTIread
000240 2711                      	clr r17			;Clear interrupt flag
000241 9310 0106                 	sts flags,r17		; "
000243 3803                      	cpi r16,0x83		;Was it read data register
000244 f7b9                      	brne WaitTIread
000245 9508                      	ret
                                 WaitTIwrite:
000246 9100 0106                 	lds r16,flags		;Get flags
000248 ff07                      	sbrs r16,iflag		;Has TI written data?
000249 cffc                      	rjmp WaitTIwrite
00024a 2711                      	clr r17			;Clear interrupt flag
00024b 9310 0106                 	sts flags,r17		; "
00024d 3807                      	cpi r16,0x87		;Was it write data register
00024e f7b9                      	brne WaitTIwrite
00024f 9508                      	ret
                                 	
                                 TI_SD_rd:
000250 d2d9                      	rcall readmmc		;512 bytes in sdbuffer
000251 ede0                      	ldi ZL,low(SDbuffer)
000252 e0f2                      	ldi ZH,high(SDbuffer)
000253 9100 0116                 	lds r16,TIlowbyte
000255 fd00                      	sbrc r16,0
000256 95f3                      	inc ZH			;Add 256 to Z
000257 edc0                      	ldi YL,low(TIbuffer)
000258 e0d1                      	ldi YH,high(TIbuffer)
                                 ;Move 256 bytes from source(Z) to destination(Y)
000259 2700                      mov256:	clr r16		
00025a 9111                      lp03:	ld r17,Z+ 
00025b 9319                      	st Y+,r17
00025c 950a                      	dec r16
00025d f7e1                      	brne lp03
00025e 9508                      	ret	;and send to TI
                                 TI_SD_wr:
00025f d2ca                      	rcall readmmc	//512 bytes in sdbuffer
000260 ede0                      	ldi ZL,low(TIbuffer)
000261 e0f1                      	ldi ZH,high(TIbuffer)
000262 edc0                      	ldi YL,low(SDbuffer)
000263 e0d2                      	ldi YH,high(SDbuffer)
000264 9100 0116                 	lds r16,TIlowbyte
000266 fd00                      	sbrc r16,0
000267 95d3                      	inc YH			;Add 256 to Y
000268 dff0                      	rcall mov256
000269 d28d                      	rcall writemmc	//512 bytes in sdbuffer
00026a 9508                      	ret	
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIwritetrack:
00026b e049                      	ldi r20,9
                                 lp25:	
00026c 983a                      	cbi PortE,2		;Release TI
                                 	
                                 ;Get (FE,Track,Side,Sector,1?,F7)	
                                 lp26:	
00026d dfd8                      	rcall WaitTIwrite	;Wait for data from TI
00026e 9100 0103                 	lds r16,fdcData		;Get next byte
000270 3f0e                      	cpi r16,0xFE
000271 f7d9                      	brne lp26
                                 	
000272 dfd3                      	rcall WaitTIwrite	;Throw away Track,already loaded
                                 
000273 dfd2                      	rcall WaitTIwrite	;Wait for data from TI
000274 9100 0103                 	lds r16,fdcData	
                                 ;	ror r16			;Move bit0 to bit7
                                 ;	ror r16			; "
000276 9300 0105                 	sts fdcSide,r16		;Save Side
                                 	
000278 dfcd                      	rcall WaitTIwrite	;Wait for data from TI
000279 9100 0103                 	lds r16,fdcData	
00027b 9300 0102                 	sts fdcSector,r16	;Save Sector
                                 
                                 ;Get (FB,256 bytes E5,F7)	
                                 lp27:	
00027d dfc8                      	rcall WaitTIwrite	;Wait for data from TI
00027e 9100 0103                 	lds r16,fdcData		;Get next byte
000280 3f0b                      	cpi r16,0xFB
000281 f7d9                      	brne lp27
                                 	
000282 e0f1                       	ldi ZH,high(TIbuffer)	;Get address to buffer
000283 ede0                      	ldi ZL,low(TIbuffer)	; "
000284 e020                      	ldi r18,0x00		;256 bytes per sector
                                 lp28:	
000285 dfc0                      	rcall WaitTIwrite	;Wait for data from TI
000286 9100 0103                 	lds r16,fdcData	;Get next byte
000288 9301                      	st Z+,r16		;Save to buffer
000289 952a                      	dec r18
00028a f7d1                      	brne lp28
                                 	
00028b 9a3a                      	sbi PortE,2		;Put TI on hold while process command
00028c df7a                      	rcall Track2Arg		;Set arg to SD sector for TI DISK
00028d dfd1                      	rcall TI_SD_wr		;Write to SD
                                 	
00028e 954a                      	dec r20			;All 9 sectors done?
00028f f6e1                      	brne lp25      
000290 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;All disks names 0-255 sent to TI
                                 ; ENTRY:
                                 ;
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 SendNames:
                                 ;Send disk numbers DSK1-3 
000291 e001                      	ldi r16,0x01
000292 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
000294 2700                       	clr r16
000295 9300 011a                 	sts arg+1,r16
000297 9300 011b                 	sts arg+2,r16
000299 9300 011c                 	sts arg+3,r16		; (MSB)
00029b d28e                      	rcall ReadMMC           ; Read sector 1
00029c e0f2                      	ldi ZH,high(SDbuffer+4)	; Point to disk #s in buffer
00029d ede4                      	ldi ZL,low(SDbuffer+4)	; "
                                    
00029e e043                      	ldi r20,3
00029f 9101                      lp93:	ld r16,Z+		;Mov char from buffer to fdcData
0002a0 9300 0103                 	sts fdcData,r16		;
0002a2 983a                      	cbi PortE,2		;Release TI
0002a3 df98                      	rcall WaitTIread	;Wait for TI to read
0002a4 9a3a                      	sbi PortE,2		;Put TI on hold
0002a5 954a                      	dec r20
0002a6 f7c1                      	brne lp93
                                 	
                                 ;Send Names
0002a7 2755                      	clr r21			;Start at disk 0
0002a8 d02c                      lp91:	rcall Disk2Sector	;Convert disk# in R21 to sector address
0002a9 d280                      	rcall ReadMMC           ;Read sector
0002aa ede0                      	ldi ZL,low(SDbuffer)	;Get address to buffer
0002ab e0f2                      	ldi ZH,high(SDbuffer)	; "
                                 	
0002ac e04a                      	ldi r20,10
0002ad 9101                      lp92:	ld r16,Z+		;Mov char from buffer to fdcData
0002ae 9300 0103                 	sts fdcData,r16		;
0002b0 983a                      	cbi PortE,2		;Release TI
0002b1 df8a                      	rcall WaitTIread	;Wait for TI to read
0002b2 9a3a                      	sbi PortE,2		;Put TI on hold
0002b3 954a                      	dec r20
0002b4 f7c1                      	brne lp92
                                 	
0002b5 9553                      	inc r21			;Next disk
0002b6 f789                      	brne lp91		;If roll over then finished
0002b7 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Change disk in drive
                                 ; ENTRY:
                                 ;	From TI	- r20 Drive 1-3 
                                 ;	From TI - r21 Disk 0-255
                                 ; EXIT:
                                 ;	
                                 ; Registers used r16 r17 r20 r21	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ChgDisk:
                                 ;Get drive number from TI
0002b8 983a                      	cbi PortE,2		;Release TI
0002b9 df8c                      	rcall WaitTIwrite	;Wait for data from TI
0002ba 9140 0103                 	lds r20,fdcData	;Get Drive number
0002bc 7043                      	andi r20,0x03		;
0002bd 954a                      	dec r20			;DSK 1-3 to 0-2
                                 ;Get disk number from TI
0002be df87                      	rcall WaitTIwrite	;Wait for data from TI
0002bf 9150 0103                 	lds r21,fdcData	;Get disk number
0002c1 9a3a                      	sbi PortE,2		;Put TI on hold
                                 	
                                 ;Put new disk number in sector 1	
0002c2 e001                      	ldi r16,0x01
0002c3 9300 0119                 	sts arg,r16		; (LSB) sector 00 00 00 01
0002c5 2700                       	clr r16
0002c6 9300 011a                 	sts arg+1,r16
0002c8 9300 011b                 	sts arg+2,r16
0002ca 9300 011c                 	sts arg+3,r16		; (MSB)
0002cc d25d                      	rcall ReadMMC           ; Read sector 1
0002cd e0f2                      	ldi ZH,high(SDbuffer)	; Get address to buffer
0002ce ede0                      	ldi ZL,low(SDbuffer)	; "
                                 ; Drive number r20
                                 ; Disk number r21
0002cf 0fe4                      	add ZL,r20		;Point to drive in sector 1		
0002d0 2700                      	clr r16			; "
0002d1 1ff0                      	adc ZH,r16		; "
0002d2 8354                      	std Z+4,r21		; Save new disk number
0002d3 d223                      	rcall WriteMMC          ; Write sector 1 back to SD
0002d4 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Multiply DISK number and store sector address at DSKx addresses
                                 ; Entry:
                                 ;	r21 = disk number
                                 ;
                                 ; Exit:	    
                                 ;	Disk sector address store in arg also in r0-r3	
                                 ;	Registers used r0-r5 r16 r17 Z
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Disk2Sector:
0002d5 2e55                       	mov r5,r21		    ;Save dsisk number
                                 
0002d6 e0f1                      	ldi ZH,high(StartSector)   ; "
0002d7 e2e4                      	ldi ZL,low(StartSector)    ; "
0002d8 9001                      	ld r0,Z+		    ;initilize to start sector
0002d9 9011                      	ld r1,Z+		    ; "
0002da 2422                      	clr r2			    ; "
0002db 2433                      	clr r3			    ; "
0002dc 9101                      	ld r16,Z+		    ;Get step sectors
0002dd 9111                      	ld r17,Z+		    ; "   
                                 
0002de 2055                      	tst r5			    ; Test for Disk number zero
0002df f019                      	breq jp90		    ; skip if zero
0002e0 d009                      lp90:	rcall Add32_16		    ;Multiply disk number by step
0002e1 945a                      	dec r5			    ; "
0002e2 f7e9                      	brne lp90		    ; "
                                 	
0002e3 e0f1                      jp90:	ldi ZH,high(arg)	    ;Place result in argument
0002e4 e1e9                      	ldi ZL,low(arg)	    ; "
0002e5 9201                       	st Z+,r0
0002e6 9211                      	st Z+,r1	
0002e7 9221                      	st Z+,r2	
0002e8 9231                      	st Z+,r3
0002e9 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; Add 16 bits to 32 bits (lsbyte first)
                                 ; Entry		r0,r1,r2,r3 + r16,r17 
                                 ; Exit result	r0,r1,r2,r3
                                 ; r4 cleared,r16,r17 not destroyed	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 Add32_16:	
0002ea 2444                      	clr r4
0002eb 0e00                      	add r0,r16  ;add low byte
0002ec 1c14                      	adc r1,r4
0002ed 1c24                      	adc r2,r4
0002ee 1c34                      	adc r3,r4
0002ef 0e11                      	add r1,r17 ;add high byte
0002f0 1c24                      	adc r2,r4
0002f1 1c34                      	adc r3,r4
0002f2 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; USART routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 USARTInit:
0002f3 b909                      	out UBRR0L,r16			;Set Baud rate
0002f4 bd10                      	out UBRR0H,r17
0002f5 e806                      	ldi r16,(1<<URSEL0)|(3<<UCSZ00)	;8N1
0002f6 bd00                      	out UCSR0C,r16
0002f7 e108                      	ldi r16,(1<<RXEN)|(1<<TXEN)	;Enable receive & transmit
0002f8 b90a                      	out UCSR0B,r16
                                 ;	ldi r16,(1<<U2X)		;Double the baud rate
                                 ;	out UCSR0A,r16
0002f9 9508                      	ret
                                 USARTRead:
0002fa 9b5f                      	sbis UCSR0A,RXC			;Wait until data is available
0002fb cffe                      	rjmp USARTRead
0002fc b10c                      	in r16,UDR			;Get received data
0002fd 9508                      	ret
                                 USARTWrite:
0002fe 9b5d                      	sbis UCSR0A,UDRE		;Wait until transmit is ready
0002ff cffe                      	rjmp USARTWrite
000300 b90c                      	out UDR,r16			;Send data
000301 9508                      	ret
                                 USARTFlush:
000302 9b5f                      	sbis UCSR0A,RXC
000303 9508                      	ret
000304 b10c                      	in r16,UDR
000305 cffc                      	rjmp USARTFlush
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; TI access to USART
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 TIrdUsartStat:
000306 b10a                          	in r16,UCSR0B		;Check if RXC interrupt enabled
000307 ff07                      	sbrs r16,RXCIE		;Skip if intr set
000308 c006                      	rjmp jp16		;Get data from USART
                                 	    
000309 9100 012a                 	lds r16,SerCnt
00030b 3000                      	cpi r16,0
00030c f019                      	breq jp17		;Send 0 No data available
00030d ee02                      	ldi r16,226		;Send 226 status If buffer not 0
00030e c001                      	rjmp jp17		;
                                 
00030f b10b                      jp16:	in r16,UCSR0A
000310 9300 0103                 jp17:	sts fdcData,r16		;Send to TI
000312 983a                      	cbi PortE,2		;Release TI
000313 9508                      	ret
                                 
                                 TIrdUsartData:
000314 b10a                              in r16,UCSR0B		;Check if RXC interrupt enabled
000315 ff07                      	sbrs r16,RXCIE		;Skip if intr set
000316 c014                      	rjmp jp18		;Get data from USART
                                     
000317 9100 012a                 	lds r16,SerCnt
000319 3000                      	cpi r16,0
00031a f089                      	breq jp19		;Send 0 No data available
00031b 950a                      	dec r16
00031c 9300 012a                 	sts SerCnt,r16
                                 	
00031e e0f1                      	ldi ZH,high(Serbuffer)
00031f e3e0                      	ldi ZL,low(Serbuffer)
000320 9100 0129                 	lds r16,SerRdPtr	;ptr Status byte
000322 0fe0                      	add ZL,r16		;Point Z to Char byte
                                 ;	clr r17			;
                                 ;	adc ZH,r17
000323 9503                      	inc r16			;ptr next entry
000324 3a00                      	cpi r16,Serbuffsize
000325 f409                      	brne jp14
000326 2700                      	clr r16
000327 9300 0129                 jp14:	sts SerRdPtr,r16
000329 8100                      	ld r16,Z		;Get char from buffer
00032a c001                      	rjmp jp19
                                 	
00032b b10c                      jp18:	in r16,UDR		;Get char from USART
00032c 9300 0103                 jp19:	sts fdcData,r16		;Send to TI
00032e 983a                      	cbi PortE,2		;Release TI
00032f 9508                      	ret 
                                 	 
                                 TIwrUsartData:
000330 983a                      	cbi PortE,2		;Release TI
000331 df14                      	rcall WaitTIwrite	;Wait for data from TI
000332 9100 0103                 	lds r16,fdcData
000334 dfc9                      	rcall USARTWrite
000335 9508                      	ret
                                     
                                 TIwrUsartSub:
000336 983a                      	cbi PortE,2		;Release TI
000337 df0e                      	rcall WaitTIwrite	;Wait for data from TI
000338 9100 0103                 	lds r16,fdcData
00033a 9a3a                      	sbi PortE,2		;Hold TI
                                 
00033b 3000                      	cpi r16,0		;Flush Buffer
00033c f449                      	brne jp20
00033d dfc4                      	rcall USARTFlush
00033e 2700                      	clr r16			;
00033f 9300 0129                 	sts SerRdPtr,r16	;Reset pointers
000341 9300 0128                 	sts SerWrPtr,r16
000343 9300 012a                 	sts SerCnt,r16
000345 9508                      	ret
                                 
000346 3001                      jp20:	cpi r16,1		;Turn on 128 buffer
000347 f421                      	brne jp21		;
000348 b10a                      	in r16,UCSR0B		;Enable RXC interrupt
000349 6800                      	sbr r16,1<<RXCIE	; "
00034a b90a                      	out UCSR0B,r16		; "
00034b 9508                      	ret			;		
                                 
00034c 3002                      jp21:	cpi r16,2		;Turn off 128 buffer
00034d f419                      	brne jp22		;
00034e b10a                      	in r16,UCSR0B		;Disable RXC interrupt
00034f 770f                      	cbr r16,1<<RXCIE	; "
000350 b90a                      	out UCSR0B,r16		; "
000351 9508                      jp22:	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
                                 ; SPI routines
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SPIInit:
000352 e503                      	ldi r16,(1<<SPE)|(1<<MSTR)|(3<<SPR0)	;En SPI,Master,fosc/128(125k)
000353 b90d                      	out SPCR,r16	;DORD=MSB,CPOL=rising,CPHA=LeadSample/TrailSetup
                                 ;	ldi r16,(1<<SPI2X)			; SPI double speed
                                 ;	out SPSR,r16	
000354 9508                      	ret
                                 SPIRead:
000355 ef0f                      	ser r16			;Transmit ones to receive byte
                                 SPIWrite:
000356 b90f                      	out SPDR,r16		;Send transmit byte
                                 SPIWait:	
000357 9b77                      	sbis SPSR,SPIF		;Wait Fot Transmission complete
000358 cffe                      	rjmp SPIWait
000359 b10f                      	in	r16,SPDR	; Get received byte
00035a 9508                      	ret
                                 FullThrottle:
00035b 9868                      	cbi SPCR,SPR0
00035c 9869                      	cbi SPCR,SPR1
00035d 9a70                      	SBI SPSR,SPI2X
00035e 9508                      	ret
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ; Access EXFAT find file TIVOL000
                                 ;	
                                 ;************************************************************************************
                                 ; Process Master Boot Sector
                                 ;************************************************************************************
                                 FindTIVOL:
00035f 2700                      	clr r16				;Get MBR sector
000360 9300 0119                 	sts arg,r16			; (LSB) sector 00 00 00 00
000362 9300 011a                 	sts arg+1,r16
000364 9300 011b                 	sts arg+2,r16
000366 9300 011c                 	sts arg+3,r16			; (MSB)
000368 d1c1                      	rcall ReadMMC           	; First 512 sector (uses ZL & ZH)
                                 		
000369 e9e6                      	ldi ZL,low(SDbuffer+0x1C6)	;Save VBR in Offset
00036a e0f4                      	ldi ZH,high(SDbuffer+0x1C6)	; "
00036b e2c0                      	ldi YL,low(Offset)		; "
00036c e0d1                      	ldi YH,high(Offset)		; "
00036d d238                      	rcall mov4
                                 
                                 ;************************************************************************************
                                 ; Process Volume Boot Sector
                                 ;************************************************************************************
00036e e2e0                      	ldi ZL,low(Offset)		;Put vbr in arg
00036f e0f1                      	ldi ZH,high(Offset)		;
000370 e1c9                      	ldi YL,low(arg)    		; "
000371 e0d1                      	ldi YH,high(arg)   		; "
000372 d233                      	rcall mov4
000373 d1b6                      	rcall ReadMMC           	; Get VBR sector	
                                 	
000374 ede0                      	ldi ZL,low(SDbuffer)		;Point to buffer
000375 e0f2                      	ldi ZH,high(SDbuffer)		;
000376 eac0                      	ldi YL,low(EXFATstr<<1)
000377 e0d1                      	ldi YH,high(EXFATstr<<1)
000378 d21a                      	rcall cmpstr
000379 f561                      	brne DiskErrRly			;Partition is not EXFAT
                                 	
00037a e2c8                      	ldi YL,low(SDbuffer+0x58)	;Save HeapOffset+VBR
00037b e0d3                      	ldi YH,high(SDbuffer+0x58)	; "
00037c e2a0                      	ldi XL,low(OffSet)    		; "
00037d e0b1                      	ldi XH,high(Offset)   		; "
00037e d22d                      	rcall AddDword			; Result in Offset
                                 
00037f e3e0                      	ldi ZL,low(SDbuffer+0x60)	;Get RootDirectory cluster
000380 e0f3                      	ldi ZH,high(SDbuffer+0x60)	; "
000381 e1c9                      	ldi YL,low(arg)    		; "
000382 e0d1                      	ldi YH,high(arg)   		; "
000383 d222                      	rcall mov4
                                 	
000384 9100 0119                 	lds r16,arg			; Start cluster - 2
000386 950a                      	dec r16				;
000387 950a                      	dec r16				;
000388 9300 0119                 	sts arg,r16			;
                                 
00038a e3ed                      	ldi ZL,low(SDbuffer+0x6D)	;Point to SectorsPerClusterShift
00038b e0f3                      	ldi ZH,high(SDbuffer+0x6D)	;
00038c 8130                      	ld r19,Z			;
00038d 9330 011f                 	sts SectorsPerCluster,r19 	;Save SectorsPerClusterShift
00038f d1ec                      	rcall LslArg			;RootDirectory * SectorsPerClusterShift
                                 
                                 ;************************************************************************************
                                 ; Process Root Directory Sector	(Find VOLUMES folder)
                                 ;************************************************************************************
000390 e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to RootDirectory in arg
000391 e0b1                      	ldi XH,high(arg)		; "
000392 e2c0                      	ldi YL,low(OffSet)    		; "
000393 e0d1                      	ldi YH,high(Offset)   		; "
000394 d217                      	rcall AddDword			; "
000395 d194                      	rcall ReadMMC           	;Get RootDirectory sector
                                 	    
000396 ede0                      	ldi ZL,low(SDbuffer)		;Point to buffer
000397 e0f2                      	ldi ZH,high(SDbuffer)		;
000398 eaca                      	ldi YL,low(VOLstr<<1)
000399 e0d1                      	ldi YH,high(VOLstr<<1)
                                 
00039a 8100                      lp06:	ld r16,Z
00039b 3c01                      	cpi r16,0xC1			;Check for type C1 entry
00039c f411                      	brne jp06
00039d d1f5                      	rcall cmpstr
00039e f041                      	breq jp03
                                 
00039f 96b0                      jp06:	adiw ZH:ZL,32			;Next entry
0003a0 ed00                      	ldi R16,low(SDbuffer+512)
0003a1 17e0                      	cp ZL,r16			;Check end of buffer
0003a2 f7b9                      	brne lp06  
0003a3 e004                      	ldi R16,high(SDbuffer+512)
0003a4 17f0                      	cp ZH,r16			;Check end of buffer
0003a5 f7a1                      	brne lp06  
                                 DiskErrRly:
0003a6 c05e                      	rjmp DiskErr			;VOLUMES not found
                                 
                                 jp03:	
0003a7 97b0                       	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
0003a8 9674                       	adiw ZH:ZL,20			;Point to VOLUMES folder cluster dword at 20
0003a9 e1c9                      	ldi YL,low(arg)    		; "
0003aa e0d1                      	ldi YH,high(arg)   		; "
0003ab d1fa                      	rcall mov4
                                 	
0003ac 9100 0119                 	lds r16,arg			; Start cluster - 2
0003ae 950a                      	dec r16				;
0003af 950a                      	dec r16				;
0003b0 9300 0119                 	sts arg,r16			;
                                 
0003b2 9130 011f                 	lds r19,SectorsPerCluster
0003b4 d1c7                      	rcall LslArg			;VOLUMES folder * SectorsPerCluster
                                 
                                 ;************************************************************************************
                                 ; Process VOLUMES Sector	(Find TIVOL000 file sector)
                                 ;************************************************************************************
0003b5 e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to VOLUMES folder in arg
0003b6 e0b1                      	ldi XH,high(arg)		; "
0003b7 e2c0                      	ldi YL,low(Offset)    		; "
0003b8 e0d1                      	ldi YH,high(Offset)   		; "
0003b9 d1f2                      	rcall AddDword			; "
0003ba d16f                      	rcall ReadMMC           	;Get VOLUMES folder sector
                                 	
0003bb ede0                      	ldi ZL,low(SDbuffer)		;Point to buffer
0003bc e0f2                      	ldi ZH,high(SDbuffer)		;
0003bd ebca                      	ldi YL,low(TIVOLstr<<1)
0003be e0d1                      	ldi YH,high(TIVOLstr<<1)
                                 	
0003bf 8100                      lp04:	ld r16,Z
0003c0 3c01                      	cpi r16,0xC1			;Check for type C1 entry
0003c1 f411                      	brne jp04
0003c2 d1d0                      	rcall cmpstr
0003c3 f041                      	breq jp05			;TIVOL000 found
                                 
0003c4 96b0                      jp04:	adiw ZH:ZL,32			;Next entry
0003c5 ed00                      	ldi R16,low(SDbuffer+512)
0003c6 17e0                      	cp ZL,r16			;Check end of buffer
0003c7 f7b9                      	brne lp04  
0003c8 e004                      	ldi R16,high(SDbuffer+512)
0003c9 17f0                      	cp ZH,r16			;Check end of buffer
0003ca f7a1                      	brne lp04  
0003cb c039                      	rjmp DiskErr			;TIVOL000 not found
                                 
0003cc 97b0                      jp05:	sbiw ZH:ZL,32			;Back up from type C1 entry to C0 entry
0003cd 9674                      	adiw ZH:ZL,20			;Point TIVOL000 file cluster dword at 20
0003ce e1c9                      	ldi YL,low(arg)    		; TIVOL000 file cluster
0003cf e0d1                      	ldi YH,high(arg)   		; "
0003d0 d1d5                      	rcall mov4
                                 	
0003d1 9100 0119                 	lds r16,arg			; Start cluster - 2
0003d3 950a                      	dec r16				;
0003d4 950a                      	dec r16				;
0003d5 9300 0119                 	sts arg,r16			;
                                 	
0003d7 9130 011f                 	lds r19,SectorsPerCluster
0003d9 d1a2                      	rcall LslArg			;TIVOL000 file * SectorsPerCluster
                                 
0003da e1a9                      	ldi XL,low(arg)		;Add VBR+HeapOffset to TIVOL000 file in arg
0003db e0b1                      	ldi XH,high(arg)		; "
0003dc e2c0                      	ldi YL,low(OffSet)    		; "
0003dd e0d1                      	ldi YH,high(OffSet)   		; "
0003de d1cd                      	rcall AddDword			;
0003df 9100 0119                 	lds r16,arg			;Save TIVOL000 start sector
0003e1 9300 0124                 	sts StartSector,r16		; "
0003e3 9100 011a                 	lds r16,arg+1			; "
0003e5 9300 0125                 	sts StartSector+1,r16		; " 
                                 
0003e7 e1c9                      	ldi YL,low(arg)    		;Z left pointing to file size at 24
0003e8 e0d1                      	ldi YH,high(arg)   		;file size is qword but we will never exceed dword
0003e9 d1bc                      	rcall mov4
                                 		
0003ea 9130 011f                 	lds r19,SectorsPerCluster
0003ec e009                      	ldi r16,9
0003ed 0f30                      	add r19,r16
0003ee d1ce                      	rcall LsrArg			;Divide by SectorsPerCluster + 512 bytes per sector
0003ef f44e                      	brtc jp01			;If t not set then no carry (no remainder)
0003f0 91e0 0119                 	lds ZL,arg
0003f2 91f0 011a                 	lds ZH,arg+1
0003f4 9631                      	adiw ZH:ZL,1
0003f5 93e0 0119                 	sts arg,ZL
0003f7 93f0 011a                 	sts arg+1,ZH
0003f9 9130 011f                 jp01:	lds r19,SectorsPerCluster
0003fb d180                      	rcall LslArg			;Size in clusters back to size in sectors
                                 
0003fc 9100 0119                 	lds r16,arg			;Save sector step
0003fe 9300 0126                 	sts StepSectors,r16		; "
000400 9100 011a                 	lds r16,arg+1			; "
000402 9300 0127                 	sts StepSectors+1,r16		; 
                                 	
000404 9418                      	sez				;Set Z bit (No error)
                                 DiskErr:				;Return error,Z bit cleared
000405 9508                      	ret				;On return will set disk ready status	
                                 	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;	
                                 ; Low level SD card access
                                 ;	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send command to MMC,Uses cmd resp r16 r17 r18 nz=error
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendMMC:
                                     ;4.8ms delay,PNY 1GB had trouble without delay
000406 d157                          	rcall delay1ms
000407 d156                      	rcall delay1ms
000408 d155                      	rcall delay1ms
000409 d154                      	rcall delay1ms
00040a d153                      	rcall delay1ms
                                 		
00040b ef0f                      	ldi r16,0xFF		;
00040c df49                             	rcall SPIWrite	;
00040d 9100 0118                 	lds r16,cmd		; Send the command byte
00040f df46                      	rcall SPIWrite	;
000410 9100 011c                 	lds r16,arg+3		; Send 4 argument bytes starting with MSB
000412 df43                      	rcall SPIWrite	;
000413 9100 011b                 	lds r16,arg+2		;
000415 df40                      	rcall SPIWrite	;
000416 9100 011a                 	lds r16,arg+1		;
000418 df3d                      	rcall SPIWrite	;
000419 9100 0119                 	lds r16,arg		;
00041b df3a                      	rcall SPIWrite	;
00041c 9100 011d                 	lds r16,crc		; Send the CRC7 byte (always use 95)
00041e df37                             	rcall SPIWrite	;
                                 			
                                 WaitResp:
00041f 2722                      	clr r18
                                 lp10:
                                     ;.69ms delay,PNY 1GB had trouble without delay	
000420 d13d                      	rcall delay1ms		
                                 				
000421 df33                      	rcall SPIRead	;
000422 9110 011e                 	lds r17,resp
000424 1701                      	cp r16,r17		; expected response?
000425 f021                      	breq jp11		; YES - return
000426 952a                      	dec r18			; waiting period is over?
000427 f7c1                             	brne lp10		; NO - keep waiting
000428 d126                      	rcall SendErrorSPI	;
000429 9498                      	clz			; Clear zero flag for time out
00042a 9508                      jp11:	ret			;
                                 
                                     
                                 ;********************************************************************
                                 ; Init SD/MMC memory card
                                 ;******************************************************************** 
                                 MMCInit:	
00042b 9ac4                      	sbi PortB,CS		    ; disable MMC
00042c e01a                      	ldi r17,10		    ; Send 80 dummy clocks
                                 lp20:
00042d df27                      	rcall SPIRead	    ;
00042e 951a                             	dec R17			    ;
00042f f7e9                      	brne lp20		    ;
000430 98c4                              cbi PortB,CS		    ; enable MMC         
                                 SendCMD0:
000431 e400                      	ldi r16,0x40		    ; CMD0 GO_IDLE_STATE
000432 9300 0118                 	sts cmd,r16              
000434 2700                             	clr r16			    ; LSB
000435 9300 0119                 	sts arg,r16                ; 0x00000000
000437 9300 011a                 	sts arg+1,r16              ;	
000439 9300 011b                 	sts arg+2,r16              ;	
00043b 9300 011c                 	sts arg+3,r16              ; MSB
00043d e905                      	ldi r16,0x95
00043e 9300 011d                        	sts crc,r16
000440 e001                      	ldi r16,1
000441 9300 011e                 	sts resp,r16		    ; expected response cnt 8
000443 dfc2                      	rcall SendMMC		    ;
000444 f761                             	brne SendCMD0		    ; Expected response timed out
                                 SendCMD8:
000445 e408                      	ldi r16,0x48		    ; CMD8 SEND_IF_COND
000446 9300 0118                 	sts cmd,r16
000448 ea0a                      	ldi r16,0xAA		    ; LSB
000449 9300 0119                 	sts arg,r16                ; 0x000001AA
00044b e001                      	ldi r16,0x01		    ;
00044c 9300 011a                 	sts arg+1,r16              ;
00044e 2700                      	clr r16			    ;
00044f 9300 011b                 	sts arg+2,r16              ;
000451 9300 011c                 	sts arg+3,r16              ; MSB
000453 e807                      	ldi r16,0x87
000454 9300 011d                 	sts crc,r16
000456 e001                      	ldi r16,1		    ; Response V2=0x01 0x000001AA or V1=0x05
000457 9300 011e                 	sts resp,r16
000459 dfac                      	rcall SendMMC               ; 
00045a f571                      	brne SendCMD1
00045b def9                      	rcall SPIRead		    ; need to clear 0x000001AA
00045c def8                      	rcall SPIRead		    ;	
00045d def7                              rcall SPIRead		    ;	      	
00045e def6                      	rcall SPIRead		    ;			; 
                                 			
                                 ;ACMD41 (CMD55+CMD41)			
                                 SendCMD55:
00045f e707                      	ldi r16,0x77		    ; CMD55 APP_CMD
000460 9300 0118                 	sts cmd,r16              
000462 2700                             	clr r16			    ; LSB
000463 9300 0119                 	sts arg,r16                ; 0x00000000
000465 9300 011a                 	sts arg+1,r16              ;	
000467 9300 011b                 	sts arg+2,r16              ;	
000469 9300 011c                 	sts arg+3,r16              ; MSB
00046b ef0f                      	ldi r16,0xFF
00046c 9300 011d                        	sts crc,r16
00046e e001                      	ldi r16,1
00046f 9300 011e                 	sts resp,r16		    ; expected response
000471 df94                      	rcall SendMMC		    ;
000472 f761                             	brne SendCMD55		    ;  Expected response timed out	
                                 SendCMD41: 	
000473 e609                      	ldi r16,0x69		    ; CMD41 SD_SEND_OP_COND
000474 9300 0118                 	sts cmd,r16              
000476 2700                             	clr r16			    ; LSB
000477 9300 0119                 	sts arg,r16                ; 0x40000000
000479 9300 011a                 	sts arg+1,r16              ;
00047b 9300 011b                 	sts arg+2,r16              ;
00047d e400                      	ldi r16,0x40
00047e 9300 011c                 	sts arg+3,r16              ; MSB
000480 ef0f                      	ldi r16,0xFF
000481 9300 011d                        	sts crc,r16
000483 2700                      	clr r16
000484 9300 011e                 	sts resp,r16		    ; expected response
000486 df7f                      	rcall SendMMC		    ;
000487 f6b9                             	brne SendCMD55		    ;  Expected response timed out
000488 c014                      	rjmp SendCMD58
                                 
                                 SendCMD1:
000489 e401                      	ldi r16,0x41		    ; CMD1 SEND_OP_COND
00048a 9300 0118                 	sts cmd,r16              
00048c 2700                             	clr r16			    ; LSB
00048d 9300 0119                 	sts arg,r16                ; 0x00000000
00048f 9300 011a                 	sts arg+1,r16              ;	
000491 9300 011b                 	sts arg+2,r16              ;	
000493 9300 011c                 	sts arg+3,r16              ; MSB
000495 ef0f                      	ldi r16,0xFF
000496 9300 011d                        	sts crc,r16
000498 2700                      	clr r16
000499 9300 011e                 	sts resp,r16		    ; expected response
00049b df6a                      	rcall SendMMC		    ;
00049c f761                             	brne SendCMD1		    ;  Expected response timed out
                                    			
                                 SendCMD58:
00049d e70a                      	ldi r16,0x7A		    ; CMD58 READ_OCR
00049e 9300 0118                 	sts cmd,r16              
0004a0 2700                             	clr r16			    ; LSB
0004a1 9300 0119                 	sts arg,r16                ; 0x00000000
0004a3 9300 011a                 	sts arg+1,r16              ;	
0004a5 9300 011b                 	sts arg+2,r16              ;	
0004a7 9300 011c                 	sts arg+3,r16              ; MSB
0004a9 ef0f                      	ldi r16,0xFF
0004aa 9300 011d                        	sts crc,r16
0004ac 2700                      	clr r16
0004ad 9300 011e                 	sts resp,r16		    ; expected response
0004af df56                      	rcall SendMMC		    ;
0004b0 f761                             	brne SendCMD58		    ;  Expected response timed out
                                 
0004b1 e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
0004b2 ede0                      	ldi ZL,low(SDbuffer)	    ; "
0004b3 e034                      	ldi R19,4
                                 lp21:
0004b4 dea0                      	rcall SPIRead		    ; Get MSByte 1 of 4 OCR register
0004b5 9301                      	st Z+,r16		    ; Save OCR to buffer
0004b6 953a                      	dec R19
0004b7 f7e1                      	brne lp21
0004b8 9100 02d0                 	lds r16,SDbuffer
0004ba 9300 0117                 	sts ocr,r16		    ; bit6=1 SDHC
                                 
                                 SendCMD9:
0004bc e409                      	ldi r16,0x49		    ; CMD9 READ_CSD
0004bd 9300 0118                 	sts cmd,r16              
0004bf 2700                             	clr r16			    ;
0004c0 9300 011e                 	sts resp,r16		    ; expected response
0004c2 df43                      	rcall SendMMC		    ;
0004c3 f7c1                      	brne SendCMD9		    ; Expected response timed out
0004c4 ef0e                      	ldi r16,0xFE
0004c5 9300 011e                 	sts resp,r16
0004c7 df57                      	rcall WaitResp		    ; Wait for FE Start
0004c8 f799                      	brne SendCMD9
0004c9 e132                      	ldi r19,18
                                 lp22:	
0004ca de8a                      	rcall SPIRead
0004cb 953a                      	dec r19
0004cc f7e9                      	brne lp22
                                 
                                 SendCMD10:
0004cd e40a                          	ldi r16,0x4A		    ; CMD10 READ_CID
0004ce 9300 0118                 	sts cmd,r16              
0004d0 2700                             	clr r16			    ;
0004d1 9300 011e                 	sts resp,r16		    ; expected response
0004d3 df32                      	rcall SendMMC		    ;
0004d4 f7c1                      	brne SendCMD10		    ; Expected response timed out
0004d5 ef0e                      	ldi r16,0xFE
0004d6 9300 011e                 	sts resp,r16
0004d8 df46                      	rcall WaitResp		    ; Wait for FE Start
0004d9 f799                      	brne SendCMD10
0004da e132                          	ldi r19,18
                                 lp23:	
0004db de79                      	rcall SPIRead
0004dc 953a                      	dec r19
0004dd f7e9                      	brne lp23
                                 
0004de de7c                      	rcall FullThrottle
                                 			
                                 ; Let fall thru to Set Block			
                                 ;********************************************************************
                                 ; CMD16 SET_BLOCKLEN default 512
                                 ; The only valid block length for write is 512!
                                 ; Read is 1 to 2048
                                 ;********************************************************************
                                 SetBlockMMC: 
0004df 98c4                      	cbi PortB,CS		    ; enable MMC         
0004e0 e500                      	ldi r16,0x50		    ; CMD16 SET_BLOCKLEN
0004e1 9300 0118                 	sts cmd,r16              
0004e3 2700                             	clr r16			    ; LSB
0004e4 9300 0119                 	sts arg,r16                ; 0x00000200 (512 block)
0004e6 e002                      	ldi r16,2
0004e7 9300 011a                 	sts arg+1,r16              ;
0004e9 2700                      	clr r16
0004ea 9300 011b                 	sts arg+2,r16              ;	
0004ec 9300 011c                 	sts arg+3,r16              ; MSB
0004ee 2700                      	clr r16
0004ef 9300 011d                 	sts crc,r16
0004f1 9300 011e                 	sts resp,r16		    ; expected response
0004f3 df12                      	rcall SendMMC		    ;
0004f4 f751                             	brne SetBlockMMC	    ; Expected response timed out
0004f5 9ac4                      	sbi PortB,CS		    ; Disable MMC
0004f6 9508                      	ret 							;
                                 
                                 ;********************************************************************
                                 ; CMD24 WRITE_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ; Exit nz=write error
                                 ;********************************************************************
                                 WriteMMC:			    ;Write 1st 256 bytes of sector
0004f7 98c4                      	cbi PortB,CS		    ; enable MMC   
0004f8 d070                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
0004f9 9100 0117                 	lds r16,ocr
0004fb ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
0004fc d07e                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 lp40:
0004fd e508                      	ldi r16,0x58		    ; CMD24 WRITE_BLOCK
0004fe 9300 0118                 	sts cmd,r16 
000500 2700                      	clr r16
000501 9300 011d                 	sts crc,r16
000503 9300 011e                 	sts resp,r16		    ; expected response
000505 df00                      	rcall SendMMC		    ;
000506 f7b1                             	brne lp40		    ; Expected response timed out
                                 	
000507 de4d                      	rcall SPIRead		    ; write prefix (Read writes FFFF)
000508 de4c                      	rcall SPIRead
000509 ef0e                      	ldi r16,0xFE		    ; Send start data token
00050a de4b                      	rcall SPIWrite
                                 	
00050b e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
00050c ede0                      	ldi ZL,low(SDbuffer)	    ; "
00050d 2733                      	clr R19			    ; Write 256 bytes to SD
                                 ;Write 1st 256 bytes of sector	
                                 lp41:
00050e 9101                      	ld r16,Z+
00050f de46                      	rcall SPIWrite		    ; Write data byte
000510 953a                      	dec R19
000511 f7e1                      	brne lp41
                                 ;Write 2nd 256 bytes of sector    		 
                                 lp42:
000512 9101                      	ld r16,Z+
000513 de42                      	rcall SPIWrite		    ; Write data byte
000514 953a                      	dec R19
000515 f7e1                      	brne lp42				
000516 de3e                      	rcall SPIRead		    ; write 2 bytes CRC 0xFF (Read writes FFFF)
000517 de3d                      	rcall SPIRead		    ;  "
                                 	    
000518 de3c                      	rcall SPIRead		    ; was data accepted			
000519 710f                      	andi r16,0x1F
00051a 3005                      	cpi r16,5
00051b f449                      	brne jp45
00051c ef0f                      	ldi r16,0xFF		    ; wait for 0xFF
00051d 9300 011e                 	sts resp,r16
00051f deff                      	rcall WaitResp
000520 f421                      	brne jp45
000521 d050                      	rcall RestoreArg
000522 9ac4                      	sbi PortB,CS		    ; Disable MMC
000523 9418                      	sez			    ;Set zero fla
000524 9508                             	ret			    ; normal return z-flag set
                                 jp45:
000525 d04c                      	rcall RestoreArg
000526 d028                      	rcall SendErrorSPI         
000527 9ac4                      	sbi PortB,CS		    ; Disable MMC
000528 9498                      	clz			    ;Clr zero flag
000529 9508                      	ret			    ; write error return z-flag clear
                                  			
                                 			
                                       		
                                 ;********************************************************************
                                 ; CMD17 READ_BLOCK 512 bytes
                                 ; Entry ARG = 4 byte sector
                                 ;********************************************************************
                                 ReadMMC:			    ;Read 1st 256 bytes of sector
00052a 98c4                      	cbi PortB,CS		    ; enable MMC   
00052b d03d                      	rcall SaveArg		    ; Save argument,in case multipled
                                 	
00052c 9100 0117                 	lds r16,ocr
00052e ff06                      	sbrs r16,ccs		    ; Skip bit 6 is 1 (SDHC)
00052f d04b                      	rcall Mul512Arg		    ; bit 6 is 0 (SDSC)
                                 lp50:
000530 e501                      	ldi r16,0x51		    ; CMD17 READ_SINGLE_BLOCK
000531 9300 0118                 	sts cmd,r16 
000533 2700                      	clr r16
000534 9300 011d                 	sts crc,r16
000536 9300 011e                 	sts resp,r16		    ; expected response
000538 decd                      	rcall SendMMC		    ;
000539 f7b1                             	brne lp50		    ; Expected response timed out
                                 	
00053a ef0e                      	ldi r16,0xFE		    ; Send start data token
00053b 9300 011e                 	sts resp,r16
00053d dee1                      	rcall WaitResp		    ; Wait for FE Start
00053e f789                      	brne lp50
                                 ;Read 1st 256 bytes of sector	
00053f e0f2                      	ldi ZH,high(SDbuffer)	    ; Get address to buffer
000540 ede0                      	ldi ZL,low(SDbuffer)	    ; "
000541 2733                      	clr R19			    ; Always read 256 the size of buffer
                                 lp51:
000542 de12                      	rcall SPIRead		    ; Get data byte
000543 9301                      	st Z+,r16
000544 953a                      	dec R19
000545 f7e1                      	brne lp51
                                 ;Read 2nd 256 bytes of sector    		 
                                 lp52:
000546 de0e                      	rcall SPIRead		    ; Get data byte
000547 9301                      	st Z+,r16
000548 953a                      	dec R19
000549 f7e1                      	brne lp52		
00054a de0a                      	rcall SPIRead		    ; read 2 bytes CRC	
00054b de09                      	rcall SPIRead		    ; and discard	
00054c 9ac4                      	sbi PortB,CS		    ; Disable MMC
00054d d024                       	rcall RestoreArg
00054e 9508                         	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Send error command/response to PC
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 SendErrorSPI:
00054f ddae                             	rcall USARTWrite	    ; Send response received
000550 9100 011e                 	lds r16,resp		    
000552 ddab                      	rcall USARTWrite	    ; Send expected response
000553 9100 0118                 	lds r16,cmd
000555 dda8                      	rcall USARTWrite	    ; Send cmd used
000556 94aa                      	dec r10
                                 ErrLP:	
000557 f3f9                      	breq ErrLP		    ; Keep from runnig away,Until reset
000558 9508                      	ret			    ; Fail 2 or 3 times on start,Just return 
                                 	
                                 SendErrorMedia:
000559 0000                      	nop
00055a 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 dlylong:
00055b 931f                      	push r17	;
00055c 2711                      	clr r17		;
00055d c002                      	rjmp jp51
                                 delay1ms:		;  15431x.0625us aprox 1ms,not exact(.965ms)
00055e 931f                      	push r17	;   2
00055f e114                      	ldi r17,20	;   1
000560 930f                      jp51:	push r16	;   2
000561 2700                      	clr r16		;   1
000562 950a                      dly1:	dec r16		; 768x20=15360          
000563 f7f1                              brne dly1	; 
000564 951a                      	dec r17		; 3x20=60   
000565 f7e1                      	brne dly1
000566 910f                      	pop r16		;   2
000567 911f                      	pop r17 	;   2
000568 9508                      	ret		;   1
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                  SaveArg:   
000569 9060 0119                     	lds r6,arg		; Save argument,in case multipled
00056b 9070 011a                   	lds r7,arg+1
00056d 9080 011b                   	lds r8,arg+2
00056f 9090 011c                   	lds r9,arg+3
000571 9508                      	ret
                                 RestoreArg:
000572 9290 011c                 	sts arg+3,r9		; Restore argument
000574 9280 011b                 	sts arg+2,r8 
000576 9270 011a                 	sts arg+1,r7  
000578 9260 0119                 	sts arg,r6
00057a 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 Mul512Arg:
00057b e039                      	ldi r19,9		; multiply arg by 512
                                 LslArg:				; shift arg left per r19
                                 lp60:	
00057c 9100 0119                 	lds r16,arg
00057e 0f00                      	lsl r16
00057f 9300 0119                 	sts arg,r16
000581 9100 011a                 	lds r16,arg+1
000583 1f00                      	rol r16
000584 9300 011a                 	sts arg+1,r16
000586 9100 011b                 	lds r16,arg+2
000588 1f00                      	rol r16
000589 9300 011b                 	sts arg+2,r16
00058b 9100 011c                 	lds r16,arg+3
00058d 1f00                      	rol r16
00058e 9300 011c                 	sts arg+3,r16
000590 953a                      	dec r19
000591 f751                      	brne lp60
000592 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000593 93ef                      cmpstr:	push ZL
000594 93ff                      	push ZH
000595 93cf                      	push YL
000596 93df                      	push YH
                                 		
000597 018f                      	movw r17:r16,ZH:ZL  ;LPM only works with Z
000598 01fe                      	movw ZH:ZL,YH:YL
000599 01e8                      	movw YH:YL,r17:r16
                                   	
00059a 9105                      lp07:	lpm r16,Z+
00059b 3f0f                      	cpi r16,0xFF	;Check end of string
00059c f021                      	breq jp07
00059d 9119                      	ld r17,Y+
00059e 1701                      	cp r16,r17
00059f f409                      	brne jp07	;Not equal,return
0005a0 cff9                      	rjmp lp07	;Next char
0005a1 91df                      jp07:	pop YH
0005a2 91cf                      	pop YL
0005a3 91ff                      	pop ZH
0005a4 91ef                      	pop ZL
0005a5 9508                      	ret		
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005a6 e004                      mov4:	ldi r16,4		    ;
0005a7 9111                      lp01:	ld r17,Z+ 
0005a8 9319                      	st Y+,r17
0005a9 950a                      	dec r16
0005aa f7e1                      	brne lp01
0005ab 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Add Dword pointed to by X & Y Result pointed to by X
                                 AddDword:
0005ac 910c                      	ld r16,X
0005ad 9119                      	ld r17,Y+
0005ae 0f01                      	add r16,r17
0005af 930d                      	st X+,r16
                                 
0005b0 910c                      	ld r16,X
0005b1 9119                      	ld r17,Y+
0005b2 1f01                      	adc r16,r17
0005b3 930d                      	st X+,r16
                                 
0005b4 910c                      	ld r16,X
0005b5 9119                      	ld r17,Y+
0005b6 1f01                      	adc r16,r17
0005b7 930d                      	st X+,r16
                                 
0005b8 910c                      	ld r16,X
0005b9 9119                      	ld r17,Y+
0005ba 1f01                      	adc r16,r17
0005bb 930d                      	st X+,r16
0005bc 9508                      	ret
                                 
                                 ; shift arg right per r19
0005bd 94e8                      LsrArg:	clt			
0005be 9100 011c                 lp61:	lds r16,arg+3
0005c0 9506                      	lsr r16
0005c1 9300 011c                 	sts arg+3,r16
0005c3 9100 011b                 	lds r16,arg+2
0005c5 9507                      	ror r16
0005c6 9300 011b                 	sts arg+2,r16
0005c8 9100 011a                 	lds r16,arg+1
0005ca 9507                      	ror r16
0005cb 9300 011a                 	sts arg+1,r16
0005cd 9100 0119                 	lds r16,arg
0005cf 9507                      	ror r16
0005d0 9300 0119                 	sts arg,r16
0005d2 f408                      	brcc jp61
0005d3 9468                      	set		;Set t bit if carry
0005d4 953a                      jp61:	dec r19
0005d5 f741                      	brne lp61
0005d6 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;Xmodem Volume transfer
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0005d7 983a                      XMODEM:	cbi PortE,2		;Release TI
0005d8 dc6d                      	rcall WaitTIwrite	;Wait for volume# from TI
0005d9 9150 0103                 	lds r21,fdcData		;Save volume in r21
                                 	
0005db dc6a                      	rcall WaitTIwrite	;Wait Telnet mode from TI
0005dc 9100 0103                 	lds r16,fdcData
0005de 9300 012f                 	sts TELFLG,r16
                                 	
0005e0 dc65                      	rcall WaitTIwrite	;Wait send/receive mode from TI
0005e1 9140 0103                 	lds r20,fdcData		;Save in r20
                                 	
0005e3 b70b                      	in r16,GICR		;Disable INT2
0005e4 7d0f                      	cbr r16,1<<INT2		; "
0005e5 bf0b                      	out GICR,r16		; "	
0005e6 e800                      	ldi r16,0x80		;Set TI to read status NotReady 
0005e7 bb0b                      	out PortA,r16		;Until Int2 enabled
                                 
0005e8 2700                      	clr r16
0005e9 9300 012e                 	sts CRCFLG,r16		;Init CRC flag to checksum mode
0005eb 9300 012c                 	sts PAKNUM+1,r16	;Init packet # to 1
0005ed 9503                      	inc r16			; "
0005ee 9300 012b                 	sts PAKNUM,r16		; "
0005f0 dce4                      	rcall Disk2Sector	;Entry r21=disk, Exit arg=SD sector address
0005f1 d13f                      	rcall BUFFL		;Clear buffer
                                 	
0005f2 2344                      	tst r20			;Send/Receive
0005f3 f409                      	brne SEND 
0005f4 c057                      	rjmp RECV	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ; Send Volume	
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
0005f5 d0ed                      SEND:	rcall SERRD		;Wait for starting NAK
0005f6 f3f1                      	breq SEND		;Timed out,Loop back
0005f7 3118                      	cpi r17,CAN		;Check if remote sent cancel
0005f8 f1d1                      	breq CANRL1		;Cancel Exit Can't continue
0005f9 3115                      	cpi r17,NAK		;Did remote sent checksum start
0005fa f029                      	breq NXTSEC		;flag already set for checksum mode
0005fb 3413                      	cpi r17,'C'		;Did remote sent CRC start
0005fc f7c1                      	brne SEND
0005fd e001                      	ldi r16,1		;Set flag for CRC mode
0005fe 9300 012e                 	sts CRCFLG,r16		; "		
                                 
000600 d139                      NXTSEC:	rcall RDSEC
000601 e011                      SAMSEC:	ldi r17,SOH		;Send start
000602 d11f                      	rcall UARTWR		; "	
000603 9110 012b                 	lds r17,PAKNUM		;Send LSByte packet#
000605 d11c                      	rcall UARTWR		; "
000606 9510                      	com r17			;Send LSByte inverted packet#
000607 d11a                      	rcall UARTWR		;
                                 	
000608 e0b2                      	ldi XH,high(SDbuffer)	;Set SDbuffer pointer
000609 eda0                      	ldi XL,low(SDbuffer)
00060a 2799                      	clr r25
00060b 9180 012b                 	lds r24,PAKNUM
00060d 958a                      	dec r24			;(1-4) to (0-3)
00060e 7083                      	andi r24,0x03		;Keep 2 lsbits
00060f e007                      	ldi r16,7		;r25:24 times 128
000610 d144                      	rcall lsl_r25r24	; "
000611 0fa8                      	add XL,r24		;Add to SDbuffer pointer
000612 1fb9                      	adc XH,r25
                                 	
000613 2400                      	clr r0			;Init CRC
000614 2411                      	clr r1
000615 9200 012d                 	sts CHKSUM,r0		;Init checksum
000617 e820                      	ldi r18,128		;Init byte counter
000618 911d                      lp29:	ld r17,X+
000619 d108                      	rcall UARTWR
00061a 9100 012d                 	lds r16,CHKSUM
00061c 0f01                      	add r16,r17
00061d 9300 012d                 	sts CHKSUM,r16
00061f d0a7                      	rcall CRC16		;r17 added to crc in r1:r0
000620 952a                      	dec r18
000621 f7b1                      	brne lp29
                                 
000622 9100 012e                 	lds r16,CRCFLG
000624 2300                      	tst r16
000625 f029                      	breq jp29
                                 
000626 2d11                      	mov r17,r1		;Send high byte of CRC
000627 d0fa                      	rcall UARTWR
000628 2d10                      	mov r17,r0		;Send low byte of CRC
000629 d0f8                      	rcall UARTWR
00062a c003                      	rjmp lp30
                                 	
00062b 9110 012d                 jp29:	lds r17,CHKSUM		;Send checksum
00062d d0f4                      	rcall UARTWR
                                 
00062e d0b4                      lp30:	rcall SERRD		;Wait for Response
                                 ;	breq SAMSEC		;Timed out,Assume NAK
00062f f3f1                      	breq lp30
000630 3115                      	cpi r17,NAK		;If NAK
000631 f279                      	breq SAMSEC		;Resend from same sector	
000632 3118                      	cpi r17,CAN		;If remote cancel
000633 f0b1                      CANRL1:	breq CANRLY		;Exit Can't continue
000634 3016                      	cpi r17,ACK		;If not ACK,Ignore
000635 f7c1                      	brne lp30
                                 
                                 ;ACK
000636 9180 012b                 	lds r24,PAKNUM		;Inc byte packet number
000638 9190 012c                 	lds r25,PAKNUM+1
00063a 9601                      	adiw r25:r24,1
00063b 9390 012c                 	sts PAKNUM+1,r25
00063d 9380 012b                 	sts PAKNUM,r24
00063f 3481                      	cpi r24,0x41		;If packet 2881 then done
000640 f411                      	brne jp30		; "
000641 309b                      	cpi r25,0x0B		; "
000642 f021                      	breq jp31		; "
                                 	
000643 7083                      jp30:	andi r24,0x03		;Check if next packet is 1
000644 3081                      	cpi r24,0x01		
000645 f029                      	breq NXTRLY		;Read new sector If zero
000646 cfba                      	rjmp SAMSEC 
                                 	
000647 e014                      jp31:	ldi r17,EOT		;Transfer completed
000648 d0d9                      	rcall UARTWR
000649 c077                      EXTRLY:	rjmp EXIT		;Exit normal
00064a c071                      CANRLY:	rjmp CANCEL
00064b cfb4                      NXTRLY:	rjmp NXTSEC
                                        
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Receive volume
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00064c e028                      RECV: 	ldi r18,8		;Send 'C' 8 times
00064d e413                      lp31:	ldi r17,'C'
00064e d0d3                      	rcall UARTWR
00064f d093                      	rcall SERRD
                                 	
000650 f011                      	breq jp32		;Skip if nothing read
000651 3011                      	cpi r17,SOH 
000652 f019                      	breq jp33		;Jump CRC
000653 952a                      jp32:	dec r18
000654 f7c1                      	brne lp31
000655 c006                      	rjmp NAKLP		;Jump Checksum
                                 ;CRC	
000656 9310 012e                 jp33:	sts CRCFLG,r17		;Set flag 01 for CRC mode	
000658 df02                      	rcall dlylong
000659 df01                      	rcall dlylong
00065a df00                      	rcall dlylong
00065b c008                      	rjmp STARTR		;r17 already SOH
                                 ;Checksum
                                 ;
                                 ;
00065c d0d4                      NAKLP:	rcall BUFFL		;Clear buffer
00065d e115                      	ldi r17,NAK		;1st response NAK to start
00065e defc                      ACKLP:	rcall dlylong
00065f defb                      	rcall dlylong
000660 defa                      	rcall dlylong
000661 d0c0                      	rcall UARTWR		;Send response
000662 d080                      	rcall SERRD		;Get SOH of packet
000663 f3c1                      	breq NAKLP		;Timed out,Resend NAK
                                 ;	
000664 9310 012d                 STARTR:	sts CHKSUM,r17		;Init checksum
000666 3014                      	cpi r17,EOT
000667 f309                      	breq EXTRLY
000668 3118                      	cpi r17,CAN
000669 f301                      	breq CANRLY
00066a 3011                      	cpi r17,SOH
00066b f781                      	brne NAKLP	
                                 
00066c d076                      	rcall SERRD		;Get packet number
00066d f371                      	breq NAKLP		;Timed out,Resend NAK	
00066e 9100 012d                 	lds r16,CHKSUM		;Add packet number to checksum
000670 0f01                      	add r16,r17
000671 9300 012d                 	sts CHKSUM,r16
000673 9100 012b                 	lds r16,PAKNUM		;LSByte packet#	
000675 1710                      	cp r17,r16		;Does Received packet = Expected packet
000676 f729                      	brne NAKLP	
                                 
000677 d06b                      	rcall SERRD		;Get inverted packet number
000678 f319                      	breq NAKLP		;Timed out,Resend NAK
000679 9100 012d                 	lds r16,CHKSUM		;Add Inv packet number to checksum
00067b 0f01                      	add r16,r17		;Sets Z only for r0 thru r7
00067c 9300 012d                 	sts CHKSUM,r16
00067e 2300                      	tst r16
00067f f6e1                      	brne NAKLP		;Does SOH+PACKET#+INV PACKET#=0
                                 	
000680 e0b2                      	ldi XH,high(SDbuffer)	;Set SDbuffer pointer
000681 eda0                      	ldi XL,low(SDbuffer)
000682 2799                      	clr r25
000683 9180 012b                 	lds r24,PAKNUM
000685 958a                      	dec r24			;(1-4) to (0-3)
000686 7083                      	andi r24,0x03		;Keep 2 lsbits
000687 e007                      	ldi r16,7		;r25:24 times 128
000688 d0cc                      	rcall lsl_r25r24	; "
000689 0fa8                      	add XL,r24		;Add to SDbuffer pointer
00068a 1fb9                      	adc XH,r25
                                 	
00068b 2400                      	clr r0			;Init CRC
00068c 2411                      	clr r1
00068d 9200 012d                 	sts CHKSUM,r0		;Init checksum
00068f e820                      	ldi r18,128		;Init byte counter
000690 d052                      lp34:	rcall SERRD		;Read packet
000691 f251                      	breq NAKLP		;Timed out,Resend NAK
000692 931d                      	st X+,r17
000693 9100 012d                 	lds r16,CHKSUM		;Add byte to checksum
000695 0f01                      	add r16,r17
000696 9300 012d                 	sts CHKSUM,r16
000698 d02e                      	rcall CRC16		;r17 added to crc in r1:r0
000699 952a                      	dec r18
00069a f7a9                      	brne lp34
                                 
00069b d047                      	rcall SERRD		;Get Checksum or MSByte of CRC
00069c f059                      	breq NAKRLY		;Timed out,Resend NAK
00069d 9100 012e                 	lds r16,CRCFLG
00069f 2300                      	tst r16
0006a0 f041                      	breq jp35
                                 ;CRC
0006a1 1511                      	cp r17,r1		;Compare of MSByte CRC
0006a2 f429                      	brne NAKRLY
0006a3 d03f                      	rcall SERRD		;Get LSByte CRC
0006a4 f019                      	breq NAKRLY		;Timed out,Resend NAK
0006a5 1510                      	cp r17,r0		;Compare LSByte of CRC
0006a6 f409                      	brne NAKRLY	
0006a7 c005                      	rjmp jp36
                                 	
0006a8 cfb3                      NAKRLY: rjmp NAKLP
                                 ;Checksum	
0006a9 9100 012d                 jp35:	lds r16,CHKSUM
0006ab 1710                      	cp r17,r16
0006ac f7d9                      	brne NAKRLY
                                 
                                 ; ACK
0006ad 9180 012b                 jp36:	lds r24,PAKNUM		;Inc byte packet number
0006af 9190 012c                 	lds r25,PAKNUM+1
0006b1 9601                      	adiw r25:r24,1
0006b2 9390 012c                 	sts PAKNUM+1,r25
0006b4 9380 012b                 	sts PAKNUM,r24	
                                 	
0006b6 7083                      	andi r24,0x03		;Check if next packet is 1
0006b7 3081                      	cpi r24,0x01		
0006b8 f409                      	brne jp37		;Write SDbuffer If buffer finished
0006b9 d083                      	rcall WRSEC		;
0006ba e016                      jp37:	ldi r17,ACK		;Send ACK response
0006bb cfa2                      	rjmp ACKLP		;Get next packet
                                     
0006bc e900                      CANCEL:	ldi r16,0x90		;TI status NotReady & Error 
0006bd bb0b                      	out PortA,r16		;	
0006be 2700                      	clr r16			;Give TI time to read status
0006bf 950a                      lp35:	dec r16			;		
0006c0 f7f1                      	brne lp35		;
                                 	
0006c1 e016                      EXIT:	ldi r17,ACK
0006c2 d05f                      	rcall UARTWR    
0006c3 b70b                      	in r16,GICR		;Enable INT2
0006c4 6200                      	sbr r16,1<<INT2		; "
0006c5 bf0b                      	out GICR,r16		; "
                                 	
0006c6 9508                              ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; CRC-16/XMODEM
                                 ;
                                 ; On entry r17  = byte
                                 ;          r0 = old CRC low byte
                                 ;          r1 = old CRC high byte
                                 ; On exit  r0 = new CRC low byte
                                 ;          r1 = new CRC high byte
                                 ;          r17,r2 = undefined
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 CRC16:
0006c7 2511                              eor     r17,r1           
0006c8 2e11                              mov     r1,r17            
0006c9 9512                              swap    r17               
0006ca 701f                              andi    r17,0x0f          
0006cb 2511                              eor     r17,r1            
0006cc 2e11                              mov     r1,r17            
0006cd 9512                              swap    r17               
0006ce 2e21                              mov     r2,r17            
0006cf 7f10                              andi    r17,0xf0         
0006d0 2510                              eor     r17,r0 
                                 	
0006d1 931f                      	push	r17		; xch r17,r2            
0006d2 922f                      	push	r2
0006d3 911f                      	pop	r17
0006d4 902f                      	pop	r2
                                 	
0006d5 fb17                      	bst	r17,7		; rl r17
0006d6 0f11                      	lsl	r17
0006d7 f910                      	bld	r17,0
                                 	
0006d8 2e01                              mov     r0,r17            
0006d9 7e10                              andi    r17,0xe0         
0006da 2511                              eor     r17,r1 
                                 	
0006db 931f                      	push	r17		; xch r17,r0            
0006dc 920f                      	push	r0
0006dd 911f                      	pop	r17
0006de 900f                      	pop	r0
                                 	
0006df 711f                      	andi    r17,0x1f          
0006e0 2512                              eor     r17,r2            
0006e1 2e11                              mov     r1,r17            
0006e2 9508                              ret
                                 ;
                                 ;Exit r17 = byte read form USART
                                 ;Equ set if timed out
                                 ;discard nul after cr
0006e3 d00e                      SERRD:	rcall UARTST		
0006e4 f061                      	breq jp42		;Equ set if timed out
0006e5 d023                      	rcall UARTRD		;data returned in r16
0006e6 2f10                      	MOV r17,R16
                                 	
0006e7 9100 012f                 	lds r16,TELFLG		;If telnet
0006e9 2300                      	tst r16
0006ea f029                      	breq jp49
                                 	
0006eb 301d                      	cpi r17,0x0D		;Check 13 cr
0006ec f419                      	brne JP49		;
                                 		
0006ed d004                      	rcall UARTST		
0006ee f011                      	breq jp42		;Equ set if timed out
0006ef d019                      	rcall UARTRD		;data returned in r16
                                 	
0006f0 9498                      jp49:	clz			;Clear EQU status
0006f1 9508                      jp42:	ret
                                 ;
                                 ;Read USART status into r16
                                 ;
0006f2 e555                      UARTST:	ldi r21,85		;85=10Sec
0006f3 2744                      	clr r20
0006f4 2733                      	clr r19
                                 	
                                 lp36:	
0006f5 b10a                      	in r16,UCSR0B		;Check if RXC interrupt enabled
0006f6 fd07                      	sbrc r16,RXCIE		;Skip if not set
0006f7 c004                      	rjmp jp50		;Get data from buffer
                                 	
0006f8 b10b                      	in r16,UCSR0A		;Get status here, Interrrupt disabled
0006f9 7800                      	andi r16,0x80
0006fa f039                      	breq jp43		;No data
0006fb c00c                      	rjmp jp44		;Data in USART
                                 	
0006fc 9100 012a                 jp50:	lds r16,SerCnt		;Get status here, Interrrupt enabled
0006fe 3000                      	cpi r16,0
0006ff f011                      	breq jp43		;No data	    
000700 ee02                      	ldi r16,226		;Data in buffer, Send status 226
000701 c006                      	rjmp jp44		;Equ not set
                                 	
                                 jp43:	
000702 953a                      	dec r19
000703 f789                      	brne lp36
000704 954a                      	dec r20
000705 f779                      	brne lp36
000706 955a                      	dec r21
000707 f769                       	brne lp36		;Timed out, EQU set
                                     
000708 9508                      jp44:	ret
                                 ;
                                 ;Read USART data into r16
                                 ;
                                 UARTRD: 
000709 b10a                      	in r16,UCSR0B		;Check if RXC interrupt enabled
00070a fd07                      	sbrc r16,RXCIE		;Skip if not set
00070b c002                      	rjmp jp47		;Get data from buffer
00070c b10c                      	in r16,UDR		;Get data from USART
00070d c013                      	rjmp jp48
                                    
00070e 9100 012a                 jp47:	lds r16,SerCnt
000710 3000                      	cpi r16,0
000711 f079                      	breq jp48		;Sent data from USART
000712 950a                      	dec r16
000713 9300 012a                 	sts SerCnt,r16
                                 	
000715 e0f1                      	ldi ZH,high(Serbuffer)
000716 e3e0                      	ldi ZL,low(Serbuffer)
000717 9100 0129                 	lds r16,SerRdPtr	;ptr Status byte
000719 0fe0                      	add ZL,r16		;Point Z to Char byte
00071a 9503                      	inc r16			;ptr next entry
00071b 3a00                      	cpi r16,Serbuffsize
00071c f409                      	brne jp46
00071d 2700                      	clr r16
00071e 9300 0129                 jp46:	sts SerRdPtr,r16
000720 8100                      	ld r16,Z		;Get char from buffer
                                 
000721 9508                      jp48:	ret 
                                 ;
                                 ;Send data in r17 to USART
                                 ;Add nul after cr & 2nd ff after ff
000722 2f01                      UARTWR:	mov r16,r17
000723 dbda                      	rcall USARTWrite	;Write data in r16 to USART
000724 9100 012f                 	lds r16,TELFLG
000726 2300                      	tst r16
000727 f041                      	breq jp41		;Return,If not Telnet
                                 	
000728 301d                      	cpi r17,0x0D		;Check 13 cr
000729 f411                      	brne JP39		;
00072a 2700                      	clr r16			;Send 2nd 0x00
00072b c003                      	rjmp JP40
                                 	
00072c 3f1f                      jp39:	cpi r17,0xFF		;Check 255
00072d f411                      	brne JP41		;
00072e ef0f                      	ldi r16,0xFF		;Send 2nd 0xFF
                                 	
00072f dbce                      jp40:	rcall USARTWrite	;Write data in r16 to USART
000730 9508                      jp41:	ret
                                 ;
                                 ; Flush buffer
                                 ;	
000731 dbd0                      BUFFL:	rcall USARTFlush
000732 2700                      	clr r16			;
000733 9300 0129                 	sts SerRdPtr,r16	;Reset pointers
000735 9300 0128                 	sts SerWrPtr,r16
000737 9300 012a                 	sts SerCnt,r16
000739 9508                      	ret
                                 ;
                                 ; Write/Read sector to SD card
                                 ;
00073a ddef                      RDSEC:	rcall ReadMMC
00073b 940c 073e                 	jmp jp38
00073d ddb9                      WRSEC:	rcall WriteMMC
                                 ;Increment arg (next sector)    
00073e e011                      jp38:   ldi r17,1	
00073f 9100 0119                 	lds r16,arg
000741 0f01                      	add r16,r17	    ;Inc doesn't affect carry
000742 9300 0119                 	sts arg,r16
                                 	
000744 2711                      	clr r17
000745 9100 011a                 	lds r16,arg+1
000747 1f01                      	adc r16,r17
000748 9300 011a                 	sts arg+1,r16
                                 	
00074a 9100 011b                 	lds r16,arg+2
00074c 1f01                      	adc r16,r17
00074d 9300 011b                 	sts arg+2,r16
                                 	
00074f 9100 011c                 	lds r16,arg+3
000751 1f01                      	adc r16,r17
000752 9300 011c                 	sts arg+3,r16    
000754 9508                      	ret
                                 ;
                                 ;Logical shift left r25:r24 times r16
                                 ; 
                                 lsl_r25r24:
000755 0f88                      	lsl r24
000756 1f99                      	rol r25
000757 950a                      	dec r16
000758 f7e1                      	brne lsl_r25r24


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega162" register use summary:
x  :  13 y  :  12 z  :  47 r0 :  21 r1 :  18 r2 :   9 r3 :   5 r4 :   6 
r5 :   3 r6 :   2 r7 :   2 r8 :   2 r9 :   2 r10:   2 r11:   0 r12:   0 
r13:   2 r14:   2 r15:   7 r16: 579 r17: 133 r18:  18 r19:  26 r20:  16 
r21:  11 r22:   2 r23:   2 r24:  22 r25:  14 r26:  12 r27:  12 r28:  25 
r29:  26 r30:  57 r31:  54 
Registers used: 33 out of 35 (94.3%)

"ATmega162" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  19 add   :  19 adiw  :  13 and   :   0 
andi  :  12 asr   :   0 bclr  :   0 bld   :   1 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  38 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  : 108 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  :   0 cbi   :  21 cbr   :   3 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  68 cls   :   0 
clt   :   1 clv   :   0 clz   :   3 com   :   2 cp    :  10 cpc   :   0 
cpi   :  64 cpse  :   0 dec   :  44 eor   :   5 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  27 inc   :  11 jmp   :   5 
ld    :  40 ldd   :   0 ldi   : 216 lds   :  99 lpm   :   1 lsl   :   3 
lsr   :   2 mov   :  13 movw  :   3 mul   :   1 muls  :   0 mulsu :   0 
neg   :   1 nop   :   3 or    :   0 ori   :   0 out   :  28 pop   :  28 
push  :  31 rcall : 193 ret   :  51 reti  :   2 rjmp  :  57 rol   :   4 
ror   :   4 sbc   :   0 sbci  :   0 sbi   :  14 sbic  :   6 sbis  :   7 
sbiw  :   4 sbr   :   7 sbrc  :   7 sbrs  :   8 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   2 ses   :   0 set   :   1 sev   :   0 
sez   :   2 sleep :   0 spm   :   0 st    :  22 std   :   1 sts   : 178 
sub   :   2 subi  :   0 swap  :   2 tst   :   7 wdr   :   0 
Instructions used: 60 out of 113 (53.1%)

"ATmega162" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000eb4   3620     44   3664   16384  22.4%
[.dseg] 0x000100 0x0004d0      0    976    976    1024  95.3%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
